/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_mapbox_search-js-react_dist_index-esm_js"],{

/***/ "./node_modules/@mapbox/search-js-core/dist/index-esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@mapbox/search-js-core/dist/index-esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Evented\": function() { return /* binding */ Evented; },\n/* harmony export */   \"LngLat\": function() { return /* binding */ LngLat; },\n/* harmony export */   \"LngLatBounds\": function() { return /* binding */ LngLatBounds; },\n/* harmony export */   \"MapboxAutofill\": function() { return /* binding */ MapboxAutofill; },\n/* harmony export */   \"MapboxError\": function() { return /* binding */ MapboxError; },\n/* harmony export */   \"MapboxSearch\": function() { return /* binding */ MapboxSearch; },\n/* harmony export */   \"MapboxValidate\": function() { return /* binding */ MapboxValidate; },\n/* harmony export */   \"MatchCodeConfidence\": function() { return /* binding */ MatchCodeConfidence; },\n/* harmony export */   \"SearchSession\": function() { return /* binding */ SearchSession; },\n/* harmony export */   \"SessionToken\": function() { return /* binding */ SessionToken; },\n/* harmony export */   \"debounce\": function() { return /* binding */ debounce; },\n/* harmony export */   \"featureToSuggestion\": function() { return /* binding */ featureToSuggestion; },\n/* harmony export */   \"polyfillFetch\": function() { return /* binding */ polyfillFetch; }\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/search/constants.ts\nvar SEARCH_URL = `https://api.mapbox.com/search/v1`;\nvar ENDPOINT_SUGGEST = \"suggest\";\nvar ENDPOINT_RETRIEVE = \"retrieve\";\nvar ENDPOINT_FORWARD = \"forward\";\nvar ENDPOINT_REVERSE = \"reverse\";\nvar SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nvar RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\nvar FORWARD_URL = `${SEARCH_URL}/${ENDPOINT_FORWARD}`;\nvar PERMANENT_FORWARD_URL = `${SEARCH_URL}/permanent/${ENDPOINT_FORWARD}`;\nvar REVERSE_URL = `${SEARCH_URL}/${ENDPOINT_REVERSE}`;\nvar PERMANENT_REVERSE_URL = `${SEARCH_URL}/permanent/${ENDPOINT_REVERSE}`;\n\n// src/LngLat.ts\nvar LngLat = class {\n  constructor(lng, lat) {\n    if (isNaN(lng) || isNaN(lat)) {\n      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n    }\n    this.lng = +lng;\n    this.lat = +lat;\n    if (this.lat > 90 || this.lat < -90) {\n      throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n    }\n    if (this.lng > 180 || this.lng < -180) {\n      throw new Error(\"Invalid LngLat longitude value: must be between -180 and 180\");\n    }\n  }\n  toArray() {\n    return [this.lng, this.lat];\n  }\n  toString() {\n    return `LngLat(${this.lng}, ${this.lat})`;\n  }\n  static convert(input) {\n    if (input instanceof LngLat) {\n      return new LngLat(input.lng, input.lat);\n    }\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLat(Number(input[0]), Number(input[1]));\n    }\n    if (!Array.isArray(input) && typeof input == \"object\" && input !== null && (\"lng\" in input || \"lon\" in input) && \"lat\" in input) {\n      return new LngLat(Number(\"lng\" in input ? input.lng : input.lon), Number(input.lat));\n    }\n    throw new Error(\"`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n  }\n};\n\n// src/LngLatBounds.ts\nvar LngLatBounds = class {\n  constructor(sw, ne) {\n    this._sw = LngLat.convert(sw);\n    this._ne = LngLat.convert(ne);\n  }\n  getSouthWest() {\n    return this._sw;\n  }\n  getNorthEast() {\n    return this._ne;\n  }\n  getNorthWest() {\n    return new LngLat(this.getWest(), this.getNorth());\n  }\n  getSouthEast() {\n    return new LngLat(this.getEast(), this.getSouth());\n  }\n  getWest() {\n    return this._sw.lng;\n  }\n  getSouth() {\n    return this._sw.lat;\n  }\n  getEast() {\n    return this._ne.lng;\n  }\n  getNorth() {\n    return this._ne.lat;\n  }\n  toArray() {\n    return [this._sw.toArray(), this._ne.toArray()];\n  }\n  toFlatArray() {\n    return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat];\n  }\n  toString() {\n    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n  }\n  static convert(input) {\n    if (!input) {\n      throw new Error(\"Invalid LngLatBounds convert value: falsy\");\n    }\n    if (input instanceof LngLatBounds) {\n      return new LngLatBounds(input.getSouthWest(), input.getNorthEast());\n    }\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLatBounds(LngLat.convert(input[0]), LngLat.convert(input[1]));\n    }\n    if (Array.isArray(input) && input.length === 4) {\n      return new LngLatBounds(LngLat.convert([input[0], input[1]]), LngLat.convert([input[2], input[3]]));\n    }\n    throw new Error(\"`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]\");\n  }\n};\n\n// src/utils/uuid.ts\nfunction generateUUID() {\n  const randomString = Date.now().toString(16) + Math.random().toString(16) + Math.random().toString(16);\n  const uuidString = randomString.replace(/\\./g, \"\");\n  const uuid = [\n    uuidString.slice(0, 8),\n    uuidString.slice(8, 12),\n    \"4\" + uuidString.slice(12, 15) + \"-8\" + uuidString.slice(15, 18),\n    uuidString.slice(18, 30)\n  ].join(\"-\");\n  return uuid;\n}\n\n// src/SessionToken.ts\nvar SessionToken = class {\n  constructor(id) {\n    this.id = id != null ? id : generateUUID();\n  }\n  toString() {\n    return this.id;\n  }\n  static convert(token) {\n    return new SessionToken(token instanceof SessionToken ? token.id : token.toString());\n  }\n};\n\n// src/MapboxError.ts\nvar UNKNOWN_ERROR = \"Unknown error\";\nvar MapboxError = class extends Error {\n  constructor(json, statusCode) {\n    super(String(json.message || json.error || UNKNOWN_ERROR));\n    this.name = \"MapboxError\";\n    this.statusCode = statusCode;\n  }\n  toString() {\n    return `${this.name} (${this.statusCode}): ${this.message}`;\n  }\n};\nfunction handleNonOkRes(res) {\n  return __async(this, null, function* () {\n    if (!res.ok) {\n      const json = yield res.json();\n      throw new MapboxError(json, res.status);\n    }\n  });\n}\n\n// src/fetch.ts\nvar _fetchImpl = globalThis.fetch;\nvar _abortControllerImpl = globalThis.AbortController;\nfunction polyfillFetch({ fetch, AbortController }, force = false) {\n  if (!fetch) {\n    throw new Error(\"Fetch implementation must include implementations of `fetch`.\");\n  }\n  if (_fetchImpl && !force) {\n    return;\n  }\n  _fetchImpl = fetch;\n  _abortControllerImpl = AbortController;\n}\nfunction getFetch() {\n  if (!_fetchImpl) {\n    throw new Error(\"Fetch implementation not found. Please include a fetch polyfill in your application or use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.\");\n  }\n  return {\n    fetch: _fetchImpl,\n    AbortController: _abortControllerImpl\n  };\n}\n\n// src/utils/queryParams.ts\nfunction queryParams(...objects) {\n  const params = [];\n  for (const obj of objects) {\n    if (!obj)\n      continue;\n    const entries = Object.entries(obj);\n    for (const [key, value] of entries) {\n      if (value == null)\n        continue;\n      params.push(`${key}=${encodeURIComponent(String(value))}`);\n    }\n  }\n  return params.join(\"&\");\n}\n\n// src/search/MapboxSearch.ts\nvar _getQueryParams, getQueryParams_fn, _getFetchInfo, getFetchInfo_fn;\nvar _MapboxSearch = class {\n  constructor(options = {}) {\n    __privateAdd(this, _getQueryParams);\n    __privateAdd(this, _getFetchInfo);\n    const _a = options, { accessToken } = _a, defaults = __objRest(_a, [\"accessToken\"]);\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _MapboxSearch.defaults), defaults);\n  }\n  suggest(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n      const { sessionToken, signal } = optionsArg;\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n      if (options.eta_type && (!options.origin || !options.navigation_profile)) {\n        throw new Error(\"to provide eta estimate: eta, navigation_profile, and origin are required\");\n      }\n      if (options.origin && !options.navigation_profile) {\n        throw new Error(\"to provide distance estimate: both navigation_profile and origin are required\");\n      }\n      const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n  retrieve(suggestion, optionsArg) {\n    return __async(this, null, function* () {\n      if (!suggestion) {\n        throw new Error(\"suggestion is required\");\n      }\n      if (!this.canRetrieve(suggestion)) {\n        throw new Error(\"suggestion cannot be retrieved\");\n      }\n      const { sessionToken: sessionTokenLike, signal } = optionsArg;\n      const sessionToken = SessionToken.convert(sessionTokenLike);\n      const url = new URL(RETRIEVE_URL);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        session_token: sessionToken.id\n      });\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), __spreadProps(__spreadValues({}, __privateMethod(this, _getFetchInfo, getFetchInfo_fn).call(this, suggestion)), {\n        signal\n      }));\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n  canRetrieve(suggestion) {\n    const action = suggestion.action;\n    if (!action) {\n      return false;\n    }\n    return action.method === \"POST\" && action.endpoint === ENDPOINT_RETRIEVE;\n  }\n  canSuggest(suggestion) {\n    const action = suggestion.action;\n    if (!action) {\n      return false;\n    }\n    return action.method === \"POST\" && action.endpoint === ENDPOINT_SUGGEST;\n  }\n  forward(_0) {\n    return __async(this, arguments, function* (searchText, optionsArg = {}) {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n      const baseUrl = options.permanent ? PERMANENT_FORWARD_URL : FORWARD_URL;\n      const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal: options.signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n  reverse(_0) {\n    return __async(this, arguments, function* (lngLat, optionsArg = {}) {\n      if (!lngLat) {\n        throw new Error(\"lngLat is required\");\n      }\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n      const searchText = typeof lngLat === \"string\" ? lngLat : LngLat.convert(lngLat).toArray().join(\",\");\n      const baseUrl = options.permanent ? PERMANENT_REVERSE_URL : REVERSE_URL;\n      const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        language: options.language,\n        limit: options.limit\n      }, options.types && {\n        types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n      });\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal: options.signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n};\nvar MapboxSearch = _MapboxSearch;\n_getQueryParams = new WeakSet();\ngetQueryParams_fn = function(options) {\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country,\n    limit: options.limit,\n    navigation_profile: options.navigation_profile,\n    eta_type: options.eta_type\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.origin && {\n    origin: typeof options.origin === \"string\" ? options.origin : LngLat.convert(options.origin).toArray().join(\",\")\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  }, options.types && {\n    types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n  });\n};\n_getFetchInfo = new WeakSet();\ngetFetchInfo_fn = function(suggestion) {\n  if (!this.canRetrieve(suggestion) && !this.canSuggest(suggestion)) {\n    throw new Error(\"Suggestion cannot be retrieved or suggested\");\n  }\n  const action = suggestion.action;\n  const body = JSON.stringify(action.body);\n  return {\n    method: action.method,\n    body,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"Content-Length\": body.length.toString()\n    }\n  };\n};\nMapboxSearch.defaults = {\n  language: \"en\"\n};\n\n// src/autofill/constants.ts\nvar SEARCH_URL2 = `https://api.mapbox.com/autofill/v1`;\nvar ENDPOINT_SUGGEST2 = \"suggest\";\nvar ENDPOINT_RETRIEVE2 = \"retrieve\";\nvar SUGGEST_URL2 = `${SEARCH_URL2}/${ENDPOINT_SUGGEST2}`;\nvar RETRIEVE_URL2 = `${SEARCH_URL2}/${ENDPOINT_RETRIEVE2}`;\n\n// src/autofill/MapboxAutofill.ts\nvar _getQueryParams2, getQueryParams_fn2;\nvar _MapboxAutofill = class {\n  constructor(options = {}) {\n    __privateAdd(this, _getQueryParams2);\n    const _a = options, { accessToken } = _a, defaults = __objRest(_a, [\"accessToken\"]);\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _MapboxAutofill.defaults), defaults);\n  }\n  suggest(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n      const { sessionToken, signal } = optionsArg;\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n      const url = new URL(`${SUGGEST_URL2}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return __spreadProps(__spreadValues({}, json), {\n        suggestions: json.suggestions.map((suggestion) => {\n          return __spreadProps(__spreadValues({}, suggestion), {\n            original_search_text: searchText\n          });\n        })\n      });\n    });\n  }\n  retrieve(suggestion, optionsArg) {\n    return __async(this, null, function* () {\n      if (!suggestion) {\n        throw new Error(\"suggestion is required\");\n      }\n      if (!this.canRetrieve(suggestion)) {\n        throw new Error(\"suggestion cannot be retrieved\");\n      }\n      const { sessionToken: sessionTokenLike, signal } = optionsArg;\n      const sessionToken = SessionToken.convert(sessionTokenLike);\n      const url = new URL(`${RETRIEVE_URL2}/${suggestion.action.id}`);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        session_token: sessionToken.id\n      });\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), { signal });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n  canRetrieve(suggestion) {\n    const action = suggestion.action;\n    return typeof (action == null ? void 0 : action.id) === \"string\";\n  }\n};\nvar MapboxAutofill = _MapboxAutofill;\n_getQueryParams2 = new WeakSet();\ngetQueryParams_fn2 = function(options) {\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country,\n    limit: options.limit\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  });\n};\nMapboxAutofill.defaults = {\n  language: \"en\",\n  proximity: \"ip\"\n};\n\n// src/types.ts\nvar MatchCodeConfidence = /* @__PURE__ */ ((MatchCodeConfidence2) => {\n  MatchCodeConfidence2[\"exact\"] = \"exact\";\n  MatchCodeConfidence2[\"high\"] = \"high\";\n  MatchCodeConfidence2[\"medium\"] = \"medium\";\n  MatchCodeConfidence2[\"low\"] = \"low\";\n  return MatchCodeConfidence2;\n})(MatchCodeConfidence || {});\n\n// src/utils/Evented.ts\nvar _listeners;\nvar Evented = class {\n  constructor() {\n    __privateAdd(this, _listeners, {});\n  }\n  addEventListener(type, listener) {\n    const listenersArr = __privateGet(this, _listeners);\n    if (!listenersArr[type]) {\n      listenersArr[type] = [];\n    }\n    listenersArr[type].push(listener);\n  }\n  removeEventListener(type, listener) {\n    const listenersArr = __privateGet(this, _listeners);\n    if (!listenersArr[type]) {\n      return;\n    }\n    const listeners = listenersArr[type];\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n  fire(type, arg0) {\n    const listenersArr = __privateGet(this, _listeners);\n    if (!listenersArr[type]) {\n      return;\n    }\n    const listeners = listenersArr[type];\n    for (const listener of listeners) {\n      listener(arg0);\n    }\n  }\n};\n_listeners = new WeakMap();\n\n// src/utils/debounce.ts\nfunction debounce(func, wait, signalFn) {\n  let timeout = null;\n  return (...args) => {\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n    const signal = signalFn && signalFn();\n    timeout = setTimeout(() => {\n      timeout = null;\n      if (signal == null ? void 0 : signal.aborted) {\n        return;\n      }\n      func(...args);\n    }, wait);\n  };\n}\n\n// src/SearchSession.ts\nfunction createAbortController() {\n  const { AbortController } = getFetch();\n  return new AbortController();\n}\nvar _suggestions, _abort, _suggestDebounce;\nvar SearchSession = class extends Evented {\n  constructor(search, wait = 0) {\n    super();\n    this.sessionToken = new SessionToken();\n    __privateAdd(this, _suggestions, void 0);\n    __privateAdd(this, _abort, createAbortController());\n    __privateAdd(this, _suggestDebounce, void 0);\n    __privateSet(this, _suggestDebounce, debounce((_0, ..._1) => __async(this, [_0, ..._1], function* (searchText, options = {}) {\n      __privateGet(this, _abort).abort();\n      __privateSet(this, _abort, createAbortController());\n      if (!searchText) {\n        __privateSet(this, _suggestions, null);\n        this.fire(\"suggest\", __privateGet(this, _suggestions));\n        return;\n      }\n      try {\n        const res = yield this.search.suggest(searchText, __spreadProps(__spreadValues({\n          sessionToken: this.sessionToken\n        }, options), {\n          signal: __privateGet(this, _abort).signal\n        }));\n        __privateSet(this, _suggestions, res);\n        this.fire(\"suggest\", res);\n      } catch (err) {\n        if (err.name === \"AbortError\") {\n          return;\n        }\n        this.fire(\"suggesterror\", err);\n      }\n    }), wait, () => __privateGet(this, _abort).signal));\n    Object.defineProperties(this, {\n      search: {\n        value: search,\n        writable: false\n      },\n      debounce: {\n        value: wait,\n        writable: false\n      }\n    });\n  }\n  get suggestions() {\n    return __privateGet(this, _suggestions);\n  }\n  suggest(searchText, options) {\n    __privateGet(this, _suggestDebounce).call(this, searchText, options);\n    return new Promise((resolve, reject) => {\n      let suggestFn;\n      let suggestErrorFn;\n      suggestFn = (res) => {\n        this.removeEventListener(\"suggest\", suggestFn);\n        this.removeEventListener(\"suggesterror\", suggestErrorFn);\n        resolve(res);\n      };\n      suggestErrorFn = (err) => {\n        this.removeEventListener(\"suggest\", suggestFn);\n        this.removeEventListener(\"suggesterror\", suggestErrorFn);\n        reject(err);\n      };\n      this.addEventListener(\"suggest\", suggestFn);\n      this.addEventListener(\"suggesterror\", suggestErrorFn);\n    });\n  }\n  clear() {\n    this.suggest(\"\");\n  }\n  retrieve(suggestion, options) {\n    return __async(this, null, function* () {\n      const res = yield this.search.retrieve(suggestion, __spreadValues({\n        sessionToken: this.sessionToken\n      }, options));\n      this.fire(\"retrieve\", res);\n      return res;\n    });\n  }\n  canRetrieve(suggestion) {\n    if (!this.search.canRetrieve) {\n      return true;\n    }\n    return this.search.canRetrieve(suggestion);\n  }\n  canSuggest(suggestion) {\n    if (!this.search.canSuggest) {\n      return true;\n    }\n    return this.search.canSuggest(suggestion);\n  }\n  abort() {\n    __privateGet(this, _abort).abort();\n    __privateSet(this, _abort, createAbortController());\n  }\n};\n_suggestions = new WeakMap();\n_abort = new WeakMap();\n_suggestDebounce = new WeakMap();\n\n// src/featureToSuggestion.ts\nfunction featureToSuggestion(feature) {\n  const { properties } = feature;\n  return __spreadValues({}, properties);\n}\n\n// src/validate/constants.ts\nvar SEARCH_URL3 = `https://api.mapbox.com/autofill/v1`;\nvar ENDPOINT_VALIDATE = \"retrieve\";\nvar VALIDATE_URL = `${SEARCH_URL3}/${ENDPOINT_VALIDATE}`;\n\n// src/validate/MapboxValidate.ts\nvar _getQueryParams3, getQueryParams_fn3;\nvar _MapboxValidate = class {\n  constructor(options = {}) {\n    __privateAdd(this, _getQueryParams3);\n    const _a = options, { accessToken } = _a, defaults = __objRest(_a, [\"accessToken\"]);\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _MapboxValidate.defaults), defaults);\n  }\n  validate(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n      const { sessionToken, signal } = optionsArg;\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n      const url = new URL(`${VALIDATE_URL}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams3, getQueryParams_fn3).call(this, options);\n      const { fetch } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      if (json.features.length > 0) {\n        json.features = [json.features[0]];\n      }\n      return json;\n    });\n  }\n};\nvar MapboxValidate = _MapboxValidate;\n_getQueryParams3 = new WeakSet();\ngetQueryParams_fn3 = function(options) {\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  });\n};\nMapboxValidate.defaults = {\n  language: \"en\",\n  proximity: \"ip\"\n};\n\n//# sourceMappingURL=index-esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hcGJveC9zZWFyY2gtanMtY29yZS9kaXN0L2luZGV4LWVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVyxHQUFHLGlCQUFpQjtBQUNwRCxzQkFBc0IsV0FBVyxHQUFHLGtCQUFrQjtBQUN0RCxxQkFBcUIsV0FBVyxHQUFHLGlCQUFpQjtBQUNwRCwrQkFBK0IsV0FBVyxhQUFhLGlCQUFpQjtBQUN4RSxxQkFBcUIsV0FBVyxHQUFHLGlCQUFpQjtBQUNwRCwrQkFBK0IsV0FBVyxhQUFhLGlCQUFpQjs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSSxJQUFJLElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTLElBQUksU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHVCQUF1QixhQUFhLHVCQUF1QjtBQUN0STtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQixJQUFJLG9CQUFvQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLEdBQUcsZ0JBQWdCLEtBQUssYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUksR0FBRyxrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQyxvRUFBb0U7QUFDcEU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVksR0FBRywrQkFBK0I7QUFDM0U7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5Q0FBeUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxjQUFjLFFBQVE7QUFDdEIsNkVBQTZFO0FBQzdFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSw2QkFBNkIsUUFBUSxHQUFHLCtCQUErQjtBQUN2RTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsNkJBQTZCLFFBQVEsR0FBRywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVksR0FBRyxrQkFBa0I7QUFDdkQsdUJBQXVCLFlBQVksR0FBRyxtQkFBbUI7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDLG9FQUFvRTtBQUNwRTtBQUNBLE9BQU87QUFDUCw2QkFBNkIsYUFBYSxHQUFHLCtCQUErQjtBQUM1RTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5Q0FBeUM7QUFDdkQ7QUFDQSw2QkFBNkIsY0FBYyxHQUFHLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsY0FBYyxRQUFRO0FBQ3RCLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSDtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QiwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVksR0FBRyxrQkFBa0I7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDLG9FQUFvRTtBQUNwRTtBQUNBLE9BQU87QUFDUCw2QkFBNkIsYUFBYSxHQUFHLCtCQUErQjtBQUM1RTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BtYXBib3gvc2VhcmNoLWpzLWNvcmUvZGlzdC9pbmRleC1lc20uanM/OTU0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19wcml2YXRlTWV0aG9kID0gKG9iaiwgbWVtYmVyLCBtZXRob2QpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJhY2Nlc3MgcHJpdmF0ZSBtZXRob2RcIik7XG4gIHJldHVybiBtZXRob2Q7XG59O1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcblxuLy8gc3JjL3NlYXJjaC9jb25zdGFudHMudHNcbnZhciBTRUFSQ0hfVVJMID0gYGh0dHBzOi8vYXBpLm1hcGJveC5jb20vc2VhcmNoL3YxYDtcbnZhciBFTkRQT0lOVF9TVUdHRVNUID0gXCJzdWdnZXN0XCI7XG52YXIgRU5EUE9JTlRfUkVUUklFVkUgPSBcInJldHJpZXZlXCI7XG52YXIgRU5EUE9JTlRfRk9SV0FSRCA9IFwiZm9yd2FyZFwiO1xudmFyIEVORFBPSU5UX1JFVkVSU0UgPSBcInJldmVyc2VcIjtcbnZhciBTVUdHRVNUX1VSTCA9IGAke1NFQVJDSF9VUkx9LyR7RU5EUE9JTlRfU1VHR0VTVH1gO1xudmFyIFJFVFJJRVZFX1VSTCA9IGAke1NFQVJDSF9VUkx9LyR7RU5EUE9JTlRfUkVUUklFVkV9YDtcbnZhciBGT1JXQVJEX1VSTCA9IGAke1NFQVJDSF9VUkx9LyR7RU5EUE9JTlRfRk9SV0FSRH1gO1xudmFyIFBFUk1BTkVOVF9GT1JXQVJEX1VSTCA9IGAke1NFQVJDSF9VUkx9L3Blcm1hbmVudC8ke0VORFBPSU5UX0ZPUldBUkR9YDtcbnZhciBSRVZFUlNFX1VSTCA9IGAke1NFQVJDSF9VUkx9LyR7RU5EUE9JTlRfUkVWRVJTRX1gO1xudmFyIFBFUk1BTkVOVF9SRVZFUlNFX1VSTCA9IGAke1NFQVJDSF9VUkx9L3Blcm1hbmVudC8ke0VORFBPSU5UX1JFVkVSU0V9YDtcblxuLy8gc3JjL0xuZ0xhdC50c1xudmFyIExuZ0xhdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobG5nLCBsYXQpIHtcbiAgICBpZiAoaXNOYU4obG5nKSB8fCBpc05hTihsYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTG5nTGF0IG9iamVjdDogKCR7bG5nfSwgJHtsYXR9KWApO1xuICAgIH1cbiAgICB0aGlzLmxuZyA9ICtsbmc7XG4gICAgdGhpcy5sYXQgPSArbGF0O1xuICAgIGlmICh0aGlzLmxhdCA+IDkwIHx8IHRoaXMubGF0IDwgLTkwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExuZ0xhdCBsYXRpdHVkZSB2YWx1ZTogbXVzdCBiZSBiZXR3ZWVuIC05MCBhbmQgOTBcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmxuZyA+IDE4MCB8fCB0aGlzLmxuZyA8IC0xODApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTG5nTGF0IGxvbmdpdHVkZSB2YWx1ZTogbXVzdCBiZSBiZXR3ZWVuIC0xODAgYW5kIDE4MFwiKTtcbiAgICB9XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMubG5nLCB0aGlzLmxhdF07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBMbmdMYXQoJHt0aGlzLmxuZ30sICR7dGhpcy5sYXR9KWA7XG4gIH1cbiAgc3RhdGljIGNvbnZlcnQoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBMbmdMYXQpIHtcbiAgICAgIHJldHVybiBuZXcgTG5nTGF0KGlucHV0LmxuZywgaW5wdXQubGF0KTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBMbmdMYXQoTnVtYmVyKGlucHV0WzBdKSwgTnVtYmVyKGlucHV0WzFdKSk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgdHlwZW9mIGlucHV0ID09IFwib2JqZWN0XCIgJiYgaW5wdXQgIT09IG51bGwgJiYgKFwibG5nXCIgaW4gaW5wdXQgfHwgXCJsb25cIiBpbiBpbnB1dCkgJiYgXCJsYXRcIiBpbiBpbnB1dCkge1xuICAgICAgcmV0dXJuIG5ldyBMbmdMYXQoTnVtYmVyKFwibG5nXCIgaW4gaW5wdXQgPyBpbnB1dC5sbmcgOiBpbnB1dC5sb24pLCBOdW1iZXIoaW5wdXQubGF0KSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImBMbmdMYXRMaWtlYCBhcmd1bWVudCBtdXN0IGJlIHNwZWNpZmllZCBhcyBhbiBvYmplY3Qge2xuZzogPGxuZz4sIGxhdDogPGxhdD59LCBhbiBvYmplY3Qge2xvbjogPGxuZz4sIGxhdDogPGxhdD59LCBvciBhbiBhcnJheSBvZiBbPGxuZz4sIDxsYXQ+XVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL0xuZ0xhdEJvdW5kcy50c1xudmFyIExuZ0xhdEJvdW5kcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3csIG5lKSB7XG4gICAgdGhpcy5fc3cgPSBMbmdMYXQuY29udmVydChzdyk7XG4gICAgdGhpcy5fbmUgPSBMbmdMYXQuY29udmVydChuZSk7XG4gIH1cbiAgZ2V0U291dGhXZXN0KCkge1xuICAgIHJldHVybiB0aGlzLl9zdztcbiAgfVxuICBnZXROb3J0aEVhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25lO1xuICB9XG4gIGdldE5vcnRoV2VzdCgpIHtcbiAgICByZXR1cm4gbmV3IExuZ0xhdCh0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXROb3J0aCgpKTtcbiAgfVxuICBnZXRTb3V0aEVhc3QoKSB7XG4gICAgcmV0dXJuIG5ldyBMbmdMYXQodGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0U291dGgoKSk7XG4gIH1cbiAgZ2V0V2VzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3cubG5nO1xuICB9XG4gIGdldFNvdXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdy5sYXQ7XG4gIH1cbiAgZ2V0RWFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmUubG5nO1xuICB9XG4gIGdldE5vcnRoKCkge1xuICAgIHJldHVybiB0aGlzLl9uZS5sYXQ7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMuX3N3LnRvQXJyYXkoKSwgdGhpcy5fbmUudG9BcnJheSgpXTtcbiAgfVxuICB0b0ZsYXRBcnJheSgpIHtcbiAgICByZXR1cm4gW3RoaXMuX3N3LmxuZywgdGhpcy5fc3cubGF0LCB0aGlzLl9uZS5sbmcsIHRoaXMuX25lLmxhdF07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBMbmdMYXRCb3VuZHMoJHt0aGlzLl9zdy50b1N0cmluZygpfSwgJHt0aGlzLl9uZS50b1N0cmluZygpfSlgO1xuICB9XG4gIHN0YXRpYyBjb252ZXJ0KGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMbmdMYXRCb3VuZHMgY29udmVydCB2YWx1ZTogZmFsc3lcIik7XG4gICAgfVxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIExuZ0xhdEJvdW5kcykge1xuICAgICAgcmV0dXJuIG5ldyBMbmdMYXRCb3VuZHMoaW5wdXQuZ2V0U291dGhXZXN0KCksIGlucHV0LmdldE5vcnRoRWFzdCgpKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBMbmdMYXRCb3VuZHMoTG5nTGF0LmNvbnZlcnQoaW5wdXRbMF0pLCBMbmdMYXQuY29udmVydChpbnB1dFsxXSkpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSA0KSB7XG4gICAgICByZXR1cm4gbmV3IExuZ0xhdEJvdW5kcyhMbmdMYXQuY29udmVydChbaW5wdXRbMF0sIGlucHV0WzFdXSksIExuZ0xhdC5jb252ZXJ0KFtpbnB1dFsyXSwgaW5wdXRbM11dKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImBMbmdMYXRCb3VuZHNMaWtlYCBhcmd1bWVudCBtdXN0IGJlIHNwZWNpZmllZCBhcyBhbiBhcnJheSBbPExuZ0xhdExpa2U+LCA8TG5nTGF0TGlrZT5dIG9yIGFuIGFycmF5IFs8d2VzdD4sIDxzb3V0aD4sIDxlYXN0PiwgPG5vcnRoPl1cIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy91dWlkLnRzXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gIGNvbnN0IHJhbmRvbVN0cmluZyA9IERhdGUubm93KCkudG9TdHJpbmcoMTYpICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygxNikgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KTtcbiAgY29uc3QgdXVpZFN0cmluZyA9IHJhbmRvbVN0cmluZy5yZXBsYWNlKC9cXC4vZywgXCJcIik7XG4gIGNvbnN0IHV1aWQgPSBbXG4gICAgdXVpZFN0cmluZy5zbGljZSgwLCA4KSxcbiAgICB1dWlkU3RyaW5nLnNsaWNlKDgsIDEyKSxcbiAgICBcIjRcIiArIHV1aWRTdHJpbmcuc2xpY2UoMTIsIDE1KSArIFwiLThcIiArIHV1aWRTdHJpbmcuc2xpY2UoMTUsIDE4KSxcbiAgICB1dWlkU3RyaW5nLnNsaWNlKDE4LCAzMClcbiAgXS5qb2luKFwiLVwiKTtcbiAgcmV0dXJuIHV1aWQ7XG59XG5cbi8vIHNyYy9TZXNzaW9uVG9rZW4udHNcbnZhciBTZXNzaW9uVG9rZW4gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkICE9IG51bGwgPyBpZCA6IGdlbmVyYXRlVVVJRCgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG4gIHN0YXRpYyBjb252ZXJ0KHRva2VuKSB7XG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uVG9rZW4odG9rZW4gaW5zdGFuY2VvZiBTZXNzaW9uVG9rZW4gPyB0b2tlbi5pZCA6IHRva2VuLnRvU3RyaW5nKCkpO1xuICB9XG59O1xuXG4vLyBzcmMvTWFwYm94RXJyb3IudHNcbnZhciBVTktOT1dOX0VSUk9SID0gXCJVbmtub3duIGVycm9yXCI7XG52YXIgTWFwYm94RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoanNvbiwgc3RhdHVzQ29kZSkge1xuICAgIHN1cGVyKFN0cmluZyhqc29uLm1lc3NhZ2UgfHwganNvbi5lcnJvciB8fCBVTktOT1dOX0VSUk9SKSk7XG4gICAgdGhpcy5uYW1lID0gXCJNYXBib3hFcnJvclwiO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubmFtZX0gKCR7dGhpcy5zdGF0dXNDb2RlfSk6ICR7dGhpcy5tZXNzYWdlfWA7XG4gIH1cbn07XG5mdW5jdGlvbiBoYW5kbGVOb25Pa1JlcyhyZXMpIHtcbiAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgY29uc3QganNvbiA9IHlpZWxkIHJlcy5qc29uKCk7XG4gICAgICB0aHJvdyBuZXcgTWFwYm94RXJyb3IoanNvbiwgcmVzLnN0YXR1cyk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2ZldGNoLnRzXG52YXIgX2ZldGNoSW1wbCA9IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgX2Fib3J0Q29udHJvbGxlckltcGwgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcjtcbmZ1bmN0aW9uIHBvbHlmaWxsRmV0Y2goeyBmZXRjaCwgQWJvcnRDb250cm9sbGVyIH0sIGZvcmNlID0gZmFsc2UpIHtcbiAgaWYgKCFmZXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZldGNoIGltcGxlbWVudGF0aW9uIG11c3QgaW5jbHVkZSBpbXBsZW1lbnRhdGlvbnMgb2YgYGZldGNoYC5cIik7XG4gIH1cbiAgaWYgKF9mZXRjaEltcGwgJiYgIWZvcmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIF9mZXRjaEltcGwgPSBmZXRjaDtcbiAgX2Fib3J0Q29udHJvbGxlckltcGwgPSBBYm9ydENvbnRyb2xsZXI7XG59XG5mdW5jdGlvbiBnZXRGZXRjaCgpIHtcbiAgaWYgKCFfZmV0Y2hJbXBsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmV0Y2ggaW1wbGVtZW50YXRpb24gbm90IGZvdW5kLiBQbGVhc2UgaW5jbHVkZSBhIGZldGNoIHBvbHlmaWxsIGluIHlvdXIgYXBwbGljYXRpb24gb3IgdXNlIGBwb2x5ZmlsbEZldGNoYCBmcm9tIGBAbWFwYm94L3NlYXJjaC1qcy1jb3JlYCB0byBmaXggdGhpcyBpc3N1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmZXRjaDogX2ZldGNoSW1wbCxcbiAgICBBYm9ydENvbnRyb2xsZXI6IF9hYm9ydENvbnRyb2xsZXJJbXBsXG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9xdWVyeVBhcmFtcy50c1xuZnVuY3Rpb24gcXVlcnlQYXJhbXMoLi4ub2JqZWN0cykge1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgZm9yIChjb25zdCBvYmogb2Ygb2JqZWN0cykge1xuICAgIGlmICghb2JqKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG9iaik7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcykge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcGFyYW1zLnB1c2goYCR7a2V5fT0ke2VuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodmFsdWUpKX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtcy5qb2luKFwiJlwiKTtcbn1cblxuLy8gc3JjL3NlYXJjaC9NYXBib3hTZWFyY2gudHNcbnZhciBfZ2V0UXVlcnlQYXJhbXMsIGdldFF1ZXJ5UGFyYW1zX2ZuLCBfZ2V0RmV0Y2hJbmZvLCBnZXRGZXRjaEluZm9fZm47XG52YXIgX01hcGJveFNlYXJjaCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9nZXRRdWVyeVBhcmFtcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9nZXRGZXRjaEluZm8pO1xuICAgIGNvbnN0IF9hID0gb3B0aW9ucywgeyBhY2Nlc3NUb2tlbiB9ID0gX2EsIGRlZmF1bHRzID0gX19vYmpSZXN0KF9hLCBbXCJhY2Nlc3NUb2tlblwiXSk7XG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgIHRoaXMuZGVmYXVsdHMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgX01hcGJveFNlYXJjaC5kZWZhdWx0cyksIGRlZmF1bHRzKTtcbiAgfVxuICBzdWdnZXN0KHNlYXJjaFRleHQsIG9wdGlvbnNBcmcpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCFzZWFyY2hUZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNlYXJjaFRleHQgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHNlc3Npb25Ub2tlbiwgc2lnbmFsIH0gPSBvcHRpb25zQXJnO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZGVmYXVsdHMpLCBvcHRpb25zQXJnKSwge1xuICAgICAgICBzZXNzaW9uVG9rZW5cbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbnMuZXRhX3R5cGUgJiYgKCFvcHRpb25zLm9yaWdpbiB8fCAhb3B0aW9ucy5uYXZpZ2F0aW9uX3Byb2ZpbGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvIHByb3ZpZGUgZXRhIGVzdGltYXRlOiBldGEsIG5hdmlnYXRpb25fcHJvZmlsZSwgYW5kIG9yaWdpbiBhcmUgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vcmlnaW4gJiYgIW9wdGlvbnMubmF2aWdhdGlvbl9wcm9maWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvIHByb3ZpZGUgZGlzdGFuY2UgZXN0aW1hdGU6IGJvdGggbmF2aWdhdGlvbl9wcm9maWxlIGFuZCBvcmlnaW4gYXJlIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtTVUdHRVNUX1VSTH0vJHtlbmNvZGVVUklDb21wb25lbnQoc2VhcmNoVGV4dCl9YCk7XG4gICAgICB1cmwuc2VhcmNoID0gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRRdWVyeVBhcmFtcywgZ2V0UXVlcnlQYXJhbXNfZm4pLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCB7IGZldGNoIH0gPSBnZXRGZXRjaCgpO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHlpZWxkIGhhbmRsZU5vbk9rUmVzKHJlcyk7XG4gICAgICBjb25zdCBqc29uID0geWllbGQgcmVzLmpzb24oKTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0pO1xuICB9XG4gIHJldHJpZXZlKHN1Z2dlc3Rpb24sIG9wdGlvbnNBcmcpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCFzdWdnZXN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Z2dlc3Rpb24gaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2FuUmV0cmlldmUoc3VnZ2VzdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3VnZ2VzdGlvbiBjYW5ub3QgYmUgcmV0cmlldmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBzZXNzaW9uVG9rZW46IHNlc3Npb25Ub2tlbkxpa2UsIHNpZ25hbCB9ID0gb3B0aW9uc0FyZztcbiAgICAgIGNvbnN0IHNlc3Npb25Ub2tlbiA9IFNlc3Npb25Ub2tlbi5jb252ZXJ0KHNlc3Npb25Ub2tlbkxpa2UpO1xuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChSRVRSSUVWRV9VUkwpO1xuICAgICAgdXJsLnNlYXJjaCA9IHF1ZXJ5UGFyYW1zKHtcbiAgICAgICAgYWNjZXNzX3Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgICAgICBzZXNzaW9uX3Rva2VuOiBzZXNzaW9uVG9rZW4uaWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyBmZXRjaCB9ID0gZ2V0RmV0Y2goKTtcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGZldGNoKHVybC50b1N0cmluZygpLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldEZldGNoSW5mbywgZ2V0RmV0Y2hJbmZvX2ZuKS5jYWxsKHRoaXMsIHN1Z2dlc3Rpb24pKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pKTtcbiAgICAgIHlpZWxkIGhhbmRsZU5vbk9rUmVzKHJlcyk7XG4gICAgICBjb25zdCBqc29uID0geWllbGQgcmVzLmpzb24oKTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0pO1xuICB9XG4gIGNhblJldHJpZXZlKHN1Z2dlc3Rpb24pIHtcbiAgICBjb25zdCBhY3Rpb24gPSBzdWdnZXN0aW9uLmFjdGlvbjtcbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uLm1ldGhvZCA9PT0gXCJQT1NUXCIgJiYgYWN0aW9uLmVuZHBvaW50ID09PSBFTkRQT0lOVF9SRVRSSUVWRTtcbiAgfVxuICBjYW5TdWdnZXN0KHN1Z2dlc3Rpb24pIHtcbiAgICBjb25zdCBhY3Rpb24gPSBzdWdnZXN0aW9uLmFjdGlvbjtcbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uLm1ldGhvZCA9PT0gXCJQT1NUXCIgJiYgYWN0aW9uLmVuZHBvaW50ID09PSBFTkRQT0lOVF9TVUdHRVNUO1xuICB9XG4gIGZvcndhcmQoXzApIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoc2VhcmNoVGV4dCwgb3B0aW9uc0FyZyA9IHt9KSB7XG4gICAgICBpZiAoIXNlYXJjaFRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VhcmNoVGV4dCBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5kZWZhdWx0cyksIG9wdGlvbnNBcmcpO1xuICAgICAgY29uc3QgYmFzZVVybCA9IG9wdGlvbnMucGVybWFuZW50ID8gUEVSTUFORU5UX0ZPUldBUkRfVVJMIDogRk9SV0FSRF9VUkw7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke2Jhc2VVcmx9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHNlYXJjaFRleHQpfWApO1xuICAgICAgdXJsLnNlYXJjaCA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UXVlcnlQYXJhbXMsIGdldFF1ZXJ5UGFyYW1zX2ZuKS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgeyBmZXRjaCB9ID0gZ2V0RmV0Y2goKTtcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgeWllbGQgaGFuZGxlTm9uT2tSZXMocmVzKTtcbiAgICAgIGNvbnN0IGpzb24gPSB5aWVsZCByZXMuanNvbigpO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSk7XG4gIH1cbiAgcmV2ZXJzZShfMCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIChsbmdMYXQsIG9wdGlvbnNBcmcgPSB7fSkge1xuICAgICAgaWYgKCFsbmdMYXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG5nTGF0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmRlZmF1bHRzKSwgb3B0aW9uc0FyZyk7XG4gICAgICBjb25zdCBzZWFyY2hUZXh0ID0gdHlwZW9mIGxuZ0xhdCA9PT0gXCJzdHJpbmdcIiA/IGxuZ0xhdCA6IExuZ0xhdC5jb252ZXJ0KGxuZ0xhdCkudG9BcnJheSgpLmpvaW4oXCIsXCIpO1xuICAgICAgY29uc3QgYmFzZVVybCA9IG9wdGlvbnMucGVybWFuZW50ID8gUEVSTUFORU5UX1JFVkVSU0VfVVJMIDogUkVWRVJTRV9VUkw7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke2Jhc2VVcmx9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHNlYXJjaFRleHQpfWApO1xuICAgICAgdXJsLnNlYXJjaCA9IHF1ZXJ5UGFyYW1zKHtcbiAgICAgICAgYWNjZXNzX3Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgICAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSxcbiAgICAgICAgbGltaXQ6IG9wdGlvbnMubGltaXRcbiAgICAgIH0sIG9wdGlvbnMudHlwZXMgJiYge1xuICAgICAgICB0eXBlczogdHlwZW9mIG9wdGlvbnMudHlwZXMgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLnR5cGVzIDogWy4uLm9wdGlvbnMudHlwZXNdLmpvaW4oXCIsXCIpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHsgZmV0Y2ggfSA9IGdldEZldGNoKCk7XG4gICAgICBjb25zdCByZXMgPSB5aWVsZCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHlpZWxkIGhhbmRsZU5vbk9rUmVzKHJlcyk7XG4gICAgICBjb25zdCBqc29uID0geWllbGQgcmVzLmpzb24oKTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0pO1xuICB9XG59O1xudmFyIE1hcGJveFNlYXJjaCA9IF9NYXBib3hTZWFyY2g7XG5fZ2V0UXVlcnlQYXJhbXMgPSBuZXcgV2Vha1NldCgpO1xuZ2V0UXVlcnlQYXJhbXNfZm4gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiBxdWVyeVBhcmFtcyh7XG4gICAgYWNjZXNzX3Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlLFxuICAgIGNvdW50cnk6IG9wdGlvbnMuY291bnRyeSxcbiAgICBsaW1pdDogb3B0aW9ucy5saW1pdCxcbiAgICBuYXZpZ2F0aW9uX3Byb2ZpbGU6IG9wdGlvbnMubmF2aWdhdGlvbl9wcm9maWxlLFxuICAgIGV0YV90eXBlOiBvcHRpb25zLmV0YV90eXBlXG4gIH0sIG9wdGlvbnMuc2Vzc2lvblRva2VuICYmIHtcbiAgICBzZXNzaW9uX3Rva2VuOiBTZXNzaW9uVG9rZW4uY29udmVydChvcHRpb25zLnNlc3Npb25Ub2tlbikuaWRcbiAgfSwgb3B0aW9ucy5vcmlnaW4gJiYge1xuICAgIG9yaWdpbjogdHlwZW9mIG9wdGlvbnMub3JpZ2luID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5vcmlnaW4gOiBMbmdMYXQuY29udmVydChvcHRpb25zLm9yaWdpbikudG9BcnJheSgpLmpvaW4oXCIsXCIpXG4gIH0sIG9wdGlvbnMucHJveGltaXR5ICYmIHtcbiAgICBwcm94aW1pdHk6IHR5cGVvZiBvcHRpb25zLnByb3hpbWl0eSA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMucHJveGltaXR5IDogTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5wcm94aW1pdHkpLnRvQXJyYXkoKS5qb2luKFwiLFwiKVxuICB9LCBvcHRpb25zLmJib3ggJiYge1xuICAgIGJib3g6IHR5cGVvZiBvcHRpb25zLmJib3ggPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLmJib3ggOiBMbmdMYXRCb3VuZHMuY29udmVydChvcHRpb25zLmJib3gpLnRvRmxhdEFycmF5KCkuam9pbihcIixcIilcbiAgfSwgb3B0aW9ucy50eXBlcyAmJiB7XG4gICAgdHlwZXM6IHR5cGVvZiBvcHRpb25zLnR5cGVzID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy50eXBlcyA6IFsuLi5vcHRpb25zLnR5cGVzXS5qb2luKFwiLFwiKVxuICB9KTtcbn07XG5fZ2V0RmV0Y2hJbmZvID0gbmV3IFdlYWtTZXQoKTtcbmdldEZldGNoSW5mb19mbiA9IGZ1bmN0aW9uKHN1Z2dlc3Rpb24pIHtcbiAgaWYgKCF0aGlzLmNhblJldHJpZXZlKHN1Z2dlc3Rpb24pICYmICF0aGlzLmNhblN1Z2dlc3Qoc3VnZ2VzdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWdnZXN0aW9uIGNhbm5vdCBiZSByZXRyaWV2ZWQgb3Igc3VnZ2VzdGVkXCIpO1xuICB9XG4gIGNvbnN0IGFjdGlvbiA9IHN1Z2dlc3Rpb24uYWN0aW9uO1xuICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoYWN0aW9uLmJvZHkpO1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogYWN0aW9uLm1ldGhvZCxcbiAgICBib2R5LFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJDb250ZW50LUxlbmd0aFwiOiBib2R5Lmxlbmd0aC50b1N0cmluZygpXG4gICAgfVxuICB9O1xufTtcbk1hcGJveFNlYXJjaC5kZWZhdWx0cyA9IHtcbiAgbGFuZ3VhZ2U6IFwiZW5cIlxufTtcblxuLy8gc3JjL2F1dG9maWxsL2NvbnN0YW50cy50c1xudmFyIFNFQVJDSF9VUkwyID0gYGh0dHBzOi8vYXBpLm1hcGJveC5jb20vYXV0b2ZpbGwvdjFgO1xudmFyIEVORFBPSU5UX1NVR0dFU1QyID0gXCJzdWdnZXN0XCI7XG52YXIgRU5EUE9JTlRfUkVUUklFVkUyID0gXCJyZXRyaWV2ZVwiO1xudmFyIFNVR0dFU1RfVVJMMiA9IGAke1NFQVJDSF9VUkwyfS8ke0VORFBPSU5UX1NVR0dFU1QyfWA7XG52YXIgUkVUUklFVkVfVVJMMiA9IGAke1NFQVJDSF9VUkwyfS8ke0VORFBPSU5UX1JFVFJJRVZFMn1gO1xuXG4vLyBzcmMvYXV0b2ZpbGwvTWFwYm94QXV0b2ZpbGwudHNcbnZhciBfZ2V0UXVlcnlQYXJhbXMyLCBnZXRRdWVyeVBhcmFtc19mbjI7XG52YXIgX01hcGJveEF1dG9maWxsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2dldFF1ZXJ5UGFyYW1zMik7XG4gICAgY29uc3QgX2EgPSBvcHRpb25zLCB7IGFjY2Vzc1Rva2VuIH0gPSBfYSwgZGVmYXVsdHMgPSBfX29ialJlc3QoX2EsIFtcImFjY2Vzc1Rva2VuXCJdKTtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gICAgdGhpcy5kZWZhdWx0cyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBfTWFwYm94QXV0b2ZpbGwuZGVmYXVsdHMpLCBkZWZhdWx0cyk7XG4gIH1cbiAgc3VnZ2VzdChzZWFyY2hUZXh0LCBvcHRpb25zQXJnKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghc2VhcmNoVGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZWFyY2hUZXh0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBzZXNzaW9uVG9rZW4sIHNpZ25hbCB9ID0gb3B0aW9uc0FyZztcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmRlZmF1bHRzKSwgb3B0aW9uc0FyZyksIHtcbiAgICAgICAgc2Vzc2lvblRva2VuXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7U1VHR0VTVF9VUkwyfS8ke2VuY29kZVVSSUNvbXBvbmVudChzZWFyY2hUZXh0KX1gKTtcbiAgICAgIHVybC5zZWFyY2ggPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFF1ZXJ5UGFyYW1zMiwgZ2V0UXVlcnlQYXJhbXNfZm4yKS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgeyBmZXRjaCB9ID0gZ2V0RmV0Y2goKTtcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICB5aWVsZCBoYW5kbGVOb25Pa1JlcyhyZXMpO1xuICAgICAgY29uc3QganNvbiA9IHlpZWxkIHJlcy5qc29uKCk7XG4gICAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwganNvbiksIHtcbiAgICAgICAgc3VnZ2VzdGlvbnM6IGpzb24uc3VnZ2VzdGlvbnMubWFwKChzdWdnZXN0aW9uKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHN1Z2dlc3Rpb24pLCB7XG4gICAgICAgICAgICBvcmlnaW5hbF9zZWFyY2hfdGV4dDogc2VhcmNoVGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0cmlldmUoc3VnZ2VzdGlvbiwgb3B0aW9uc0FyZykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXN1Z2dlc3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3VnZ2VzdGlvbiBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jYW5SZXRyaWV2ZShzdWdnZXN0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWdnZXN0aW9uIGNhbm5vdCBiZSByZXRyaWV2ZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHNlc3Npb25Ub2tlbjogc2Vzc2lvblRva2VuTGlrZSwgc2lnbmFsIH0gPSBvcHRpb25zQXJnO1xuICAgICAgY29uc3Qgc2Vzc2lvblRva2VuID0gU2Vzc2lvblRva2VuLmNvbnZlcnQoc2Vzc2lvblRva2VuTGlrZSk7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke1JFVFJJRVZFX1VSTDJ9LyR7c3VnZ2VzdGlvbi5hY3Rpb24uaWR9YCk7XG4gICAgICB1cmwuc2VhcmNoID0gcXVlcnlQYXJhbXMoe1xuICAgICAgICBhY2Nlc3NfdG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgICAgIHNlc3Npb25fdG9rZW46IHNlc3Npb25Ub2tlbi5pZFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IGZldGNoIH0gPSBnZXRGZXRjaCgpO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHsgc2lnbmFsIH0pO1xuICAgICAgeWllbGQgaGFuZGxlTm9uT2tSZXMocmVzKTtcbiAgICAgIGNvbnN0IGpzb24gPSB5aWVsZCByZXMuanNvbigpO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSk7XG4gIH1cbiAgY2FuUmV0cmlldmUoc3VnZ2VzdGlvbikge1xuICAgIGNvbnN0IGFjdGlvbiA9IHN1Z2dlc3Rpb24uYWN0aW9uO1xuICAgIHJldHVybiB0eXBlb2YgKGFjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogYWN0aW9uLmlkKSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxufTtcbnZhciBNYXBib3hBdXRvZmlsbCA9IF9NYXBib3hBdXRvZmlsbDtcbl9nZXRRdWVyeVBhcmFtczIgPSBuZXcgV2Vha1NldCgpO1xuZ2V0UXVlcnlQYXJhbXNfZm4yID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gcXVlcnlQYXJhbXMoe1xuICAgIGFjY2Vzc190b2tlbjogdGhpcy5hY2Nlc3NUb2tlbixcbiAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSxcbiAgICBjb3VudHJ5OiBvcHRpb25zLmNvdW50cnksXG4gICAgbGltaXQ6IG9wdGlvbnMubGltaXRcbiAgfSwgb3B0aW9ucy5zZXNzaW9uVG9rZW4gJiYge1xuICAgIHNlc3Npb25fdG9rZW46IFNlc3Npb25Ub2tlbi5jb252ZXJ0KG9wdGlvbnMuc2Vzc2lvblRva2VuKS5pZFxuICB9LCBvcHRpb25zLnByb3hpbWl0eSAmJiB7XG4gICAgcHJveGltaXR5OiB0eXBlb2Ygb3B0aW9ucy5wcm94aW1pdHkgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLnByb3hpbWl0eSA6IExuZ0xhdC5jb252ZXJ0KG9wdGlvbnMucHJveGltaXR5KS50b0FycmF5KCkuam9pbihcIixcIilcbiAgfSwgb3B0aW9ucy5iYm94ICYmIHtcbiAgICBiYm94OiB0eXBlb2Ygb3B0aW9ucy5iYm94ID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5iYm94IDogTG5nTGF0Qm91bmRzLmNvbnZlcnQob3B0aW9ucy5iYm94KS50b0ZsYXRBcnJheSgpLmpvaW4oXCIsXCIpXG4gIH0pO1xufTtcbk1hcGJveEF1dG9maWxsLmRlZmF1bHRzID0ge1xuICBsYW5ndWFnZTogXCJlblwiLFxuICBwcm94aW1pdHk6IFwiaXBcIlxufTtcblxuLy8gc3JjL3R5cGVzLnRzXG52YXIgTWF0Y2hDb2RlQ29uZmlkZW5jZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE1hdGNoQ29kZUNvbmZpZGVuY2UyKSA9PiB7XG4gIE1hdGNoQ29kZUNvbmZpZGVuY2UyW1wiZXhhY3RcIl0gPSBcImV4YWN0XCI7XG4gIE1hdGNoQ29kZUNvbmZpZGVuY2UyW1wiaGlnaFwiXSA9IFwiaGlnaFwiO1xuICBNYXRjaENvZGVDb25maWRlbmNlMltcIm1lZGl1bVwiXSA9IFwibWVkaXVtXCI7XG4gIE1hdGNoQ29kZUNvbmZpZGVuY2UyW1wibG93XCJdID0gXCJsb3dcIjtcbiAgcmV0dXJuIE1hdGNoQ29kZUNvbmZpZGVuY2UyO1xufSkoTWF0Y2hDb2RlQ29uZmlkZW5jZSB8fCB7fSk7XG5cbi8vIHNyYy91dGlscy9FdmVudGVkLnRzXG52YXIgX2xpc3RlbmVycztcbnZhciBFdmVudGVkID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2xpc3RlbmVycywge30pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnNBcnIgPSBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3RlbmVycyk7XG4gICAgaWYgKCFsaXN0ZW5lcnNBcnJbdHlwZV0pIHtcbiAgICAgIGxpc3RlbmVyc0Fyclt0eXBlXSA9IFtdO1xuICAgIH1cbiAgICBsaXN0ZW5lcnNBcnJbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyc0FyciA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGVuZXJzKTtcbiAgICBpZiAoIWxpc3RlbmVyc0Fyclt0eXBlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNBcnJbdHlwZV07XG4gICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIGZpcmUodHlwZSwgYXJnMCkge1xuICAgIGNvbnN0IGxpc3RlbmVyc0FyciA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGVuZXJzKTtcbiAgICBpZiAoIWxpc3RlbmVyc0Fyclt0eXBlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNBcnJbdHlwZV07XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVyKGFyZzApO1xuICAgIH1cbiAgfVxufTtcbl9saXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpO1xuXG4vLyBzcmMvdXRpbHMvZGVib3VuY2UudHNcbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHNpZ25hbEZuKSB7XG4gIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKHRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmFsID0gc2lnbmFsRm4gJiYgc2lnbmFsRm4oKTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmIChzaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZ1bmMoLi4uYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH07XG59XG5cbi8vIHNyYy9TZWFyY2hTZXNzaW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVBYm9ydENvbnRyb2xsZXIoKSB7XG4gIGNvbnN0IHsgQWJvcnRDb250cm9sbGVyIH0gPSBnZXRGZXRjaCgpO1xuICByZXR1cm4gbmV3IEFib3J0Q29udHJvbGxlcigpO1xufVxudmFyIF9zdWdnZXN0aW9ucywgX2Fib3J0LCBfc3VnZ2VzdERlYm91bmNlO1xudmFyIFNlYXJjaFNlc3Npb24gPSBjbGFzcyBleHRlbmRzIEV2ZW50ZWQge1xuICBjb25zdHJ1Y3RvcihzZWFyY2gsIHdhaXQgPSAwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlc3Npb25Ub2tlbiA9IG5ldyBTZXNzaW9uVG9rZW4oKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3N1Z2dlc3Rpb25zLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYWJvcnQsIGNyZWF0ZUFib3J0Q29udHJvbGxlcigpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3N1Z2dlc3REZWJvdW5jZSwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3N1Z2dlc3REZWJvdW5jZSwgZGVib3VuY2UoKF8wLCAuLi5fMSkgPT4gX19hc3luYyh0aGlzLCBbXzAsIC4uLl8xXSwgZnVuY3Rpb24qIChzZWFyY2hUZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYWJvcnQpLmFib3J0KCk7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2Fib3J0LCBjcmVhdGVBYm9ydENvbnRyb2xsZXIoKSk7XG4gICAgICBpZiAoIXNlYXJjaFRleHQpIHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9zdWdnZXN0aW9ucywgbnVsbCk7XG4gICAgICAgIHRoaXMuZmlyZShcInN1Z2dlc3RcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9zdWdnZXN0aW9ucykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLnNlYXJjaC5zdWdnZXN0KHNlYXJjaFRleHQsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgIHNlc3Npb25Ub2tlbjogdGhpcy5zZXNzaW9uVG9rZW5cbiAgICAgICAgfSwgb3B0aW9ucyksIHtcbiAgICAgICAgICBzaWduYWw6IF9fcHJpdmF0ZUdldCh0aGlzLCBfYWJvcnQpLnNpZ25hbFxuICAgICAgICB9KSk7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfc3VnZ2VzdGlvbnMsIHJlcyk7XG4gICAgICAgIHRoaXMuZmlyZShcInN1Z2dlc3RcIiwgcmVzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyZShcInN1Z2dlc3RlcnJvclwiLCBlcnIpO1xuICAgICAgfVxuICAgIH0pLCB3YWl0LCAoKSA9PiBfX3ByaXZhdGVHZXQodGhpcywgX2Fib3J0KS5zaWduYWwpKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBzZWFyY2g6IHtcbiAgICAgICAgdmFsdWU6IHNlYXJjaCxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZGVib3VuY2U6IHtcbiAgICAgICAgdmFsdWU6IHdhaXQsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBzdWdnZXN0aW9ucygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zdWdnZXN0aW9ucyk7XG4gIH1cbiAgc3VnZ2VzdChzZWFyY2hUZXh0LCBvcHRpb25zKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zdWdnZXN0RGVib3VuY2UpLmNhbGwodGhpcywgc2VhcmNoVGV4dCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBzdWdnZXN0Rm47XG4gICAgICBsZXQgc3VnZ2VzdEVycm9yRm47XG4gICAgICBzdWdnZXN0Rm4gPSAocmVzKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RcIiwgc3VnZ2VzdEZuKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdGVycm9yXCIsIHN1Z2dlc3RFcnJvckZuKTtcbiAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgfTtcbiAgICAgIHN1Z2dlc3RFcnJvckZuID0gKGVycikgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIHN1Z2dlc3RGbik7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RlcnJvclwiLCBzdWdnZXN0RXJyb3JGbik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RcIiwgc3VnZ2VzdEZuKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RlcnJvclwiLCBzdWdnZXN0RXJyb3JGbik7XG4gICAgfSk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5zdWdnZXN0KFwiXCIpO1xuICB9XG4gIHJldHJpZXZlKHN1Z2dlc3Rpb24sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5zZWFyY2gucmV0cmlldmUoc3VnZ2VzdGlvbiwgX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICBzZXNzaW9uVG9rZW46IHRoaXMuc2Vzc2lvblRva2VuXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgICB0aGlzLmZpcmUoXCJyZXRyaWV2ZVwiLCByZXMpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgfVxuICBjYW5SZXRyaWV2ZShzdWdnZXN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLnNlYXJjaC5jYW5SZXRyaWV2ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlYXJjaC5jYW5SZXRyaWV2ZShzdWdnZXN0aW9uKTtcbiAgfVxuICBjYW5TdWdnZXN0KHN1Z2dlc3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuc2VhcmNoLmNhblN1Z2dlc3QpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZWFyY2guY2FuU3VnZ2VzdChzdWdnZXN0aW9uKTtcbiAgfVxuICBhYm9ydCgpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2Fib3J0KS5hYm9ydCgpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYWJvcnQsIGNyZWF0ZUFib3J0Q29udHJvbGxlcigpKTtcbiAgfVxufTtcbl9zdWdnZXN0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG5fYWJvcnQgPSBuZXcgV2Vha01hcCgpO1xuX3N1Z2dlc3REZWJvdW5jZSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIHNyYy9mZWF0dXJlVG9TdWdnZXN0aW9uLnRzXG5mdW5jdGlvbiBmZWF0dXJlVG9TdWdnZXN0aW9uKGZlYXR1cmUpIHtcbiAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBmZWF0dXJlO1xuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoe30sIHByb3BlcnRpZXMpO1xufVxuXG4vLyBzcmMvdmFsaWRhdGUvY29uc3RhbnRzLnRzXG52YXIgU0VBUkNIX1VSTDMgPSBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9hdXRvZmlsbC92MWA7XG52YXIgRU5EUE9JTlRfVkFMSURBVEUgPSBcInJldHJpZXZlXCI7XG52YXIgVkFMSURBVEVfVVJMID0gYCR7U0VBUkNIX1VSTDN9LyR7RU5EUE9JTlRfVkFMSURBVEV9YDtcblxuLy8gc3JjL3ZhbGlkYXRlL01hcGJveFZhbGlkYXRlLnRzXG52YXIgX2dldFF1ZXJ5UGFyYW1zMywgZ2V0UXVlcnlQYXJhbXNfZm4zO1xudmFyIF9NYXBib3hWYWxpZGF0ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9nZXRRdWVyeVBhcmFtczMpO1xuICAgIGNvbnN0IF9hID0gb3B0aW9ucywgeyBhY2Nlc3NUb2tlbiB9ID0gX2EsIGRlZmF1bHRzID0gX19vYmpSZXN0KF9hLCBbXCJhY2Nlc3NUb2tlblwiXSk7XG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgIHRoaXMuZGVmYXVsdHMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgX01hcGJveFZhbGlkYXRlLmRlZmF1bHRzKSwgZGVmYXVsdHMpO1xuICB9XG4gIHZhbGlkYXRlKHNlYXJjaFRleHQsIG9wdGlvbnNBcmcpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCFzZWFyY2hUZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNlYXJjaFRleHQgaXMgcmVxdWlyZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHNlc3Npb25Ub2tlbiwgc2lnbmFsIH0gPSBvcHRpb25zQXJnO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZGVmYXVsdHMpLCBvcHRpb25zQXJnKSwge1xuICAgICAgICBzZXNzaW9uVG9rZW5cbiAgICAgIH0pO1xuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtWQUxJREFURV9VUkx9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHNlYXJjaFRleHQpfWApO1xuICAgICAgdXJsLnNlYXJjaCA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UXVlcnlQYXJhbXMzLCBnZXRRdWVyeVBhcmFtc19mbjMpLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCB7IGZldGNoIH0gPSBnZXRGZXRjaCgpO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHlpZWxkIGhhbmRsZU5vbk9rUmVzKHJlcyk7XG4gICAgICBjb25zdCBqc29uID0geWllbGQgcmVzLmpzb24oKTtcbiAgICAgIGlmIChqc29uLmZlYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAganNvbi5mZWF0dXJlcyA9IFtqc29uLmZlYXR1cmVzWzBdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBqc29uO1xuICAgIH0pO1xuICB9XG59O1xudmFyIE1hcGJveFZhbGlkYXRlID0gX01hcGJveFZhbGlkYXRlO1xuX2dldFF1ZXJ5UGFyYW1zMyA9IG5ldyBXZWFrU2V0KCk7XG5nZXRRdWVyeVBhcmFtc19mbjMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiBxdWVyeVBhcmFtcyh7XG4gICAgYWNjZXNzX3Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlLFxuICAgIGNvdW50cnk6IG9wdGlvbnMuY291bnRyeVxuICB9LCBvcHRpb25zLnNlc3Npb25Ub2tlbiAmJiB7XG4gICAgc2Vzc2lvbl90b2tlbjogU2Vzc2lvblRva2VuLmNvbnZlcnQob3B0aW9ucy5zZXNzaW9uVG9rZW4pLmlkXG4gIH0sIG9wdGlvbnMucHJveGltaXR5ICYmIHtcbiAgICBwcm94aW1pdHk6IHR5cGVvZiBvcHRpb25zLnByb3hpbWl0eSA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMucHJveGltaXR5IDogTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5wcm94aW1pdHkpLnRvQXJyYXkoKS5qb2luKFwiLFwiKVxuICB9LCBvcHRpb25zLmJib3ggJiYge1xuICAgIGJib3g6IHR5cGVvZiBvcHRpb25zLmJib3ggPT09IFwic3RyaW5nXCIgPyBvcHRpb25zLmJib3ggOiBMbmdMYXRCb3VuZHMuY29udmVydChvcHRpb25zLmJib3gpLnRvRmxhdEFycmF5KCkuam9pbihcIixcIilcbiAgfSk7XG59O1xuTWFwYm94VmFsaWRhdGUuZGVmYXVsdHMgPSB7XG4gIGxhbmd1YWdlOiBcImVuXCIsXG4gIHByb3hpbWl0eTogXCJpcFwiXG59O1xuZXhwb3J0IHtcbiAgRXZlbnRlZCxcbiAgTG5nTGF0LFxuICBMbmdMYXRCb3VuZHMsXG4gIE1hcGJveEF1dG9maWxsLFxuICBNYXBib3hFcnJvcixcbiAgTWFwYm94U2VhcmNoLFxuICBNYXBib3hWYWxpZGF0ZSxcbiAgTWF0Y2hDb2RlQ29uZmlkZW5jZSxcbiAgU2VhcmNoU2Vzc2lvbixcbiAgU2Vzc2lvblRva2VuLFxuICBkZWJvdW5jZSxcbiAgZmVhdHVyZVRvU3VnZ2VzdGlvbixcbiAgcG9seWZpbGxGZXRjaFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LWVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@mapbox/search-js-core/dist/index-esm.js\n"));

/***/ }),

/***/ "./node_modules/@mapbox/search-js-react/dist/index-esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@mapbox/search-js-react/dist/index-esm.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AddressAutofill\": function() { return /* binding */ AddressAutofill; },\n/* harmony export */   \"AddressMinimap\": function() { return /* binding */ AddressMinimap; },\n/* harmony export */   \"SearchBox\": function() { return /* binding */ SearchBox; },\n/* harmony export */   \"config\": function() { return /* reexport safe */ _mapbox_search_js_web__WEBPACK_IMPORTED_MODULE_0__.config; },\n/* harmony export */   \"useConfirmAddress\": function() { return /* binding */ useConfirmAddress; },\n/* harmony export */   \"useEvented\": function() { return /* binding */ useEvented; },\n/* harmony export */   \"useMapboxAutofill\": function() { return /* binding */ useMapboxAutofill; },\n/* harmony export */   \"useMapboxSearch\": function() { return /* binding */ useMapboxSearch; },\n/* harmony export */   \"useSearchSession\": function() { return /* binding */ useSearchSession; }\n/* harmony export */ });\n/* harmony import */ var _mapbox_search_js_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mapbox/search-js-web */ \"./node_modules/@mapbox/search-js-web/dist/index-esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mapbox/search-js-core */ \"./node_modules/@mapbox/search-js-core/dist/index-esm.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n// src/index.ts\n\n\n\n// src/components/AddressAutofill.tsx\n\nvar AddressAutofill = react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, refProp) => {\n  const {\n    accessToken,\n    options,\n    theme,\n    popoverOptions,\n    confirmOnBrowserAutofill,\n    children,\n    onSuggest,\n    onSuggestError,\n    onRetrieve\n  } = props;\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(refProp, () => ({\n    focus: () => {\n      if (ref.current)\n        return ref.current.focus();\n      throw new Error(\"AddressAutofill is not mounted\");\n    }\n  }));\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.options = options;\n  }, [ref.current, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.theme = theme;\n  }, [ref.current, theme]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.popoverOptions = popoverOptions;\n  }, [ref.current, popoverOptions]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.confirmOnBrowserAutofill = confirmOnBrowserAutofill;\n  }, [ref.current, confirmOnBrowserAutofill]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onSuggest)\n      return;\n    const fn = (e) => onSuggest(e.detail);\n    node.addEventListener(\"suggest\", fn);\n    return () => {\n      node.removeEventListener(\"suggest\", fn);\n    };\n  }, [ref.current, onSuggest]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onSuggestError)\n      return;\n    const fn = (e) => onSuggestError(e.detail);\n    node.addEventListener(\"suggesterror\", fn);\n    return () => {\n      node.removeEventListener(\"suggesterror\", fn);\n    };\n  }, [ref.current, onSuggestError]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    if (!onRetrieve)\n      return;\n    const fn = (e) => onRetrieve(e.detail);\n    node.addEventListener(\"retrieve\", fn);\n    return () => {\n      node.removeEventListener(\"retrieve\", fn);\n    };\n  }, [ref.current, onRetrieve]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.accessToken = accessToken;\n  }, [ref.current, accessToken]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"mapbox-address-autofill\", {\n    ref\n  }, children);\n});\n\n// src/components/SearchBox.tsx\n\nvar SearchBox = react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, refProp) => {\n  const {\n    accessToken,\n    options,\n    theme,\n    popoverOptions,\n    map,\n    value,\n    onChange,\n    onSuggest,\n    onSuggestError,\n    onRetrieve\n  } = props;\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(refProp, () => ({\n    focus: () => {\n      if (ref.current)\n        return ref.current.focus();\n      throw new Error(\"SearchBox is not mounted\");\n    }\n  }));\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.options = options;\n  }, [ref.current, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.theme = theme;\n  }, [ref.current, theme]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.popoverOptions = popoverOptions;\n  }, [ref.current, popoverOptions]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.value = value;\n  }, [ref.current, value]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    node.bindMap(map);\n    return () => {\n      node.unbindMap();\n    };\n  }, [ref.current, map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    const fn = (e) => onSuggest(e.detail);\n    node.addEventListener(\"suggest\", fn);\n    return () => {\n      node.removeEventListener(\"suggest\", fn);\n    };\n  }, [ref.current, onSuggest]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    const fn = (e) => onSuggestError(e.detail);\n    node.addEventListener(\"suggesterror\", fn);\n    return () => {\n      node.removeEventListener(\"suggesterror\", fn);\n    };\n  }, [ref.current, onSuggestError]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    const fn = (e) => onRetrieve(e.detail);\n    node.addEventListener(\"retrieve\", fn);\n    return () => {\n      node.removeEventListener(\"retrieve\", fn);\n    };\n  }, [ref.current, onRetrieve]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const node = ref.current;\n    if (!node)\n      return;\n    const fn = (e) => onChange(e.detail);\n    node.addEventListener(\"input\", fn);\n    return () => {\n      node.removeEventListener(\"input\", fn);\n    };\n  }, [ref.current, onChange]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.accessToken = accessToken;\n  }, [ref.current, accessToken]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"mapbox-search-box\", {\n    ref\n  });\n});\n\n// src/components/AddressMinimap.tsx\n\nfunction AddressMinimap(props) {\n  const {\n    canAdjustMarker = false,\n    keepMarkerCentered = false,\n    markerAnchor = \"bottom\",\n    onSaveMarkerLocation,\n    show = false,\n    accessToken,\n    feature = null,\n    satelliteToggle = false,\n    theme,\n    mapStyleMode = \"default\",\n    defaultMapStyle = [\"mapbox\", \"streets-v11\"],\n    footer\n  } = props;\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!ref.current)\n      return;\n    if (show) {\n      ref.current.show();\n    } else {\n      ref.current.hide();\n    }\n  }, [ref.current, show]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.theme = theme;\n  }, [ref.current, theme]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.feature = show ? feature : null;\n  }, [ref.current, feature, show]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.mapStyleMode = mapStyleMode;\n  }, [ref.current, mapStyleMode]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.defaultMapStyle = defaultMapStyle;\n  }, [ref.current, defaultMapStyle]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (footer === void 0)\n      return;\n    if (ref.current)\n      ref.current.footer = footer;\n  }, [ref.current, footer]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.accessToken = accessToken;\n  }, [ref.current, accessToken]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ref.current)\n      ref.current.onSaveMarkerLocation = onSaveMarkerLocation;\n  }, [ref.current, onSaveMarkerLocation]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"mapbox-address-minimap\", {\n    ref,\n    \"can-adjust-marker\": canAdjustMarker,\n    \"keep-marker-centered\": keepMarkerCentered,\n    \"marker-anchor\": markerAnchor,\n    \"satellite-toggle\": satelliteToggle\n  });\n}\n\n// src/hooks/useEvented.tsx\n\nfunction useEvented(evented, eventName, cb) {\n  const cbRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(cb);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    cbRef.current = cb;\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!evented)\n      return;\n    const fn = (object) => cbRef.current(object);\n    evented.addEventListener(eventName, fn);\n    return () => {\n      evented.removeEventListener(eventName, fn);\n    };\n  }, [evented, eventName, cbRef]);\n}\n\n// src/hooks/useMapboxAutofill.tsx\n\n\nvar DEFAULTS = _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.MapboxAutofill.defaults;\nfunction useMapboxAutofill(options) {\n  const autofill = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.MapboxAutofill();\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const _a = options, { accessToken } = _a, restOptions = __objRest(_a, [\"accessToken\"]);\n    autofill.accessToken = accessToken;\n    autofill.defaults = __spreadValues(__spreadValues({}, DEFAULTS), restOptions);\n  }, [options]);\n  return autofill;\n}\n\n// src/hooks/useMapboxSearch.tsx\n\n\nvar DEFAULTS2 = _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.MapboxSearch.defaults;\nfunction useMapboxSearch(options) {\n  const search = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.MapboxSearch();\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const _a = options, { accessToken } = _a, restOptions = __objRest(_a, [\"accessToken\"]);\n    search.accessToken = accessToken;\n    search.defaults = __spreadValues(__spreadValues({}, DEFAULTS2), restOptions);\n  }, [options]);\n  return search;\n}\n\n// src/hooks/useSearchSession.tsx\n\n\nfunction useSearchSession(search) {\n  const searchSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.SearchSession(search);\n  }, [search]);\n  if (search instanceof _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_2__.MapboxSearch) {\n    return searchSession;\n  } else {\n    return searchSession;\n  }\n}\n\n// src/hooks/useConfirmAddress.tsx\n\n\nfunction useConfirmAddress(optionsArg = {}) {\n  const formRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return {\n      formRef,\n      showConfirm: () => (0,_mapbox_search_js_web__WEBPACK_IMPORTED_MODULE_0__.confirmAddress)(formRef.current, optionsArg)\n    };\n  }, [formRef, optionsArg]);\n}\n\n//# sourceMappingURL=index-esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hcGJveC9zZWFyY2gtanMtcmVhY3QvZGlzdC9pbmRleC1lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDK0I7QUFDZ0I7O0FBRS9DO0FBQ3NFO0FBQ3RFLHNCQUFzQix1REFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osY0FBYyw2Q0FBTTtBQUNwQixFQUFFLDBEQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QiwwREFBbUI7QUFDNUM7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUN3SDtBQUN4SCxnQkFBZ0IsdURBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osY0FBYyw2Q0FBTztBQUNyQixFQUFFLDBEQUFvQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsMERBQW9CO0FBQzdDO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLDZDQUFPO0FBQ3JCLEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsMERBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDbUU7QUFDbkU7QUFDQSxnQkFBZ0IsNkNBQU87QUFDdkIsRUFBRSxnREFBVTtBQUNaO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUN5RDtBQUNEO0FBQ3hELGVBQWUsMkVBQXVCO0FBQ3RDO0FBQ0EsbUJBQW1CLDhDQUFPO0FBQzFCLGVBQWUsa0VBQWM7QUFDN0IsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWiwwQkFBMEIsY0FBYztBQUN4QztBQUNBLHdEQUF3RDtBQUN4RCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNxRTtBQUNmO0FBQ3RELGdCQUFnQix5RUFBcUI7QUFDckM7QUFDQSxpQkFBaUIsOENBQVE7QUFDekIsZUFBZSxnRUFBWTtBQUMzQixHQUFHO0FBQ0gsRUFBRSxnREFBVTtBQUNaLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0Esc0RBQXNEO0FBQ3RELEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBSWdDO0FBQ1k7QUFDNUM7QUFDQSx3QkFBd0IsOENBQVE7QUFDaEMsZUFBZSxpRUFBYTtBQUM1QixHQUFHO0FBQ0gsd0JBQXdCLGdFQUFhO0FBQ3JDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUMrRDtBQUdoQztBQUMvQiwwQ0FBMEM7QUFDMUMsa0JBQWtCLDZDQUFPO0FBQ3pCLFNBQVMsOENBQVE7QUFDakI7QUFDQTtBQUNBLHlCQUF5QixxRUFBYztBQUN2QztBQUNBLEdBQUc7QUFDSDtBQVdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BtYXBib3gvc2VhcmNoLWpzLXJlYWN0L2Rpc3QvaW5kZXgtZXNtLmpzPzQ5MjgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IFwiQG1hcGJveC9zZWFyY2gtanMtd2ViXCI7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tIFwiQG1hcGJveC9zZWFyY2gtanMtd2ViXCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL0FkZHJlc3NBdXRvZmlsbC50c3hcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIEFkZHJlc3NBdXRvZmlsbCA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWZQcm9wKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBhY2Nlc3NUb2tlbixcbiAgICBvcHRpb25zLFxuICAgIHRoZW1lLFxuICAgIHBvcG92ZXJPcHRpb25zLFxuICAgIGNvbmZpcm1PbkJyb3dzZXJBdXRvZmlsbCxcbiAgICBjaGlsZHJlbixcbiAgICBvblN1Z2dlc3QsXG4gICAgb25TdWdnZXN0RXJyb3IsXG4gICAgb25SZXRyaWV2ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZigpO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZlByb3AsICgpID0+ICh7XG4gICAgZm9jdXM6ICgpID0+IHtcbiAgICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgICAgcmV0dXJuIHJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGRyZXNzQXV0b2ZpbGwgaXMgbm90IG1vdW50ZWRcIik7XG4gICAgfVxuICB9KSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sIFtyZWYuY3VycmVudCwgb3B0aW9uc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50LnRoZW1lID0gdGhlbWU7XG4gIH0sIFtyZWYuY3VycmVudCwgdGhlbWVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC5wb3BvdmVyT3B0aW9ucyA9IHBvcG92ZXJPcHRpb25zO1xuICB9LCBbcmVmLmN1cnJlbnQsIHBvcG92ZXJPcHRpb25zXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQuY29uZmlybU9uQnJvd3NlckF1dG9maWxsID0gY29uZmlybU9uQnJvd3NlckF1dG9maWxsO1xuICB9LCBbcmVmLmN1cnJlbnQsIGNvbmZpcm1PbkJyb3dzZXJBdXRvZmlsbF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFvblN1Z2dlc3QpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZm4gPSAoZSkgPT4gb25TdWdnZXN0KGUuZGV0YWlsKTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIGZuKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdFwiLCBmbik7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBvblN1Z2dlc3RdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghb25TdWdnZXN0RXJyb3IpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZm4gPSAoZSkgPT4gb25TdWdnZXN0RXJyb3IoZS5kZXRhaWwpO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RlcnJvclwiLCBmbik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RlcnJvclwiLCBmbik7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBvblN1Z2dlc3RFcnJvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFvblJldHJpZXZlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGZuID0gKGUpID0+IG9uUmV0cmlldmUoZS5kZXRhaWwpO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcInJldHJpZXZlXCIsIGZuKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicmV0cmlldmVcIiwgZm4pO1xuICAgIH07XG4gIH0sIFtyZWYuY3VycmVudCwgb25SZXRyaWV2ZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50LmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gIH0sIFtyZWYuY3VycmVudCwgYWNjZXNzVG9rZW5dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwibWFwYm94LWFkZHJlc3MtYXV0b2ZpbGxcIiwge1xuICAgIHJlZlxuICB9LCBjaGlsZHJlbik7XG59KTtcblxuLy8gc3JjL2NvbXBvbmVudHMvU2VhcmNoQm94LnRzeFxuaW1wb3J0IFJlYWN0MiwgeyB1c2VSZWYgYXMgdXNlUmVmMiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBTZWFyY2hCb3ggPSBSZWFjdDIuZm9yd2FyZFJlZigocHJvcHMsIHJlZlByb3ApID0+IHtcbiAgY29uc3Qge1xuICAgIGFjY2Vzc1Rva2VuLFxuICAgIG9wdGlvbnMsXG4gICAgdGhlbWUsXG4gICAgcG9wb3Zlck9wdGlvbnMsXG4gICAgbWFwLFxuICAgIHZhbHVlLFxuICAgIG9uQ2hhbmdlLFxuICAgIG9uU3VnZ2VzdCxcbiAgICBvblN1Z2dlc3RFcnJvcixcbiAgICBvblJldHJpZXZlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcmVmID0gdXNlUmVmMigpO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlMihyZWZQcm9wLCAoKSA9PiAoe1xuICAgIGZvY3VzOiAoKSA9PiB7XG4gICAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICAgIHJldHVybiByZWYuY3VycmVudC5mb2N1cygpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VhcmNoQm94IGlzIG5vdCBtb3VudGVkXCIpO1xuICAgIH1cbiAgfSkpO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC5vcHRpb25zID0gb3B0aW9ucztcbiAgfSwgW3JlZi5jdXJyZW50LCBvcHRpb25zXSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50LnRoZW1lID0gdGhlbWU7XG4gIH0sIFtyZWYuY3VycmVudCwgdGhlbWVdKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQucG9wb3Zlck9wdGlvbnMgPSBwb3BvdmVyT3B0aW9ucztcbiAgfSwgW3JlZi5jdXJyZW50LCBwb3BvdmVyT3B0aW9uc10pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICB9LCBbcmVmLmN1cnJlbnQsIHZhbHVlXSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICByZXR1cm47XG4gICAgbm9kZS5iaW5kTWFwKG1hcCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG5vZGUudW5iaW5kTWFwKCk7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBtYXBdKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghbm9kZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmbiA9IChlKSA9PiBvblN1Z2dlc3QoZS5kZXRhaWwpO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RcIiwgZm4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIGZuKTtcbiAgICB9O1xuICB9LCBbcmVmLmN1cnJlbnQsIG9uU3VnZ2VzdF0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBjb25zdCBub2RlID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGZuID0gKGUpID0+IG9uU3VnZ2VzdEVycm9yKGUuZGV0YWlsKTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgZm4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgZm4pO1xuICAgIH07XG4gIH0sIFtyZWYuY3VycmVudCwgb25TdWdnZXN0RXJyb3JdKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghbm9kZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmbiA9IChlKSA9PiBvblJldHJpZXZlKGUuZGV0YWlsKTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXRyaWV2ZVwiLCBmbik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJldHJpZXZlXCIsIGZuKTtcbiAgICB9O1xuICB9LCBbcmVmLmN1cnJlbnQsIG9uUmV0cmlldmVdKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghbm9kZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmbiA9IChlKSA9PiBvbkNoYW5nZShlLmRldGFpbCk7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZm4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmbik7XG4gICAgfTtcbiAgfSwgW3JlZi5jdXJyZW50LCBvbkNoYW5nZV0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICB9LCBbcmVmLmN1cnJlbnQsIGFjY2Vzc1Rva2VuXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJtYXBib3gtc2VhcmNoLWJveFwiLCB7XG4gICAgcmVmXG4gIH0pO1xufSk7XG5cbi8vIHNyYy9jb21wb25lbnRzL0FkZHJlc3NNaW5pbWFwLnRzeFxuaW1wb3J0IFJlYWN0MywgeyB1c2VSZWYgYXMgdXNlUmVmMywgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIEFkZHJlc3NNaW5pbWFwKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjYW5BZGp1c3RNYXJrZXIgPSBmYWxzZSxcbiAgICBrZWVwTWFya2VyQ2VudGVyZWQgPSBmYWxzZSxcbiAgICBtYXJrZXJBbmNob3IgPSBcImJvdHRvbVwiLFxuICAgIG9uU2F2ZU1hcmtlckxvY2F0aW9uLFxuICAgIHNob3cgPSBmYWxzZSxcbiAgICBhY2Nlc3NUb2tlbixcbiAgICBmZWF0dXJlID0gbnVsbCxcbiAgICBzYXRlbGxpdGVUb2dnbGUgPSBmYWxzZSxcbiAgICB0aGVtZSxcbiAgICBtYXBTdHlsZU1vZGUgPSBcImRlZmF1bHRcIixcbiAgICBkZWZhdWx0TWFwU3R5bGUgPSBbXCJtYXBib3hcIiwgXCJzdHJlZXRzLXYxMVwiXSxcbiAgICBmb290ZXJcbiAgfSA9IHByb3BzO1xuICBjb25zdCByZWYgPSB1c2VSZWYzKCk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGlmICghcmVmLmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHNob3cpIHtcbiAgICAgIHJlZi5jdXJyZW50LnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmLmN1cnJlbnQuaGlkZSgpO1xuICAgIH1cbiAgfSwgW3JlZi5jdXJyZW50LCBzaG93XSk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50LnRoZW1lID0gdGhlbWU7XG4gIH0sIFtyZWYuY3VycmVudCwgdGhlbWVdKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQuZmVhdHVyZSA9IHNob3cgPyBmZWF0dXJlIDogbnVsbDtcbiAgfSwgW3JlZi5jdXJyZW50LCBmZWF0dXJlLCBzaG93XSk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50Lm1hcFN0eWxlTW9kZSA9IG1hcFN0eWxlTW9kZTtcbiAgfSwgW3JlZi5jdXJyZW50LCBtYXBTdHlsZU1vZGVdKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQuZGVmYXVsdE1hcFN0eWxlID0gZGVmYXVsdE1hcFN0eWxlO1xuICB9LCBbcmVmLmN1cnJlbnQsIGRlZmF1bHRNYXBTdHlsZV0pO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBpZiAoZm9vdGVyID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJlZi5jdXJyZW50KVxuICAgICAgcmVmLmN1cnJlbnQuZm9vdGVyID0gZm9vdGVyO1xuICB9LCBbcmVmLmN1cnJlbnQsIGZvb3Rlcl0pO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBpZiAocmVmLmN1cnJlbnQpXG4gICAgICByZWYuY3VycmVudC5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICB9LCBbcmVmLmN1cnJlbnQsIGFjY2Vzc1Rva2VuXSk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudClcbiAgICAgIHJlZi5jdXJyZW50Lm9uU2F2ZU1hcmtlckxvY2F0aW9uID0gb25TYXZlTWFya2VyTG9jYXRpb247XG4gIH0sIFtyZWYuY3VycmVudCwgb25TYXZlTWFya2VyTG9jYXRpb25dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChcIm1hcGJveC1hZGRyZXNzLW1pbmltYXBcIiwge1xuICAgIHJlZixcbiAgICBcImNhbi1hZGp1c3QtbWFya2VyXCI6IGNhbkFkanVzdE1hcmtlcixcbiAgICBcImtlZXAtbWFya2VyLWNlbnRlcmVkXCI6IGtlZXBNYXJrZXJDZW50ZXJlZCxcbiAgICBcIm1hcmtlci1hbmNob3JcIjogbWFya2VyQW5jaG9yLFxuICAgIFwic2F0ZWxsaXRlLXRvZ2dsZVwiOiBzYXRlbGxpdGVUb2dnbGVcbiAgfSk7XG59XG5cbi8vIHNyYy9ob29rcy91c2VFdmVudGVkLnRzeFxuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDQsIHVzZVJlZiBhcyB1c2VSZWY0IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VFdmVudGVkKGV2ZW50ZWQsIGV2ZW50TmFtZSwgY2IpIHtcbiAgY29uc3QgY2JSZWYgPSB1c2VSZWY0KGNiKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgY2JSZWYuY3VycmVudCA9IGNiO1xuICB9KTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgaWYgKCFldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGZuID0gKG9iamVjdCkgPT4gY2JSZWYuY3VycmVudChvYmplY3QpO1xuICAgIGV2ZW50ZWQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRlZC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4pO1xuICAgIH07XG4gIH0sIFtldmVudGVkLCBldmVudE5hbWUsIGNiUmVmXSk7XG59XG5cbi8vIHNyYy9ob29rcy91c2VNYXBib3hBdXRvZmlsbC50c3hcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q1LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBNYXBib3hBdXRvZmlsbCB9IGZyb20gXCJAbWFwYm94L3NlYXJjaC1qcy1jb3JlXCI7XG52YXIgREVGQVVMVFMgPSBNYXBib3hBdXRvZmlsbC5kZWZhdWx0cztcbmZ1bmN0aW9uIHVzZU1hcGJveEF1dG9maWxsKG9wdGlvbnMpIHtcbiAgY29uc3QgYXV0b2ZpbGwgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gbmV3IE1hcGJveEF1dG9maWxsKCk7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgY29uc3QgX2EgPSBvcHRpb25zLCB7IGFjY2Vzc1Rva2VuIH0gPSBfYSwgcmVzdE9wdGlvbnMgPSBfX29ialJlc3QoX2EsIFtcImFjY2Vzc1Rva2VuXCJdKTtcbiAgICBhdXRvZmlsbC5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgIGF1dG9maWxsLmRlZmF1bHRzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIERFRkFVTFRTKSwgcmVzdE9wdGlvbnMpO1xuICB9LCBbb3B0aW9uc10pO1xuICByZXR1cm4gYXV0b2ZpbGw7XG59XG5cbi8vIHNyYy9ob29rcy91c2VNYXBib3hTZWFyY2gudHN4XG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NiwgdXNlTWVtbyBhcyB1c2VNZW1vMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgTWFwYm94U2VhcmNoIH0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcbnZhciBERUZBVUxUUzIgPSBNYXBib3hTZWFyY2guZGVmYXVsdHM7XG5mdW5jdGlvbiB1c2VNYXBib3hTZWFyY2gob3B0aW9ucykge1xuICBjb25zdCBzZWFyY2ggPSB1c2VNZW1vMigoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBNYXBib3hTZWFyY2goKTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3Q2KCgpID0+IHtcbiAgICBjb25zdCBfYSA9IG9wdGlvbnMsIHsgYWNjZXNzVG9rZW4gfSA9IF9hLCByZXN0T3B0aW9ucyA9IF9fb2JqUmVzdChfYSwgW1wiYWNjZXNzVG9rZW5cIl0pO1xuICAgIHNlYXJjaC5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgIHNlYXJjaC5kZWZhdWx0cyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBERUZBVUxUUzIpLCByZXN0T3B0aW9ucyk7XG4gIH0sIFtvcHRpb25zXSk7XG4gIHJldHVybiBzZWFyY2g7XG59XG5cbi8vIHNyYy9ob29rcy91c2VTZWFyY2hTZXNzaW9uLnRzeFxuaW1wb3J0IHtcbiAgTWFwYm94U2VhcmNoIGFzIE1hcGJveFNlYXJjaDIsXG4gIFNlYXJjaFNlc3Npb25cbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzMgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVNlYXJjaFNlc3Npb24oc2VhcmNoKSB7XG4gIGNvbnN0IHNlYXJjaFNlc3Npb24gPSB1c2VNZW1vMygoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hTZXNzaW9uKHNlYXJjaCk7XG4gIH0sIFtzZWFyY2hdKTtcbiAgaWYgKHNlYXJjaCBpbnN0YW5jZW9mIE1hcGJveFNlYXJjaDIpIHtcbiAgICByZXR1cm4gc2VhcmNoU2Vzc2lvbjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2VhcmNoU2Vzc2lvbjtcbiAgfVxufVxuXG4vLyBzcmMvaG9va3MvdXNlQ29uZmlybUFkZHJlc3MudHN4XG5pbXBvcnQgeyB1c2VNZW1vIGFzIHVzZU1lbW80LCB1c2VSZWYgYXMgdXNlUmVmNSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgY29uZmlybUFkZHJlc3Ncbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLXdlYlwiO1xuZnVuY3Rpb24gdXNlQ29uZmlybUFkZHJlc3Mob3B0aW9uc0FyZyA9IHt9KSB7XG4gIGNvbnN0IGZvcm1SZWYgPSB1c2VSZWY1KG51bGwpO1xuICByZXR1cm4gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtUmVmLFxuICAgICAgc2hvd0NvbmZpcm06ICgpID0+IGNvbmZpcm1BZGRyZXNzKGZvcm1SZWYuY3VycmVudCwgb3B0aW9uc0FyZylcbiAgICB9O1xuICB9LCBbZm9ybVJlZiwgb3B0aW9uc0FyZ10pO1xufVxuZXhwb3J0IHtcbiAgQWRkcmVzc0F1dG9maWxsLFxuICBBZGRyZXNzTWluaW1hcCxcbiAgU2VhcmNoQm94LFxuICBjb25maWcsXG4gIHVzZUNvbmZpcm1BZGRyZXNzLFxuICB1c2VFdmVudGVkLFxuICB1c2VNYXBib3hBdXRvZmlsbCxcbiAgdXNlTWFwYm94U2VhcmNoLFxuICB1c2VTZWFyY2hTZXNzaW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgtZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@mapbox/search-js-react/dist/index-esm.js\n"));

/***/ }),

/***/ "./node_modules/@mapbox/search-js-web/dist/index-esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/@mapbox/search-js-web/dist/index-esm.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MapboxAddressAutofill\": function() { return /* binding */ MapboxAddressAutofill; },\n/* harmony export */   \"MapboxAddressConfirmation\": function() { return /* binding */ MapboxAddressConfirmation; },\n/* harmony export */   \"MapboxAddressMinimap\": function() { return /* binding */ MapboxAddressMinimap; },\n/* harmony export */   \"MapboxHTMLEvent\": function() { return /* binding */ MapboxHTMLEvent; },\n/* harmony export */   \"MapboxSearchBox\": function() { return /* binding */ MapboxSearchBox; },\n/* harmony export */   \"autofill\": function() { return /* binding */ autofill; },\n/* harmony export */   \"config\": function() { return /* binding */ config; },\n/* harmony export */   \"confirmAddress\": function() { return /* binding */ confirmAddress; },\n/* harmony export */   \"getAutofillSearchText\": function() { return /* binding */ getAutofillSearchText; },\n/* harmony export */   \"getFormAutofillValues\": function() { return /* binding */ getFormAutofillValues; }\n/* harmony export */ });\n/* harmony import */ var _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mapbox/search-js-core */ \"./node_modules/@mapbox/search-js-core/dist/index-esm.js\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"./node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs\");\n/* harmony import */ var no_scroll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! no-scroll */ \"./node_modules/no-scroll/index.js\");\n/* harmony import */ var no_scroll__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(no_scroll__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var focus_trap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! focus-trap */ \"./node_modules/focus-trap/dist/focus-trap.esm.js\");\n/* harmony import */ var _mapbox_sphericalmercator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @mapbox/sphericalmercator */ \"./node_modules/@mapbox/sphericalmercator/sphericalmercator.js\");\n/* harmony import */ var _mapbox_sphericalmercator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_mapbox_sphericalmercator__WEBPACK_IMPORTED_MODULE_4__);\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/utils/dom.ts\nvar subdoc = document.implementation.createHTMLDocument();\nfunction bindElements(root, elements) {\n  const binding = {};\n  for (const [key, selector] of Object.entries(elements)) {\n    binding[key] = root.querySelector(selector);\n  }\n  return binding;\n}\nfunction getChildElements(node) {\n  return Array.from(node.childNodes || []).filter((el) => el.nodeType === Node.ELEMENT_NODE);\n}\nfunction createElementFromString(innerHTML) {\n  const template = document.createElement(\"template\");\n  template.innerHTML = innerHTML;\n  return template.content.firstElementChild;\n}\nfunction createCSSStyleSheet(text) {\n  const style = subdoc.createElement(\"style\");\n  style.textContent = text;\n  subdoc.head.appendChild(style);\n  return style.sheet;\n}\nfunction isVisible(element) {\n  const style = window.getComputedStyle(element);\n  return style.display !== \"none\";\n}\nfunction setValue(input, value) {\n  if (!input) {\n    return;\n  }\n  const set = Object.getOwnPropertyDescriptor(input.constructor.prototype, \"value\").set;\n  set.call(input, value);\n  const wrapperState = input;\n  if (wrapperState._valueTracker) {\n    wrapperState._valueTracker.setValue(\"\");\n  }\n  const onInputEvent = new Event(\"input\", {\n    bubbles: true\n  });\n  onInputEvent.simulated = true;\n  input.dispatchEvent(onInputEvent);\n  const onChangeEvent = new Event(\"change\", {\n    bubbles: true\n  });\n  onChangeEvent.simulated = true;\n  input.dispatchEvent(onChangeEvent);\n}\nfunction getElementSize(element, deep = false) {\n  let width;\n  let height;\n  const elementRect = element.getBoundingClientRect();\n  if (element.style.display === \"none\" || elementRect.height === 0 && elementRect.width === 0) {\n    const clone = element.cloneNode(deep);\n    element.parentElement.appendChild(clone);\n    clone.style.setProperty(\"display\", \"block\", \"important\");\n    const cloneRect = clone.getBoundingClientRect();\n    width = cloneRect.width;\n    height = cloneRect.height;\n    clone.style.setProperty(\"display\", \"none\");\n    clone.remove();\n  } else {\n    width = elementRect.width;\n    height = elementRect.height;\n  }\n  return {\n    height: Math.floor(height),\n    width: Math.floor(width)\n  };\n}\nfunction addDocumentStyle(css) {\n  const style = document.createElement(\"style\");\n  style.innerHTML = css;\n  document.head.appendChild(style);\n}\n\n// src/utils/class_name_transformers.ts\nvar IDENTIFIER_REGEX = new RegExp(\"[_a-zA-Z]+[_a-zA-Z0-9-]*\", \"g\");\nvar CLASS_NAME_REGEX = new RegExp(`\\\\.${IDENTIFIER_REGEX.source}`, \"g\");\nvar CONDITION_RULE_REGEX = new RegExp(`^\\\\s*(@(?:media|supports)[^{]*){(.*)}\\\\s*$`);\nfunction transformClassSelectors(css, transform) {\n  return css.replace(CLASS_NAME_REGEX, (className) => {\n    return \".\" + transform(className.slice(1));\n  });\n}\nfunction transformCSSClassRules(text, transform) {\n  const sheet = createCSSStyleSheet(text);\n  const rules = sheet.cssRules;\n  function transformCSSRule(rule) {\n    if (rule instanceof CSSStyleRule) {\n      const selector = transformClassSelectors(rule.selectorText, transform);\n      return `${selector} { ${rule.style.cssText} }`;\n    }\n    const atRule = CONDITION_RULE_REGEX.exec(rule.cssText.split(\"\\n\").join(\"\"));\n    if (atRule && atRule.length > 2) {\n      const rule2 = atRule[1];\n      const contents = atRule[2];\n      return `${rule2} { ${transformCSSClassRules(contents, transform)} }`;\n    }\n    return rule.cssText;\n  }\n  let style = \"\";\n  for (const rule of Array.from(rules)) {\n    style += transformCSSRule(rule) + \"\\n\\n\";\n  }\n  return style.trim();\n}\nfunction transformDOMClassAttributes(content, transform) {\n  const elements = Array.from(content.querySelectorAll(\"[class]\"));\n  elements.push(content);\n  for (const element of elements) {\n    const { classList } = element;\n    for (const className of Array.from(classList)) {\n      classList.remove(className);\n      classList.add(transform(className));\n    }\n  }\n  return content;\n}\n\n// src/utils/index.ts\n\n\n// src/utils/map.ts\nvar FLY_TO_SPEED = 1.4;\nfunction bboxViewport(map, bounds, delta = 0.5) {\n  const { center, zoom } = map.cameraForBounds(bounds);\n  const transformedZoom = Math.max(zoom - delta, 0);\n  return {\n    center,\n    zoom: transformedZoom,\n    speed: FLY_TO_SPEED\n  };\n}\nfunction getMaxZoom(placeType) {\n  switch (placeType) {\n    case \"street\":\n      return 15;\n    case \"locality\":\n    case \"oaza\":\n      return 14;\n    case \"place\":\n    case \"city\":\n      return 13;\n    case \"district\":\n      return 9;\n    case \"region\":\n    case \"prefecture\":\n      return 6;\n    case \"country\":\n      return 4;\n    default:\n      return 16;\n  }\n}\nfunction getStaticBaseUrl(username, styleId) {\n  return `https://api.mapbox.com/styles/v1/${username}/${styleId}/static/`;\n}\n\n// src/constants.ts\nvar STATIC_BASE_URL_SATELLITE = getStaticBaseUrl(\"mapbox\", \"satellite-streets-v11\");\nvar AUTOFILL_SKU_TOKEN_PREFIX = \"20d01\";\nvar MAPBOX_DOMAINS = [\"mapbox.com\", \"mapbox.cn\", \"tilestream.net\"];\n\n// src/utils/index.ts\nfunction randomValidID() {\n  return `mbx` + new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.SessionToken().id.slice(0, 8);\n}\nfunction tryParseJSON(json) {\n  try {\n    return JSON.parse(json);\n  } catch (e) {\n    return null;\n  }\n}\nfunction deepEquals(a, b) {\n  if (a == null || b == null) {\n    return a === b;\n  }\n  if (typeof a !== \"object\" || typeof b !== \"object\") {\n    return a === b;\n  }\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n  for (const key of aKeys) {\n    if (!deepEquals(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction round(num, decimalPlaces) {\n  const factorOfTen = Math.pow(10, decimalPlaces);\n  return Math.round(num * factorOfTen) / factorOfTen;\n}\nfunction isLocalServer(hostname) {\n  return Boolean(hostname.match(/localhost|[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}|::1|\\.local|^$/gi));\n}\nfunction isMapboxDomain(hostname) {\n  return Boolean(MAPBOX_DOMAINS.some((domain) => hostname.includes(domain)));\n}\n\n// src/components/HTMLScopedElement.ts\nvar _seed, _templateUserStyleElement, _transform;\nvar HTMLScopedElement = class extends HTMLElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _seed, randomValidID());\n    __privateAdd(this, _templateUserStyleElement, void 0);\n    __privateAdd(this, _transform, (className) => {\n      return `${__privateGet(this, _seed)}--${className}`;\n    });\n  }\n  get template() {\n    return null;\n  }\n  get templateStyle() {\n    return null;\n  }\n  get templateUserStyle() {\n    return null;\n  }\n  clonedCallback(oldSeed, newSeed) {\n    const seedTransform = (className) => className.replace(oldSeed, newSeed);\n    transformDOMClassAttributes(this, seedTransform);\n    const styles = Array.from(this.querySelectorAll(\"style\"));\n    for (const style of styles) {\n      style.textContent = transformClassSelectors(style.textContent, seedTransform);\n    }\n    if (styles.length) {\n      __privateSet(this, _templateUserStyleElement, styles[styles.length - 1]);\n    }\n  }\n  connectedCallback() {\n    if (this.childElementCount > 0) {\n      const oldSeed = this.dataset.seed;\n      const newSeed = __privateGet(this, _seed);\n      if (oldSeed && oldSeed !== newSeed) {\n        this.clonedCallback(oldSeed, newSeed);\n        this.dataset.seed = newSeed;\n      }\n      return;\n    }\n    this.dataset.seed = __privateGet(this, _seed);\n    const template = this.template;\n    if (template) {\n      const element = this.prepareTemplate(template);\n      this.appendChild(element);\n    }\n    const templateStyle = this.templateStyle;\n    if (templateStyle) {\n      const style = document.createElement(\"style\");\n      style.textContent = this.prepareCSS(templateStyle);\n      this.appendChild(style);\n    }\n    const userStyle = document.createElement(\"style\");\n    if (this.templateUserStyle) {\n      userStyle.textContent = this.prepareCSS(this.templateUserStyle);\n    }\n    this.appendChild(userStyle);\n    __privateSet(this, _templateUserStyleElement, userStyle);\n  }\n  prepareTemplate(template) {\n    const element = template.content.firstElementChild;\n    return transformDOMClassAttributes(element.cloneNode(true), __privateGet(this, _transform));\n  }\n  prepareCSS(css) {\n    return transformCSSClassRules(css, __privateGet(this, _transform));\n  }\n  updateTemplateUserStyle(style) {\n    if (!__privateGet(this, _templateUserStyleElement)) {\n      return;\n    }\n    __privateGet(this, _templateUserStyleElement).textContent = this.prepareCSS(style);\n  }\n  querySelector(selectors) {\n    return super.querySelector(transformClassSelectors(selectors, __privateGet(this, _transform)));\n  }\n  querySelectorAll(selectors) {\n    return super.querySelectorAll(transformClassSelectors(selectors, __privateGet(this, _transform)));\n  }\n  addEventListener(type, listener, options) {\n    super.addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener, options) {\n    super.removeEventListener(type, listener, options);\n  }\n  dispatchEvent(event) {\n    return super.dispatchEvent(event);\n  }\n};\n_seed = new WeakMap();\n_templateUserStyleElement = new WeakMap();\n_transform = new WeakMap();\n\n// src/MapboxHTMLEvent.ts\nvar MapboxHTMLEvent = class extends CustomEvent {\n  constructor(type, detail) {\n    super(type, {\n      composed: true,\n      detail\n    });\n  }\n  clone(newTarget) {\n    const eventClone = new MapboxHTMLEvent(this.type, this.detail);\n    if (newTarget) {\n      Object.defineProperty(eventClone, \"target\", { value: newTarget });\n    }\n    return eventClone;\n  }\n};\n\n// src/icons/close.svg\nvar close_default = '<svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M3.8 3.8a1 1 0 0 1 1.4 0L9 7.58l3.8-3.8a1 1 0 1 1 1.4 1.42L10.42 9l3.8 3.8a1 1 0 0 1-1.42 1.4L9 10.42l-3.8 3.8a1 1 0 0 1-1.4-1.42L7.58 9l-3.8-3.8a1 1 0 0 1 0-1.4Z\" fill=\"currentColor\"/></svg>';\n\n// src/icons/question.svg\nvar question_default = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><svg viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M9 16A7 7 0 1 0 9 2a7 7 0 0 0 0 14ZM6.88 4.88a2.58 2.58 0 0 1 1.83-.75h1.08a2.58 2.58 0 0 1 2.59 2.58v.16c0 1-.53 1.94-1.4 2.46l-.56.34c-.27.16-.45.42-.52.71-.03.14-.14.25-.28.25H8.38a.23.23 0 0 1-.24-.25c.08-.91.59-1.74 1.38-2.21l.56-.34c.34-.2.54-.57.54-.96V6.7a.83.83 0 0 0-.83-.83H8.71a.83.83 0 0 0-.84.83v.18a.87.87 0 1 1-1.75 0V6.7c0-.69.28-1.34.76-1.83ZM10 13a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z\" fill=\"currentColor\"/></svg>';\n\n// src/icons/marker.svg\nvar marker_default = '<svg width=\"48\" height=\"56\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><g filter=\"url(#a)\"><path d=\"m24 50.4 13.79-14.12a18.82 18.82 0 0 0 4.23-20.86 19.23 19.23 0 0 0-7.19-8.6 19.76 19.76 0 0 0-21.66 0c-3.21 2.11-5.71 5.1-7.19 8.6a18.82 18.82 0 0 0 4.23 20.86L24 50.4Z\" fill=\"currentColor\"/><path d=\"M37.26 35.75 24 49.34 10.75 35.76l-.01-.01A18.07 18.07 0 0 1 6.68 15.7a18.48 18.48 0 0 1 6.9-8.26 19 19 0 0 1 20.84 0 18.48 18.48 0 0 1 6.9 8.26 18.07 18.07 0 0 1-4.06 20.04Z\" stroke=\"#fff\" stroke-width=\"1.5\"/></g><circle cx=\"24\" cy=\"22.45\" fill=\"#fff\" r=\"5.85\"/><defs><filter id=\"a\" x=\".5\" y=\".6\" width=\"47\" height=\"54.8\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\"><feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\"/><feColorMatrix in=\"SourceAlpha\" values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0\" result=\"hardAlpha\"/><feOffset dy=\"1\"/><feGaussianBlur stdDeviation=\"2\"/><feColorMatrix values=\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0\"/><feBlend in2=\"BackgroundImageFix\" result=\"effect1_dropShadow_17_871\"/><feBlend in=\"SourceGraphic\" in2=\"effect1_dropShadow_17_871\" result=\"shape\"/></filter></defs></svg>';\n\n// package.json\nvar version = \"1.0.0-beta.13\";\n\n// src/theme.ts\nvar styleToggleSatelliteImg = `https://api.mapbox.com/search-js/v${version}/img/style-toggle-satellite.jpg`;\nvar styleToggleDefaultImg = `https://api.mapbox.com/search-js/v${version}/img/style-toggle-default.jpg`;\nvar MOBILE_BREAKPOINT = 768 - 1;\nvar MOBILE_MEDIA_QUERY = `@media only screen and (max-width: ${MOBILE_BREAKPOINT}px)`;\nvar DEFAULT_THEME = {\n  variables: {\n    unit: [\"mobile\", \"16px\", \"14px\"],\n    unitHeader: [\"mobile\", \"24px\", \"18px\"],\n    minWidth: \"min(300px, 100vw)\",\n    spacing: \"0.75em\",\n    padding: \"0.5em 0.75em\",\n    paddingModal: \"1.25em\",\n    colorText: \"rgba(0, 0, 0, 0.75)\",\n    colorPrimary: \"#4264FB\",\n    colorSecondary: \"#667F91\",\n    colorBackground: \"#fff\",\n    colorBackgroundHover: \"#f5f5f5\",\n    colorBackgroundActive: \"#f0f0f0\",\n    colorBackdrop: \"rgba(102, 127, 145, 0.3)\",\n    border: \"none\",\n    borderRadius: \"4px\",\n    boxShadow: `\n      0 0 10px 2px rgba(0, 0, 0, 0.05),\n      0 0 6px 1px rgba(0, 0, 0, 0.1),\n      0 0 0 1px rgba(0, 0, 0, 0.1)\n    `,\n    lineHeight: \"1.2em\",\n    fontFamily: `\n      -apple-system, BlinkMacSystemFont,\n      avenir next, avenir,\n      segoe ui,\n      helvetica neue, helvetica,\n      Ubuntu, roboto, noto, arial, sans-serif\n    `,\n    fontWeight: \"normal\",\n    fontWeightSemibold: \"600\",\n    fontWeightBold: \"bold\",\n    duration: \"150ms\",\n    curve: \"ease-out\"\n  },\n  icons: {\n    close: close_default,\n    question: question_default,\n    marker: marker_default\n  },\n  images: {\n    styleToggleDefault: styleToggleDefaultImg,\n    styleToggleSatellite: styleToggleSatelliteImg\n  }\n};\nfunction getThemeCSS(rootSelector, theme = {}) {\n  const variables = __spreadValues(__spreadValues({}, DEFAULT_THEME.variables), theme.variables || {});\n  let cssText = theme.cssText || \"\";\n  let rootVariables = \"\";\n  for (const [key, value] of Object.entries(variables)) {\n    if (!Array.isArray(value)) {\n      rootVariables += `--${key}: ${value};`;\n      continue;\n    }\n    if (value[0] !== \"mobile\") {\n      const valueStr = JSON.stringify(value);\n      throw new Error(`Unsupported expression in theme variables: ${key} ${valueStr}`);\n    }\n    const [, mobileValue, desktopValue] = value;\n    cssText += `${MOBILE_MEDIA_QUERY} { ${rootSelector} { --${key}: ${mobileValue} !important; } }`;\n    rootVariables += `--${key}: ${desktopValue};`;\n  }\n  return cssText + `${rootSelector} { ${rootVariables} }`;\n}\nfunction getIcon(iconName, theme = {}) {\n  const icons = __spreadValues(__spreadValues({}, DEFAULT_THEME.icons), theme.icons || {});\n  const svgString = icons[iconName];\n  return svgString;\n}\nfunction getImage(imageName, theme = {}) {\n  const images = __spreadValues(__spreadValues({}, DEFAULT_THEME.images), theme.images || {});\n  const imgString = images[imageName];\n  return imgString;\n}\n\n// src/utils/popover.ts\n\nvar _options, _defaultOptions;\nvar Popover = class {\n  constructor(referenceEl, floatingEl, options) {\n    __privateAdd(this, _options, void 0);\n    __privateAdd(this, _defaultOptions, {\n      placement: \"bottom-start\",\n      flip: false,\n      offset: 10\n    });\n    this.update = () => __async(this, null, function* () {\n      const config2 = {\n        placement: this.options.placement,\n        middleware: [\n          (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.offset)(this.options.offset),\n          this.options.flip && (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.flip)()\n        ].filter(Boolean)\n      };\n      const { x, y } = yield (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.computePosition)(this.referenceEl, this.floatingEl, config2);\n      Object.assign(this.floatingEl.style, {\n        left: `${x}px`,\n        top: `${y}px`\n      });\n    });\n    this.referenceEl = referenceEl;\n    this.floatingEl = floatingEl;\n    __privateSet(this, _options, __spreadValues(__spreadValues({}, __privateGet(this, _defaultOptions)), options));\n    this.destroy = (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.autoUpdate)(this.referenceEl, this.floatingEl, this.update);\n  }\n  get options() {\n    return __privateGet(this, _options);\n  }\n  set options(newOptions) {\n    __privateSet(this, _options, __spreadValues(__spreadValues({}, __privateGet(this, _options)), newOptions));\n  }\n};\n_options = new WeakMap();\n_defaultOptions = new WeakMap();\n\n// src/style.css\nvar style_default = \"*{box-sizing:border-box!important}[role=button]{cursor:pointer}.MapboxSearch{--width:0;display:none}.Results{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);min-width:var(--minWidth);overflow-y:auto;position:absolute;transform:translateZ(0);transition:visibility var(--duration);width:var(--width);z-index:1000}.Results:not([aria-hidden=true]){visibility:visible}.Results[aria-hidden=true]{animation:fadein var(--duration) var(--curve) reverse forwards;visibility:hidden}.Suggestion{padding:var(--padding)}.Suggestion:hover{cursor:pointer}.Suggestion[aria-selected=true]{background-color:var(--colorBackgroundHover)}.Suggestion:active{background-color:var(--colorBackgroundActive)}.SuggestionName{font-weight:var(--fontWeightBold)}.ResultsAttribution{padding:var(--padding)}.ResultsAttribution a{color:var(--colorSecondary)}.ResultsAttribution a:not(:hover){text-decoration:none}.ResultsList{list-style:none;margin:0;padding:0}.Label{display:none}.Input{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);padding:var(--padding);width:100%}mapbox-address-confirmation-feature[aria-hidden=true],mapbox-address-confirmation-no-feature[aria-hidden=true]{display:none}.MapboxAddressConfirmation{align-items:center;background-color:var(--colorBackdrop);bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;transform:translateZ(0);z-index:1000}.MapboxAddressConfirmation:not([aria-hidden=true]){animation:fadein var(--duration) var(--curve) forwards;visibility:visible}.MapboxAddressConfirmation[aria-hidden=true]{visibility:hidden}.ContentFeature,.ContentNoFeature{width:var(--minWidth)}.Modal{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);padding:var(--paddingModal);width:100%}@media screen and (max-width:480px){.MapboxAddressConfirmation{align-items:flex-end}.ContentFeature,.ContentNoFeature{width:100%}.Modal{border-bottom-left-radius:0;border-bottom-right-radius:0}}.ModalHeader{align-items:center;color:var(--colorPrimary);display:flex;font-size:var(--unitHeader);font-weight:var(--fontWeightBold);margin-bottom:var(--spacing);user-select:none;width:100%}.ModalMap{height:calc(var(--minWidth)*9/16);margin-left:calc(var(--paddingModal)*-1);width:calc(100% + var(--paddingModal)*2)}.ModalMap[aria-hidden=true]{display:none}.Icon{height:var(--unitHeader);width:var(--unitHeader)}.Icon.IconClose{color:var(--colorSecondary)}.ModalHeaderTitle{flex:1;margin-left:.25em}.ModalFooter{color:var(--colorSecondary);margin-top:var(--spacing);text-align:center}.ModalFooter[aria-hidden=true]{display:none}.ModalSubheader{font-weight:var(--fontWeightBold);user-select:none}.ModalDescription{color:var(--colorPrimary)}.ModalAddress,.ModalSubheader{margin-bottom:var(--spacing)}.ModalAddress.ModalAddressApprove{color:var(--colorPrimary)}.Button{border-radius:var(--borderRadius);cursor:pointer;font-weight:var(--fontWeightSemibold);margin-top:var(--spacing);padding:var(--padding);text-align:center;user-select:none;width:100%}.Button[aria-hidden=true]{display:none}.Button.ButtonPrimary{background-color:var(--colorPrimary);color:var(--colorBackground)}.Button.ButtonSecondary{border:1px solid var(--colorSecondary);color:var(--colorSecondary)}@keyframes fadein{0%{opacity:0}to{opacity:1}}.MapboxAddressMinimap{font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight)}.MapboxAddressMinimap[aria-hidden=true]{display:none}.MinimapImageContainer{border-radius:var(--borderRadius);overflow:hidden}.MinimapImage{height:unset;max-height:unset;max-width:unset;position:relative;width:unset}.MinimapInnerFrame{border:var(--border);border-radius:inherit;height:inherit;left:0;overflow:hidden;position:absolute;top:0;width:inherit}.MinimapMarker{left:50%;position:absolute;top:50%}.MinimapMarker>svg{color:var(--colorPrimary);display:block!important}.MinimapAttributionLogo{bottom:0;left:0;margin:0 0 6px 6px;position:absolute}.MinimapAttributionLogo a{cursor:pointer;display:block;height:23px;width:88px}.MinimapAttributionText{background-color:hsla(0,0%,100%,.65);bottom:0;font:11px/16px Helvetica Neue,Arial,Helvetica,sans-serif;padding:0 5px;position:absolute;right:0}.MinimapAttributionText a{color:rgba(0,0,0,.75);text-decoration:none}.MinimapAttributionText a:hover{color:inherit;text-decoration:underline}.MinimapAttributionText a:not(:first-child){margin-left:3px}.MinimapStyleToggle{background-position:0;background-repeat:no-repeat;background-size:contain;border:2px solid #fff;border-radius:3px;box-shadow:var(--boxShadow);cursor:pointer;height:2em;position:absolute;right:var(--spacing);top:var(--spacing);width:2em}.MinimapFooter{color:var(--colorSecondary);font-family:var(--fontFamily);font-size:var(--unit);margin-top:var(--spacing)}.MinimapFooter[aria-hidden=true]{display:none}.MinimapEditButtons{bottom:26px;display:flex;font-family:var(--fontFamily);position:absolute;right:var(--spacing)}.MinimapEditButtons .Button{box-shadow:var(--boxShadow)}.MinimapButtonCancel{background-color:var(--colorBackground);margin-left:var(--spacing)}.draggable{cursor:move;cursor:grab}.draggable:active{cursor:grabbing}\";\n\n// src/components/MapboxSearchListbox.ts\nvar TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"MapboxSearch\">\n      <div class=\"Label\" role=\"label\" aria-live=\"polite\" aria-atomic=\"true\">\n      </div>\n      <div class=\"Results\" aria-hidden=\"true\">\n        <div class=\"ResultsList\" role=\"listbox\">\n        </div>\n        <div class=\"ResultsAttribution\" aria-hidden=\"true\">\n          <a href=\"https://www.mapbox.com/search-service\" target=\"_blank\" tabindex=\"-1\">\n            Powered by Mapbox\n          </a>\n        </div>\n      </div>\n  </div>\n</template>\n`);\nvar RENDER_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"Suggestion\" role=\"option\">\n    <div class=\"SuggestionName\"></div>\n    <div class=\"SuggestionDesc\"></div>\n  </div>\n</template>\n`);\nfunction getAriaIdForSuggestion(resultListId, i) {\n  return `${resultListId}-${i}`;\n}\nvar _sessionInternal, _popover, _binding, _labelID, _resultListID, _inputInternal, _selectedIndexInternal, _showResults, showResults_fn, _hideResults, hideResults_fn, _renderResultsList, renderResultsList_fn, _optionsInternal, _themeInternal, _popoverOptions, _handleInput, _handleSuggest, _handleSuggestError, _handleFocus, _handleBlur, _handleKeyDown;\nvar MapboxSearchListbox = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _showResults);\n    __privateAdd(this, _hideResults);\n    __privateAdd(this, _renderResultsList);\n    __privateAdd(this, _sessionInternal, void 0);\n    __privateAdd(this, _popover, null);\n    __privateAdd(this, _binding, void 0);\n    __privateAdd(this, _labelID, randomValidID());\n    __privateAdd(this, _resultListID, randomValidID());\n    __privateAdd(this, _inputInternal, void 0);\n    __privateAdd(this, _selectedIndexInternal, 0);\n    __privateAdd(this, _optionsInternal, {});\n    __privateAdd(this, _themeInternal, {});\n    __privateAdd(this, _popoverOptions, {});\n    this.retrieveFeature = null;\n    __privateAdd(this, _handleInput, (e) => {\n      const { Results } = __privateGet(this, _binding);\n      const input = e.target;\n      if (input.dataset[\"mapboxSuccess\"]) {\n        delete input.dataset[\"mapboxSuccess\"];\n        return;\n      }\n      const searchText = input.value;\n      Results.setAttribute(\"aria-busy\", \"true\");\n      this.session.suggest(searchText, this.options);\n    });\n    __privateAdd(this, _handleSuggest, (result) => {\n      if (!result || !result.suggestions) {\n        __privateMethod(this, _hideResults, hideResults_fn).call(this);\n        return;\n      }\n      __privateMethod(this, _renderResultsList, renderResultsList_fn).call(this);\n      if (result.suggestions.length) {\n        __privateMethod(this, _showResults, showResults_fn).call(this);\n      }\n      this.dispatchEvent(new MapboxHTMLEvent(\"suggest\", result));\n      const { Results } = __privateGet(this, _binding);\n      Results.setAttribute(\"aria-busy\", \"false\");\n    });\n    __privateAdd(this, _handleSuggestError, (error) => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"suggesterror\", error));\n      const { Results } = __privateGet(this, _binding);\n      Results.setAttribute(\"aria-busy\", \"false\");\n      __privateMethod(this, _hideResults, hideResults_fn).call(this);\n    });\n    __privateAdd(this, _handleFocus, () => {\n      const input = this.input;\n      delete input.dataset[\"mapboxSuccess\"];\n      __privateMethod(this, _showResults, showResults_fn).call(this);\n    });\n    __privateAdd(this, _handleBlur, () => {\n      if (document.activeElement === this.input) {\n        return;\n      }\n      this.session.abort();\n      __privateMethod(this, _hideResults, hideResults_fn).call(this);\n    });\n    __privateAdd(this, _handleKeyDown, (e) => {\n      if (e.key === \"Escape\") {\n        __privateMethod(this, _hideResults, hideResults_fn).call(this);\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        this.selectedIndex = Math.max(0, this.selectedIndex - 1);\n        return;\n      }\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        this.selectedIndex = Math.min(this.selectedIndex + 1, this.suggestions.length - 1);\n        return;\n      }\n      if (e.key === \"Enter\") {\n        e.preventDefault();\n        this.retrieve(this.suggestions[this.selectedIndex]);\n        return;\n      }\n    });\n  }\n  get template() {\n    return TEMPLATE;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxSearch\", this.theme);\n  }\n  get session() {\n    return __privateGet(this, _sessionInternal);\n  }\n  set session(newSession) {\n    const oldSession = __privateGet(this, _sessionInternal);\n    if (oldSession) {\n      newSession.removeEventListener(\"suggest\", __privateGet(this, _handleSuggest));\n      newSession.removeEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError));\n    }\n    if (newSession) {\n      newSession.addEventListener(\"suggest\", __privateGet(this, _handleSuggest));\n      newSession.addEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError));\n    }\n    __privateSet(this, _sessionInternal, newSession);\n  }\n  get suggestions() {\n    var _a;\n    return (_a = this.session.suggestions) == null ? void 0 : _a.suggestions;\n  }\n  get input() {\n    return __privateGet(this, _inputInternal);\n  }\n  set input(newInput) {\n    const oldInput = __privateGet(this, _inputInternal);\n    if (oldInput) {\n      oldInput.removeEventListener(\"input\", __privateGet(this, _handleInput));\n      oldInput.removeEventListener(\"focus\", __privateGet(this, _handleFocus));\n      oldInput.removeEventListener(\"blur\", __privateGet(this, _handleBlur));\n      oldInput.removeEventListener(\"keydown\", __privateGet(this, _handleKeyDown));\n      if (__privateGet(this, _popover)) {\n        __privateGet(this, _popover).destroy();\n      }\n    }\n    if (newInput) {\n      newInput.addEventListener(\"input\", __privateGet(this, _handleInput));\n      newInput.addEventListener(\"focus\", __privateGet(this, _handleFocus));\n      newInput.addEventListener(\"blur\", __privateGet(this, _handleBlur));\n      newInput.addEventListener(\"keydown\", __privateGet(this, _handleKeyDown));\n      newInput.setAttribute(\"role\", \"combobox\");\n      newInput.setAttribute(\"aria-autocomplete\", \"list\");\n      newInput.setAttribute(\"aria-controls\", __privateGet(this, _resultListID));\n      if (this.isConnected) {\n        __privateSet(this, _popover, new Popover(newInput, __privateGet(this, _binding).Results, this.popoverOptions));\n      }\n    }\n    __privateSet(this, _inputInternal, newInput);\n  }\n  get selectedIndex() {\n    return __privateGet(this, _selectedIndexInternal);\n  }\n  set selectedIndex(newIndex) {\n    const oldIndex = __privateGet(this, _selectedIndexInternal);\n    __privateSet(this, _selectedIndexInternal, newIndex);\n    const { ResultsList, Label } = __privateGet(this, _binding);\n    const id = getAriaIdForSuggestion(__privateGet(this, _resultListID), newIndex);\n    this.input.setAttribute(\"aria-activedescendant\", id);\n    ResultsList.setAttribute(\"aria-activedescendant\", id);\n    if (oldIndex !== newIndex) {\n      const oldId = getAriaIdForSuggestion(__privateGet(this, _resultListID), oldIndex);\n      const oldEl = ResultsList.querySelector(`#${oldId}`);\n      oldEl == null ? void 0 : oldEl.removeAttribute(\"aria-selected\");\n      const el = ResultsList.querySelector(`#${id}`);\n      el == null ? void 0 : el.setAttribute(\"aria-selected\", \"true\");\n    }\n    Label.textContent = this.suggestions[newIndex].address + `: Suggestion ${newIndex + 1} of ${this.suggestions.length}`;\n  }\n  renderItem(i) {\n    const element = this.prepareTemplate(RENDER_TEMPLATE);\n    element.id = getAriaIdForSuggestion(__privateGet(this, _resultListID), i);\n    return element;\n  }\n  fillItem(el, item, i) {\n    const [nameEl, descriptionEl] = Array.from(el.querySelectorAll('[role=\"option\"] > *'));\n    nameEl.textContent = \"address_line1\" in item ? item.address_line1 || item.matching_name || item.feature_name : item.matching_name || item.feature_name;\n    descriptionEl.textContent = item.description;\n    if (i === this.selectedIndex) {\n      el.setAttribute(\"aria-selected\", \"true\");\n    } else {\n      el.removeAttribute(\"aria-selected\");\n    }\n  }\n  get options() {\n    return __privateGet(this, _optionsInternal);\n  }\n  set options(newOptions) {\n    __privateSet(this, _optionsInternal, newOptions);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal, theme);\n    if (!__privateGet(this, _binding) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxSearch\", theme));\n  }\n  get popoverOptions() {\n    return __privateGet(this, _popoverOptions);\n  }\n  set popoverOptions(newOptions) {\n    __privateSet(this, _popoverOptions, newOptions);\n    if (__privateGet(this, _popover)) {\n      __privateGet(this, _popover).options = newOptions;\n      __privateGet(this, _popover).update();\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding, bindElements(this, {\n      MapboxSearch: \".MapboxSearch\",\n      Results: \".Results\",\n      ResultsList: \".ResultsList\",\n      Label: \".Label\"\n    }));\n    const { Results, ResultsList, Label } = __privateGet(this, _binding);\n    Label.id = __privateGet(this, _labelID);\n    ResultsList.id = __privateGet(this, _resultListID);\n    ResultsList.setAttribute(\"aria-labelledby\", __privateGet(this, _labelID));\n    Results.addEventListener(\"blur\", __privateGet(this, _handleBlur));\n    if (!__privateGet(this, _popover) && this.input) {\n      __privateSet(this, _popover, new Popover(this.input, __privateGet(this, _binding).Results, this.popoverOptions));\n    }\n    requestAnimationFrame(() => {\n      if (__privateGet(this, _popover)) {\n        __privateGet(this, _popover).update();\n      }\n    });\n  }\n  disconnectedCallback() {\n    this.input = null;\n    const { Results } = __privateGet(this, _binding);\n    Results.removeEventListener(\"blur\", __privateGet(this, _handleBlur));\n    if (__privateGet(this, _popover))\n      __privateGet(this, _popover).destroy();\n  }\n  retrieve(suggestion) {\n    return __async(this, null, function* () {\n      var _a;\n      const input = this.input;\n      if (input) {\n        input.dataset[\"mapboxSuccess\"] = \"true\";\n      }\n      const result = yield this.session.retrieve(suggestion, this.options);\n      this.retrieveFeature = (_a = result.features) == null ? void 0 : _a[0];\n      __privateMethod(this, _hideResults, hideResults_fn).call(this);\n      this.dispatchEvent(new MapboxHTMLEvent(\"retrieve\", result));\n    });\n  }\n  simulateRetrieve(feature) {\n    const input = this.input;\n    if (input) {\n      input.dataset[\"mapboxSuccess\"] = \"true\";\n    }\n    this.retrieveFeature = feature;\n    const simResult = {\n      type: \"FeatureCollection\",\n      features: [feature]\n    };\n    __privateMethod(this, _hideResults, hideResults_fn).call(this);\n    this.dispatchEvent(new MapboxHTMLEvent(\"retrieve\", simResult));\n  }\n  focus() {\n    if (document.activeElement === this.input) {\n      __privateGet(this, _handleFocus).call(this);\n    } else {\n      this.input.focus();\n    }\n  }\n  blur() {\n    this.input.blur();\n  }\n  updatePopover() {\n    if (__privateGet(this, _popover)) {\n      __privateGet(this, _popover).update();\n    }\n  }\n};\n_sessionInternal = new WeakMap();\n_popover = new WeakMap();\n_binding = new WeakMap();\n_labelID = new WeakMap();\n_resultListID = new WeakMap();\n_inputInternal = new WeakMap();\n_selectedIndexInternal = new WeakMap();\n_showResults = new WeakSet();\nshowResults_fn = function() {\n  if (!this.suggestions || !this.suggestions.length) {\n    return;\n  }\n  const { Results, MapboxSearch: MapboxSearch2 } = __privateGet(this, _binding);\n  const rect = this.input.getBoundingClientRect();\n  MapboxSearch2.style.setProperty(\"--width\", `${rect.width}px`);\n  MapboxSearch2.style.setProperty(\"display\", \"block\");\n  this.input.setAttribute(\"aria-expanded\", \"true\");\n  Results.removeAttribute(\"aria-hidden\");\n  this.selectedIndex = 0;\n};\n_hideResults = new WeakSet();\nhideResults_fn = function() {\n  const { Results, ResultsList } = __privateGet(this, _binding);\n  Results.setAttribute(\"aria-hidden\", \"true\");\n  this.input.removeAttribute(\"aria-expanded\");\n  ResultsList.removeAttribute(\"aria-activedescendant\");\n  this.input.removeAttribute(\"aria-activedescendant\");\n};\n_renderResultsList = new WeakSet();\nrenderResultsList_fn = function() {\n  const { ResultsList } = __privateGet(this, _binding);\n  const suggestions = this.suggestions;\n  if (!suggestions || !suggestions.length) {\n    ResultsList.innerHTML = \"\";\n    __privateMethod(this, _hideResults, hideResults_fn).call(this);\n    return;\n  }\n  const elements = getChildElements(ResultsList);\n  if (suggestions.length > elements.length) {\n    for (let i = elements.length; i < suggestions.length; i++) {\n      const item = this.renderItem(i);\n      elements.push(item);\n      item.onmouseenter = () => {\n        this.selectedIndex = i;\n      };\n      ResultsList.appendChild(item);\n    }\n  }\n  if (suggestions.length < elements.length) {\n    for (let i = suggestions.length; i < elements.length; i++) {\n      elements[i].remove();\n    }\n  }\n  for (const suggestion of suggestions) {\n    const i = suggestions.indexOf(suggestion);\n    const element = elements[i];\n    this.fillItem(element, suggestion, i);\n    element.onclick = () => {\n      this.retrieve(suggestion);\n    };\n  }\n};\n_optionsInternal = new WeakMap();\n_themeInternal = new WeakMap();\n_popoverOptions = new WeakMap();\n_handleInput = new WeakMap();\n_handleSuggest = new WeakMap();\n_handleSuggestError = new WeakMap();\n_handleFocus = new WeakMap();\n_handleBlur = new WeakMap();\n_handleKeyDown = new WeakMap();\nwindow.MapboxSearchListbox = MapboxSearchListbox;\nif (!window.customElements.get(\"mapbox-search-listbox\")) {\n  customElements.define(\"mapbox-search-listbox\", MapboxSearchListbox);\n}\n\n// src/utils/aria.ts\nfunction ariaButtonKeyDown(e) {\n  const el = e.currentTarget;\n  if (e.key === \" \" || e.key === \"Enter\") {\n    e.preventDefault();\n    e.stopPropagation();\n    el.dispatchEvent(new MouseEvent(\"click\", {\n      bubbles: true,\n      composed: true\n    }));\n  }\n}\n\n// src/utils/autofill.ts\n\nvar AUTOFILL_TOKENS = /* @__PURE__ */ new Set([\n  \"street-address\",\n  \"address-line1\",\n  \"address-line2\",\n  \"address-line3\",\n  \"address-level4\",\n  \"address-level3\",\n  \"address-level2\",\n  \"address-level1\",\n  \"country\",\n  \"country-name\",\n  \"postal-code\"\n]);\nvar AUTOFILL_SKIP_TOKENS = /* @__PURE__ */ new Set([\"off\", \"on\", \"true\", \"false\"]);\nfunction findParentForm(el) {\n  let node = el.parentNode;\n  while (node) {\n    if (node instanceof HTMLFormElement) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\nfunction findAddressInputs(form) {\n  const parent = form || document;\n  return Array.from(parent.querySelectorAll('input[autocomplete~=\"address-line1\"], input[autocomplete~=\"street-address\"]'));\n}\nvar SECTION = \"section-\";\nvar SECTION_DEFAULT = \"section-default\";\nvar SECTION_SHIPPING = \"section-shipping\";\nvar SECTION_BILLING = \"section-billing\";\nfunction parseFormStructure(form) {\n  const inputs = Array.from(form.querySelectorAll(\"[autocomplete]\")).filter((el) => {\n    const tagName = el.tagName.toLowerCase();\n    return tagName === \"input\" || tagName === \"select\" || tagName === \"textarea\";\n  });\n  const res = [];\n  for (const input of inputs) {\n    if (!isVisible(input)) {\n      continue;\n    }\n    const autocomplete = input.getAttribute(\"autocomplete\") || \"\";\n    if (!autocomplete || AUTOFILL_SKIP_TOKENS.has(autocomplete)) {\n      continue;\n    }\n    const tokens = autocomplete.toLowerCase().split(\" \");\n    if (tokens.length > 3) {\n      continue;\n    }\n    const field = tokens[tokens.length - 1];\n    if (!AUTOFILL_TOKENS.has(field)) {\n      continue;\n    }\n    tokens.pop();\n    let section = SECTION_DEFAULT;\n    if (tokens.length) {\n      const sectionToken = tokens[tokens.length - 1];\n      if (sectionToken === \"shipping\") {\n        section = SECTION_SHIPPING;\n        tokens.pop();\n      }\n      if (sectionToken === \"billing\") {\n        section = SECTION_BILLING;\n        tokens.pop();\n      }\n    }\n    if (tokens.length) {\n      const sectionToken = tokens[tokens.length - 1];\n      if (sectionToken.startsWith(SECTION)) {\n        section = sectionToken;\n      }\n    }\n    res.push({\n      input,\n      section,\n      field\n    });\n  }\n  return res;\n}\nfunction findAddressAutofillInputs(form, ref) {\n  const logicalSections = [];\n  const logicalSectionSections = [];\n  const formStructure = parseFormStructure(form);\n  let foundSection = null;\n  for (const { input, section, field } of formStructure) {\n    let lastIndex = logicalSections.length - 1;\n    let createNewSection = false;\n    if (!logicalSections.length) {\n      createNewSection = true;\n    } else if (logicalSectionSections[lastIndex] !== section) {\n      createNewSection = true;\n    } else if (logicalSections[lastIndex][field]) {\n      createNewSection = true;\n    }\n    if (createNewSection) {\n      if (foundSection) {\n        break;\n      }\n      logicalSections.push({\n        [field]: input\n      });\n      logicalSectionSections.push(section);\n      lastIndex++;\n    } else {\n      logicalSections[lastIndex][field] = input;\n    }\n    if (input === ref) {\n      foundSection = logicalSections[lastIndex];\n    }\n  }\n  return foundSection != null ? foundSection : {};\n}\nfunction setFormAutofillValues(form, ref, suggestion) {\n  var _a;\n  const map = findAddressAutofillInputs(form, ref);\n  const streetAddress = [\n    suggestion.address_line1,\n    suggestion.address_line2,\n    suggestion.address_line3\n  ].filter((part) => Boolean(part)).join(\", \");\n  setValue(map[\"street-address\"], streetAddress);\n  setValue(map[\"address-line1\"], suggestion.address_line1 || \"\");\n  setValue(map[\"address-level1\"], suggestion.address_level1 || \"\");\n  setValue(map[\"address-level2\"], suggestion.address_level2 || \"\");\n  setValue(map[\"address-level3\"], suggestion.address_level3 || \"\");\n  const countryCode = ((_a = suggestion.metadata) == null ? void 0 : _a.iso_3166_1) || \"\";\n  if (map.country && map.country instanceof HTMLSelectElement) {\n    const firstOption = map.country.querySelector(`option`).value;\n    const isUpperCase = firstOption === firstOption.toUpperCase();\n    setValue(map[\"country\"], isUpperCase ? countryCode.toUpperCase() : countryCode);\n  } else {\n    setValue(map[\"country\"], countryCode);\n  }\n  setValue(map[\"country-name\"], suggestion.country || \"\");\n  setValue(map[\"postal-code\"], suggestion.postcode || \"\");\n}\nfunction getFormAutofillValues(form, ref) {\n  const map = findAddressAutofillInputs(form, ref);\n  const values = {};\n  for (const [key, input] of Object.entries(map)) {\n    if (input == null ? void 0 : input.value) {\n      values[key] = input.value;\n    }\n  }\n  return values;\n}\nfunction getAutofillSearchText(snapshot) {\n  const searchText = [];\n  if (snapshot[\"street-address\"]) {\n    searchText.push(snapshot[\"street-address\"]);\n  } else {\n    searchText.push(snapshot[\"address-line1\"] || \"\");\n    searchText.push(snapshot[\"address-line2\"] || \"\");\n    searchText.push(snapshot[\"address-line3\"] || \"\");\n  }\n  searchText.push(snapshot[\"address-level3\"] || \"\");\n  searchText.push(snapshot[\"address-level2\"] || \"\");\n  searchText.push(snapshot[\"address-level1\"] || \"\");\n  searchText.push(snapshot[\"postal-code\"] || \"\");\n  if (snapshot[\"country-name\"]) {\n    searchText.push(snapshot[\"country-name\"]);\n  } else {\n    searchText.push(snapshot[\"country\"] || \"\");\n  }\n  return searchText.filter((part) => Boolean(part)).join(\", \");\n}\nfunction fillFormWithFeature(feature, input) {\n  const form = findParentForm(input);\n  if (!form) {\n    return;\n  }\n  const suggestion = (0,_mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.featureToSuggestion)(feature);\n  setFormAutofillValues(form, input, suggestion);\n}\nfunction featureToAutofillValueMap(feature) {\n  var _a;\n  const values = {};\n  const streetAddress = [\n    feature.properties.address_line1,\n    feature.properties.address_line2,\n    feature.properties.address_line3\n  ].filter((part) => Boolean(part)).join(\", \");\n  values[\"street-address\"] = streetAddress;\n  values[\"address-line1\"] = feature.properties.address_line1;\n  values[\"address-line2\"] = feature.properties.address_line2;\n  values[\"address-line3\"] = feature.properties.address_line3;\n  values[\"address-level1\"] = feature.properties.address_level1;\n  values[\"address-level2\"] = feature.properties.address_level2;\n  values[\"address-level3\"] = feature.properties.address_level3;\n  values[\"country\"] = (_a = feature.properties.metadata) == null ? void 0 : _a.iso_3166_1;\n  values[\"country-name\"] = feature.properties.country;\n  values[\"postal-code\"] = feature.properties.postcode;\n  return values;\n}\nfunction checkAutofillValuesChanged(targetMap, referenceMap) {\n  for (const [key, value] of Object.entries(targetMap)) {\n    if (referenceMap[key] !== value)\n      return true;\n  }\n  return false;\n}\n\n// src/confirmAddress.ts\n\n\n// src/components/MapboxAddressConfirmation.ts\n\n\n\n\n// src/config.ts\n\nvar Config = class {\n  constructor() {\n    this.feedbackEnabled = true;\n    this.autofillSessionToken = new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.SessionToken();\n    this.autofillSessionEnabled = false;\n    this.detectBrowserAutofillEnabled = false;\n  }\n};\nvar config = new Config();\nObject.defineProperty(config, \"autofillSessionToken\", {\n  configurable: false,\n  writable: false\n});\n\n// src/components/MapboxAddressConfirmation.ts\nvar TEMPLATE2 = createElementFromString(`\n<template>\n  <div class=\"MapboxAddressConfirmation\" aria-hidden=\"true\">\n    <mapbox-address-confirmation-feature class=\"ContentFeature\"></mapbox-address-confirmation-feature>\n    <mapbox-address-confirmation-no-feature class=\"ContentNoFeature\"></mapbox-address-confirmation-no-feature>\n  </div>\n</template>\n`);\nvar _show, _binding2, _focusTrap, _themeInternal2;\nvar MapboxAddressConfirmation = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _show, false);\n    __privateAdd(this, _binding2, void 0);\n    __privateAdd(this, _focusTrap, void 0);\n    __privateAdd(this, _themeInternal2, {});\n  }\n  get template() {\n    return TEMPLATE2;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxAddressConfirmation\", this.theme);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal2);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal2, theme);\n    if (!__privateGet(this, _binding2) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxAddressConfirmation\", theme));\n    const { ContentFeature, ContentNoFeature } = __privateGet(this, _binding2);\n    ContentFeature.theme = theme;\n    ContentNoFeature.theme = theme;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding2, bindElements(this, {\n      MapboxAddressConfirmation: \".MapboxAddressConfirmation\",\n      ContentFeature: \".ContentFeature\",\n      ContentNoFeature: \".ContentNoFeature\"\n    }));\n    const { MapboxAddressConfirmation: MapboxAddressConfirmation2 } = __privateGet(this, _binding2);\n    MapboxAddressConfirmation2.setAttribute(\"aria-hidden\", \"true\");\n    const theme = this.theme;\n    if (theme) {\n      const { ContentFeature, ContentNoFeature } = __privateGet(this, _binding2);\n      ContentFeature.theme = theme;\n      ContentNoFeature.theme = theme;\n    }\n  }\n  disconnectedCallback() {\n    __privateSet(this, _focusTrap, null);\n  }\n  hide() {\n    var _a;\n    __privateSet(this, _show, false);\n    if (!__privateGet(this, _binding2)) {\n      return;\n    }\n    const { MapboxAddressConfirmation: MapboxAddressConfirmation2 } = __privateGet(this, _binding2);\n    MapboxAddressConfirmation2.setAttribute(\"aria-hidden\", \"true\");\n    (_a = __privateGet(this, _focusTrap)) == null ? void 0 : _a.deactivate();\n    no_scroll__WEBPACK_IMPORTED_MODULE_2___default().off();\n  }\n  show(autofillValues, optionsArg, feature) {\n    return __async(this, null, function* () {\n      var _a;\n      if (!__privateGet(this, _binding2)) {\n        return { type: \"cancel\" };\n      }\n      const { MapboxAddressConfirmation: MapboxAddressConfirmation2, ContentFeature, ContentNoFeature } = __privateGet(this, _binding2);\n      const { accessToken, minimap = false, theme, footer } = optionsArg;\n      this.theme = theme;\n      if (feature) {\n        ContentFeature.removeAttribute(\"aria-hidden\");\n        ContentNoFeature.setAttribute(\"aria-hidden\", \"true\");\n        ContentFeature.minimap = minimap;\n        ContentFeature.accessToken = accessToken;\n        ContentFeature.footer = footer;\n        ContentFeature.update(feature, autofillValues);\n      } else {\n        ContentFeature.setAttribute(\"aria-hidden\", \"true\");\n        ContentNoFeature.removeAttribute(\"aria-hidden\");\n        ContentNoFeature.update(autofillValues);\n      }\n      __privateSet(this, _show, true);\n      MapboxAddressConfirmation2.removeAttribute(\"aria-hidden\");\n      no_scroll__WEBPACK_IMPORTED_MODULE_2___default().on();\n      const activeContentElement = feature ? ContentFeature : ContentNoFeature;\n      __privateSet(this, _focusTrap, (0,focus_trap__WEBPACK_IMPORTED_MODULE_3__.createFocusTrap)(MapboxAddressConfirmation2, {\n        fallbackFocus: activeContentElement,\n        escapeDeactivates: () => {\n          this.hide();\n          return true;\n        }\n      }));\n      (_a = __privateGet(this, _focusTrap)) == null ? void 0 : _a.activate();\n      return new Promise((resolve) => {\n        const eventHost = activeContentElement;\n        const fn = (e) => {\n          eventHost.removeEventListener(\"result\", fn);\n          const result = e.detail;\n          this.hide();\n          if (result === \"change\") {\n            resolve({\n              type: \"change\",\n              feature\n            });\n          } else {\n            resolve({\n              type: result\n            });\n          }\n        };\n        eventHost.addEventListener(\"result\", fn);\n      });\n    });\n  }\n  tryShow(autofillValues, optionsArg) {\n    return __async(this, null, function* () {\n      if (!__privateGet(this, _binding2)) {\n        return { type: \"cancel\" };\n      }\n      const { accessToken, options = {} } = optionsArg;\n      const validate = new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.MapboxValidate(__spreadValues({\n        accessToken\n      }, options));\n      const searchText = getAutofillSearchText(autofillValues);\n      const featureCollection = yield validate.validate(searchText, {\n        sessionToken: config.autofillSessionToken\n      });\n      const feature = featureCollection.features[0];\n      if (feature) {\n        const defaultValidation = (feature2) => feature2.properties.match_code.confidence === _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.MatchCodeConfidence.exact;\n        const { skipConfirmModal = defaultValidation } = optionsArg;\n        if (skipConfirmModal(feature)) {\n          return { type: \"nochange\" };\n        }\n      }\n      return yield this.show(autofillValues, optionsArg, feature);\n    });\n  }\n};\n_show = new WeakMap();\n_binding2 = new WeakMap();\n_focusTrap = new WeakMap();\n_themeInternal2 = new WeakMap();\nwindow.MapboxAddressConfirmation = MapboxAddressConfirmation;\nif (!window.customElements.get(\"mapbox-address-confirmation\")) {\n  customElements.define(\"mapbox-address-confirmation\", MapboxAddressConfirmation);\n}\n\n// src/confirmAddress.ts\nvar confirmation = new MapboxAddressConfirmation();\nfunction confirmAddress(_0) {\n  return __async(this, arguments, function* (form, optionsArg = {}) {\n    const { sections = [] } = optionsArg;\n    if (!confirmation.parentNode) {\n      document.body.appendChild(confirmation);\n    }\n    let collectedResult = { type: \"nochange\" };\n    const inputs = findAddressInputs(form);\n    const structure = parseFormStructure(form);\n    const listboxComponents = Array.from(document.querySelectorAll(\"mapbox-search-listbox\"));\n    for (const input of inputs) {\n      if (sections.length) {\n        const structureRef = structure.find((s) => s.input === input);\n        if (!structureRef) {\n          continue;\n        }\n        if (!sections.includes(structureRef.section)) {\n          continue;\n        }\n      }\n      const autofillValues = getFormAutofillValues(form, input);\n      const listbox = listboxComponents.find((lb) => lb.input === input);\n      if (listbox) {\n        const lastRetrievedFeature = listbox.retrieveFeature;\n        if (lastRetrievedFeature) {\n          const snapshot = featureToAutofillValueMap(lastRetrievedFeature);\n          if (!checkAutofillValuesChanged(autofillValues, snapshot)) {\n            continue;\n          }\n        }\n      }\n      const accessToken = optionsArg.accessToken || config.accessToken;\n      const result = yield confirmation.tryShow(autofillValues, __spreadProps(__spreadValues({}, optionsArg), {\n        accessToken\n      }));\n      if (result.type === \"change\") {\n        if (listbox) {\n          listbox.simulateRetrieve(result.feature);\n        } else {\n          input.dataset[\"mapboxSuccess\"] = \"true\";\n          const suggestion = (0,_mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.featureToSuggestion)(result.feature);\n          setFormAutofillValues(form, input, suggestion);\n        }\n      }\n      if (result.type === \"change\" && collectedResult.type !== \"cancel\") {\n        collectedResult = result;\n      }\n      if (result.type === \"cancel\") {\n        collectedResult = result;\n      }\n    }\n    return collectedResult;\n  });\n}\n\n// src/utils/confirmation.ts\nfunction createAddressElement(autofillValues, baseAddress) {\n  if (baseAddress) {\n    const element = createElementFromString(`\n        <span>\n          <span></span>\n          <br />\n          <span></span>\n        </span>\n      `);\n    const [firstLine, lastLine] = Array.from(element.querySelectorAll(\"span > span\"));\n    const parts = baseAddress.split(\",\");\n    firstLine.textContent = parts[0].trim();\n    lastLine.textContent = parts.slice(1).join(\",\").trim();\n    if (autofillValues[\"address-line2\"]) {\n      const span = document.createElement(\"span\");\n      span.textContent = autofillValues[\"address-line2\"];\n      element.insertBefore(span, lastLine);\n      element.insertBefore(document.createElement(\"br\"), lastLine);\n    }\n    if (autofillValues[\"address-line3\"]) {\n      const span = document.createElement(\"span\");\n      span.textContent = autofillValues[\"address-line3\"];\n      element.insertBefore(span, lastLine);\n      element.insertBefore(document.createElement(\"br\"), lastLine);\n    }\n    return element;\n  } else {\n    const firstLine = autofillValues[\"street-address\"] || autofillValues[\"address-line1\"] || \"\";\n    const line2 = autofillValues[\"address-line2\"];\n    const line3 = autofillValues[\"address-line3\"];\n    const lastLine = [\n      autofillValues[\"address-level4\"] || \"\",\n      autofillValues[\"address-level3\"] || \"\",\n      autofillValues[\"address-level2\"] || \"\",\n      `${autofillValues[\"address-level1\"] || \"\"} ${autofillValues[\"postal-code\"] || \"\"}`,\n      autofillValues.country || autofillValues[\"country-name\"] || \"\"\n    ].filter(Boolean).join(\", \");\n    const addressLines = [firstLine, line2, line3, lastLine].filter(Boolean);\n    const addressLinesHtml = addressLines.map((val) => `<span>${val}</span>`).join(\"<br />\");\n    const element = createElementFromString(`\n        <span>${addressLinesHtml}</span>\n      `);\n    return element;\n  }\n}\nfunction tryConfirmBrowserAutofill(input, event, confirmOnBrowserAutofill, accessToken) {\n  return __async(this, null, function* () {\n    if (!confirmOnBrowserAutofill)\n      return;\n    const parentForm = findParentForm(input);\n    const formElements = Object.values(findAddressAutofillInputs(parentForm, input));\n    if (!event.detail.elements.some((el) => formElements.includes(el))) {\n      return;\n    }\n    const structure = parseFormStructure(parentForm);\n    const structureRef = structure.find((s) => s.input === input);\n    const autofillInstanceSection = structureRef.section;\n    const browserAutofilledSections = Array.from(new Set(structure.filter((s) => event.detail.elements.includes(s.input)).map((s) => s.section)));\n    if (!browserAutofilledSections.includes(autofillInstanceSection)) {\n      return;\n    }\n    const optionsSections = typeof confirmOnBrowserAutofill === \"object\" && confirmOnBrowserAutofill.sections || [];\n    if (optionsSections.length && !optionsSections.some((section) => browserAutofilledSections.includes(section))) {\n      return;\n    }\n    let optionsArg = typeof confirmOnBrowserAutofill === \"object\" ? confirmOnBrowserAutofill : {};\n    optionsArg = __spreadProps(__spreadValues({}, optionsArg), {\n      accessToken,\n      sections: [autofillInstanceSection]\n    });\n    yield confirmAddress(parentForm, optionsArg);\n  });\n}\n\n// src/utils/contribute.ts\nvar CONTRIBUTE_API_BASE_URL = \"https://contribute-api.mapbox.com/v1\";\nvar CONTRIBUTE_API_STAGING_BASE_URL = \"https://contribute-api-staging.tilestream.net/v1\";\nvar EDIT_SUGGESTION_ENDPOINT = \"edit-suggestion\";\nfunction sendFeedback(accessToken, feedbackArgs) {\n  if (!config.feedbackEnabled)\n    return;\n  const hostname = window.location.hostname;\n  const BASE_URL = isLocalServer(hostname) || isMapboxDomain(hostname) ? CONTRIBUTE_API_STAGING_BASE_URL : CONTRIBUTE_API_BASE_URL;\n  const url = `${BASE_URL}/${EDIT_SUGGESTION_ENDPOINT}/address?access_token=${accessToken}`;\n  const { originalCoordinate, originalAddress, changes } = feedbackArgs;\n  const payload = {\n    action: \"update\",\n    reason: \"incorrect_address\",\n    location: {\n      longitude: originalCoordinate[0],\n      latitude: originalCoordinate[1]\n    },\n    userEmail: \"no-reply-autofill@mapbox.com\",\n    changes,\n    placeName: originalAddress\n  };\n  fetch(url, {\n    method: \"POST\",\n    headers: new Headers({\n      \"User-Agent\": `mapbox-search-js.${version}.${navigator.userAgent}`,\n      \"Content-Type\": \"application/json\"\n    }),\n    body: JSON.stringify(payload)\n  });\n}\n\n// src/components/MapboxAddressConfirmationFeature.ts\nvar TEMPLATE3 = createElementFromString(`\n<template>\n  <div class=\"MapboxAddressConfirmationFeature\">\n    <div class=\"Modal\" aria-modal=\"true\" role=\"dialog\">\n      <div class=\"ModalHeader\">\n        <svg viewBox=\"0 0 18 18\" class=\"Icon IconQuestion\"></svg>\n        <div class=\"ModalHeaderTitle\">Did you mean?</div>\n        <svg\n          viewBox=\"0 0 18 18\"\n          class=\"Icon IconClose\"\n          tabindex=\"0\"\n          role=\"button\"\n          title=\"Close\"\n          aria-label=\"Close\"\n          aria-expanded=\"true\"\n        ></svg>\n      </div>\n\n      <div class=\"ModalAddress ModalAddressApprove\"></div>\n            \n      <div class=\"ModalMap\">\n        <mapbox-address-minimap class=\"Minimap\"></mapbox-address-minimap>\n      </div>\n\n      <div\n        class=\"Button ButtonPrimary ButtonApprove\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"Yes\"\n      >\n        Yes\n      </div>\n      \n      <div\n        class=\"Button ButtonSecondary ButtonReject\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"No, use the address I provided\"\n      >\n        No, use the address I provided\n      </div>\n\n      <div class=\"ModalFooter\">\n          Your confirmation helps improve address data accuracy.\n      </div>\n    </div>\n  </div>\n</template>\n`);\nvar _binding3, _themeInternal3, _feature, _formValues, _handleClose, _modalID, _modalHeaderTitleID, _modalAddressApproveID;\nvar MapboxAddressConfirmationFeature = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _binding3, void 0);\n    __privateAdd(this, _themeInternal3, {});\n    this.minimap = false;\n    __privateAdd(this, _feature, void 0);\n    __privateAdd(this, _formValues, void 0);\n    this.update = (feature, autofillValues) => {\n      __privateSet(this, _feature, feature);\n      __privateSet(this, _formValues, autofillValues);\n      const { ModalMap, Minimap, ModalAddressApprove } = __privateGet(this, _binding3);\n      if (this.minimap) {\n        ModalMap.removeAttribute(\"aria-hidden\");\n        Minimap.accessToken = this.accessToken;\n        if (typeof this.minimap === \"object\") {\n          const { defaultMapStyle, theme, mapStyleMode, satelliteToggle } = this.minimap;\n          defaultMapStyle && (Minimap.defaultMapStyle = this.minimap.defaultMapStyle);\n          theme && (Minimap.theme = this.minimap.theme);\n          mapStyleMode && (Minimap.mapStyleMode = mapStyleMode);\n          satelliteToggle !== void 0 && (Minimap.satelliteToggle = satelliteToggle);\n        }\n        Minimap.feature = feature;\n      } else {\n        ModalMap.setAttribute(\"aria-hidden\", \"true\");\n      }\n      const approveAddress = feature.properties.place_name || feature.properties.full_address || feature.properties.address;\n      ModalAddressApprove.innerHTML = \"\";\n      ModalAddressApprove.appendChild(createAddressElement(autofillValues, approveAddress));\n    };\n    __privateAdd(this, _handleClose, () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"cancel\"));\n    });\n    this.approve = () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"change\"));\n    };\n    this.reject = () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"nochange\"));\n      sendFeedback(this.accessToken, {\n        originalCoordinate: __privateGet(this, _feature).geometry.coordinates,\n        originalAddress: __privateGet(this, _feature).properties.full_address,\n        changes: {\n          address: getAutofillSearchText(__privateGet(this, _formValues))\n        }\n      });\n    };\n    __privateAdd(this, _modalID, randomValidID());\n    __privateAdd(this, _modalHeaderTitleID, randomValidID());\n    __privateAdd(this, _modalAddressApproveID, randomValidID());\n  }\n  get template() {\n    return TEMPLATE3;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxAddressConfirmationFeature\", this.theme);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal3);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal3, theme);\n    if (!__privateGet(this, _binding3) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxAddressConfirmationFeature\", theme));\n    const { IconQuestion, IconClose } = __privateGet(this, _binding3);\n    IconQuestion.innerHTML = getIcon(\"question\", theme);\n    IconClose.innerHTML = getIcon(\"close\", theme);\n  }\n  set footer(val) {\n    if (val === void 0)\n      return;\n    const footerEl = this.querySelector(\".ModalFooter\");\n    if (typeof val === \"string\") {\n      footerEl.textContent = val;\n      footerEl.removeAttribute(\"aria-hidden\");\n    } else if (!val) {\n      footerEl.setAttribute(\"aria-hidden\", \"true\");\n    } else {\n      footerEl.removeAttribute(\"aria-hidden\");\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding3, bindElements(this, {\n      MapboxAddressConfirmationFeature: \".MapboxAddressConfirmationFeature\",\n      Modal: \".Modal\",\n      ModalHeaderTitle: \".ModalHeaderTitle\",\n      ModalMap: \".ModalMap\",\n      Minimap: \".Minimap\",\n      IconQuestion: \".IconQuestion\",\n      IconClose: \".IconClose\",\n      ButtonApprove: \".ButtonApprove\",\n      ButtonReject: \".ButtonReject\",\n      ModalAddressApprove: \".ModalAddressApprove\"\n    }));\n    const {\n      Modal,\n      ModalHeaderTitle,\n      IconClose,\n      ButtonApprove,\n      ButtonReject,\n      ModalAddressApprove\n    } = __privateGet(this, _binding3);\n    Modal.setAttribute(\"aria-labelledby\", __privateGet(this, _modalHeaderTitleID));\n    Modal.setAttribute(\"aria-describedby\", __privateGet(this, _modalAddressApproveID));\n    IconClose.setAttribute(\"aria-controls\", __privateGet(this, _modalID));\n    Modal.id = __privateGet(this, _modalID);\n    ModalHeaderTitle.id = __privateGet(this, _modalHeaderTitleID);\n    ModalAddressApprove.id = __privateGet(this, _modalAddressApproveID);\n    const buttons = Array.from(this.querySelectorAll('[role=\"button\"]'));\n    for (const button of buttons) {\n      button.addEventListener(\"keydown\", ariaButtonKeyDown);\n    }\n    IconClose.addEventListener(\"click\", __privateGet(this, _handleClose));\n    ButtonApprove.addEventListener(\"click\", this.approve);\n    ButtonReject.addEventListener(\"click\", this.reject);\n    const theme = this.theme;\n    if (theme) {\n      const { IconQuestion, IconClose: IconClose2 } = __privateGet(this, _binding3);\n      IconQuestion.innerHTML = getIcon(\"question\", theme);\n      IconClose2.innerHTML = getIcon(\"close\", theme);\n    }\n  }\n  disconnectedCallback() {\n    const { IconClose, ButtonApprove } = __privateGet(this, _binding3);\n    IconClose.removeEventListener(\"click\", __privateGet(this, _handleClose));\n    ButtonApprove.removeEventListener(\"click\", this.approve);\n  }\n};\n_binding3 = new WeakMap();\n_themeInternal3 = new WeakMap();\n_feature = new WeakMap();\n_formValues = new WeakMap();\n_handleClose = new WeakMap();\n_modalID = new WeakMap();\n_modalHeaderTitleID = new WeakMap();\n_modalAddressApproveID = new WeakMap();\nwindow.MapboxAddressConfirmationFeature = MapboxAddressConfirmationFeature;\nif (!window.customElements.get(\"mapbox-address-confirmation-feature\")) {\n  customElements.define(\"mapbox-address-confirmation-feature\", MapboxAddressConfirmationFeature);\n}\n\n// src/components/MapboxAddressConfirmationNoFeature.ts\nvar TEMPLATE4 = createElementFromString(`\n<template>\n  <div class=\"MapboxAddressConfirmationNoFeature\">\n    <div class=\"Modal\" aria-modal=\"true\" role=\"dialog\">\n      <div class=\"ModalHeader\">\n        <svg viewBox=\"0 0 18 18\" class=\"Icon IconQuestion\"></svg>\n        <div class=\"ModalHeaderTitle\">Confirm address</div>\n        <svg\n          viewBox=\"0 0 18 18\"\n          class=\"Icon IconClose\"\n          tabindex=\"0\"\n          role=\"button\"\n          title=\"Close\"\n          aria-label=\"Close\"\n          aria-expanded=\"true\"\n        ></svg>\n      </div>\n      <div class=\"ModalDescription\">\n        We couldn't verify this address. Please check that your information is correct before continuing.\n      </div>\n      <br />\n      <div class=\"ModalSubheader\">\n        You entered\n      </div>\n      <div class=\"ModalAddress\"></div>\n      <div\n        class=\"Button ButtonPrimary\"\n        tabindex=\"0\"\n        role=\"button\"\n        aria-label=\"Use the address I provided\"\n      >\n        Use the address I provided\n      </div>\n    </div>\n  </div>\n</template>\n`);\nvar _binding4, _themeInternal4, _handleClose2, _modalID2, _modalHeaderTitleID2, _modalAddressID;\nvar MapboxAddressConfirmationNoFeature = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _binding4, void 0);\n    __privateAdd(this, _themeInternal4, {});\n    this.update = (autofillValues) => {\n      const { ModalAddress } = __privateGet(this, _binding4);\n      ModalAddress.innerHTML = \"\";\n      ModalAddress.appendChild(createAddressElement(autofillValues));\n    };\n    __privateAdd(this, _handleClose2, () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"cancel\"));\n    });\n    this.reject = () => {\n      this.dispatchEvent(new MapboxHTMLEvent(\"result\", \"nochange\"));\n    };\n    __privateAdd(this, _modalID2, randomValidID());\n    __privateAdd(this, _modalHeaderTitleID2, randomValidID());\n    __privateAdd(this, _modalAddressID, randomValidID());\n  }\n  get template() {\n    return TEMPLATE4;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxAddressConfirmationNoFeature\", this.theme);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal4);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal4, theme);\n    if (!__privateGet(this, _binding4) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxAddressConfirmationNoFeature\", theme));\n    const { IconQuestion, IconClose } = __privateGet(this, _binding4);\n    IconQuestion.innerHTML = getIcon(\"question\", theme);\n    IconClose.innerHTML = getIcon(\"close\", theme);\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding4, bindElements(this, {\n      Modal: \".Modal\",\n      ModalHeaderTitle: \".ModalHeaderTitle\",\n      IconQuestion: \".IconQuestion\",\n      IconClose: \".IconClose\",\n      ModalAddress: \".ModalAddress\",\n      ButtonReject: \".Button\"\n    }));\n    const { Modal, ModalHeaderTitle, IconClose, ModalAddress, ButtonReject } = __privateGet(this, _binding4);\n    Modal.setAttribute(\"aria-labelledby\", __privateGet(this, _modalHeaderTitleID2));\n    Modal.setAttribute(\"aria-describedby\", __privateGet(this, _modalAddressID));\n    IconClose.setAttribute(\"aria-controls\", __privateGet(this, _modalID2));\n    Modal.id = __privateGet(this, _modalID2);\n    ModalHeaderTitle.id = __privateGet(this, _modalHeaderTitleID2);\n    ModalAddress.id = __privateGet(this, _modalAddressID);\n    const buttons = Array.from(this.querySelectorAll('[role=\"button\"]'));\n    for (const button of buttons) {\n      button.addEventListener(\"keydown\", ariaButtonKeyDown);\n    }\n    IconClose.addEventListener(\"click\", __privateGet(this, _handleClose2));\n    ButtonReject.addEventListener(\"click\", this.reject);\n    const theme = this.theme;\n    if (theme) {\n      const { IconQuestion, IconClose: IconClose2 } = __privateGet(this, _binding4);\n      IconQuestion.innerHTML = getIcon(\"question\", theme);\n      IconClose2.innerHTML = getIcon(\"close\", theme);\n    }\n  }\n  disconnectedCallback() {\n    const { IconClose, ButtonReject } = __privateGet(this, _binding4);\n    IconClose.removeEventListener(\"click\", __privateGet(this, _handleClose2));\n    ButtonReject.removeEventListener(\"click\", this.reject);\n  }\n};\n_binding4 = new WeakMap();\n_themeInternal4 = new WeakMap();\n_handleClose2 = new WeakMap();\n_modalID2 = new WeakMap();\n_modalHeaderTitleID2 = new WeakMap();\n_modalAddressID = new WeakMap();\nwindow.MapboxAddressConfirmationNoFeature = MapboxAddressConfirmationNoFeature;\nif (!window.customElements.get(\"mapbox-address-confirmation-no-feature\")) {\n  customElements.define(\"mapbox-address-confirmation-no-feature\", MapboxAddressConfirmationNoFeature);\n}\n\n// src/components/MapboxAddressAutofill.ts\n\n\n// src/utils/detect_browser_autofill.ts\n\n\n// src/utils/detect_browser_autofill.css\nvar detect_browser_autofill_default = 'input:-webkit-autofill,select:-webkit-autofill,textarea:-webkit-autofill{animation-name:onbrowserautofillstart}input:not(:-webkit-autofill),select:not(:-webkit-autofill),textarea:not(:-webkit-autofill){animation-name:onbrowserautofillcancel}@keyframes onbrowserautofillstart{0%{animation-name:\"onbrowserautofillstart\"}to{animation-name:\"onbrowserautofillstart\"}}@keyframes onbrowserautofillcancel{0%{animation-name:\"onbrowserautofillcancel\"}to{animation-name:\"onbrowserautofillcancel\"}}';\n\n// src/utils/detect_browser_autofill.ts\nvar ATTR_NAME = \"browser-autofilled\";\nvar AUTOFILLED_ELEMENTS = [];\nfunction dispatchBrowserAutofillEvent() {\n  window.dispatchEvent(new window.CustomEvent(\"browserautofill\", {\n    bubbles: true,\n    cancelable: true,\n    detail: { elements: AUTOFILLED_ELEMENTS }\n  }));\n  AUTOFILLED_ELEMENTS = [];\n}\nvar debouncedAutofill = (0,_mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.debounce)(dispatchBrowserAutofillEvent, 5);\nfunction browserAutofill(element) {\n  if (element.hasAttribute(ATTR_NAME))\n    return;\n  element.setAttribute(ATTR_NAME, \"\");\n  AUTOFILLED_ELEMENTS.push(element);\n  debouncedAutofill();\n}\nfunction cancelBrowserAutofill(element) {\n  if (!element.hasAttribute(ATTR_NAME))\n    return;\n  element.removeAttribute(ATTR_NAME);\n}\nfunction onAnimationStart(event) {\n  event.animationName === \"onbrowserautofillstart\" ? browserAutofill(event.target) : cancelBrowserAutofill(event.target);\n}\nfunction onInput(event) {\n  const targetEl = event.target;\n  targetEl.nodeName.toLowerCase() !== \"select\" && !event.simulated && (event.inputType === \"insertReplacementText\" || !(\"data\" in event)) ? browserAutofill(targetEl) : cancelBrowserAutofill(targetEl);\n}\nfunction initDetectBrowserAutofill() {\n  if (config.detectBrowserAutofillEnabled) {\n    return;\n  } else {\n    config.detectBrowserAutofillEnabled = true;\n  }\n  addDocumentStyle(detect_browser_autofill_default);\n  document.addEventListener(\"animationstart\", onAnimationStart, true);\n  document.addEventListener(\"input\", onInput, true);\n}\n\n// src/components/MapboxAddressAutofill.ts\nvar _autofill, _session, _input, _listbox, _handleSuggest2, _handleSuggestError2, _handleRetrieve, _handleObserve, _observer, _handleBrowserAutofill;\nvar MapboxAddressAutofill = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _autofill, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.MapboxAutofill());\n    __privateAdd(this, _session, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.SearchSession(__privateGet(this, _autofill)));\n    __privateAdd(this, _input, void 0);\n    __privateAdd(this, _listbox, new MapboxSearchListbox());\n    this.confirmOnBrowserAutofill = false;\n    __privateAdd(this, _handleSuggest2, (e) => {\n      this.dispatchEvent(new MapboxHTMLEvent(e.type, e.detail));\n    });\n    __privateAdd(this, _handleSuggestError2, (e) => {\n      this.dispatchEvent(new MapboxHTMLEvent(e.type, e.detail));\n    });\n    __privateAdd(this, _handleRetrieve, (e) => {\n      this.dispatchEvent(new MapboxHTMLEvent(e.type, e.detail));\n      if (!__privateGet(this, _input)) {\n        return;\n      }\n      const featureCollection = e.detail;\n      if (!featureCollection || !featureCollection.features || !featureCollection.features.length) {\n        return;\n      }\n      fillFormWithFeature(featureCollection.features[0], __privateGet(this, _input));\n    });\n    __privateAdd(this, _handleObserve, () => {\n      var _a;\n      try {\n        const input = (_a = this.querySelector(\"input\")) != null ? _a : null;\n        __privateSet(this, _input, input);\n        __privateGet(this, _listbox).input = input;\n      } catch (e) {\n        __privateSet(this, _input, null);\n        __privateGet(this, _listbox).input = null;\n        console.error(e.message || e);\n      }\n    });\n    __privateAdd(this, _observer, new MutationObserver(__privateGet(this, _handleObserve)));\n    __privateAdd(this, _handleBrowserAutofill, (e) => {\n      __privateGet(this, _listbox).blur();\n      tryConfirmBrowserAutofill(__privateGet(this, _input), e, this.confirmOnBrowserAutofill, this.accessToken);\n    });\n  }\n  get accessToken() {\n    return __privateGet(this, _autofill).accessToken;\n  }\n  set accessToken(newToken) {\n    __privateGet(this, _autofill).accessToken = newToken;\n  }\n  get options() {\n    return __privateGet(this, _listbox).options;\n  }\n  set options(newOptions) {\n    __privateGet(this, _listbox).options = newOptions;\n  }\n  get theme() {\n    return __privateGet(this, _listbox).theme;\n  }\n  set theme(theme) {\n    __privateGet(this, _listbox).theme = theme;\n  }\n  get popoverOptions() {\n    return __privateGet(this, _listbox).popoverOptions;\n  }\n  set popoverOptions(newOptions) {\n    __privateGet(this, _listbox).popoverOptions = newOptions;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    config.autofillSessionEnabled = true;\n    __privateGet(this, _listbox).session = __privateGet(this, _session);\n    __privateGet(this, _listbox).session.sessionToken = config.autofillSessionToken;\n    __privateGet(this, _listbox).addEventListener(\"suggest\", __privateGet(this, _handleSuggest2));\n    __privateGet(this, _listbox).addEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError2));\n    __privateGet(this, _listbox).addEventListener(\"retrieve\", __privateGet(this, _handleRetrieve));\n    document.body.appendChild(__privateGet(this, _listbox));\n    __privateGet(this, _observer).observe(this, {\n      subtree: true,\n      childList: true\n    });\n    __privateGet(this, _handleObserve).call(this);\n    initDetectBrowserAutofill();\n    window.addEventListener(\"browserautofill\", __privateGet(this, _handleBrowserAutofill));\n  }\n  disconnectedCallback() {\n    __privateGet(this, _listbox).remove();\n    __privateGet(this, _listbox).removeEventListener(\"suggest\", __privateGet(this, _handleSuggest2));\n    __privateGet(this, _listbox).removeEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError2));\n    __privateGet(this, _listbox).removeEventListener(\"retrieve\", __privateGet(this, _handleRetrieve));\n    __privateGet(this, _observer).disconnect();\n    window.removeEventListener(\"browserautofill\", __privateGet(this, _handleBrowserAutofill));\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"access-token\") {\n      __privateGet(this, _autofill).accessToken = newValue;\n      return;\n    }\n    if (name === \"theme\") {\n      this.theme = tryParseJSON(newValue);\n      return;\n    }\n    if (name === \"popover-options\") {\n      this.popoverOptions = tryParseJSON(newValue);\n      return;\n    }\n    const optionName = name.split(\"-\").join(\"_\");\n    if (!newValue) {\n      delete __privateGet(this, _listbox).options[optionName];\n    }\n    __privateGet(this, _listbox).options[optionName] = newValue;\n  }\n  focus() {\n    __privateGet(this, _listbox).focus();\n  }\n};\n_autofill = new WeakMap();\n_session = new WeakMap();\n_input = new WeakMap();\n_listbox = new WeakMap();\n_handleSuggest2 = new WeakMap();\n_handleSuggestError2 = new WeakMap();\n_handleRetrieve = new WeakMap();\n_handleObserve = new WeakMap();\n_observer = new WeakMap();\n_handleBrowserAutofill = new WeakMap();\nMapboxAddressAutofill.observedAttributes = [\n  \"access-token\",\n  \"theme\",\n  \"popover-options\",\n  \"css-text\",\n  \"language\",\n  \"country\",\n  \"bbox\",\n  \"limit\",\n  \"proximity\"\n];\nwindow.MapboxAddressAutofill = MapboxAddressAutofill;\nif (!window.customElements.get(\"mapbox-address-autofill\")) {\n  customElements.define(\"mapbox-address-autofill\", MapboxAddressAutofill);\n}\n\n// src/components/MapboxSearchBox.ts\n\nvar MAX_ZOOM = 9;\nvar TEMPLATE5 = createElementFromString(`\n<template>\n  <input class=\"Input\" type=\"text\" />\n</template>\n`);\nvar _search, _session2, _map, _input2, _listbox2, _handleSuggest3, _handleSuggestError3, _handleRetrieve2, _handleInput2, _handleMoveEnd;\nvar MapboxSearchBox = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _search, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.MapboxSearch({}));\n    __privateAdd(this, _session2, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.SearchSession(__privateGet(this, _search)));\n    __privateAdd(this, _map, null);\n    __privateAdd(this, _input2, void 0);\n    __privateAdd(this, _listbox2, new MapboxSearchListbox());\n    __privateAdd(this, _handleSuggest3, (e) => {\n      this.dispatchEvent(new MapboxHTMLEvent(e.type, e.detail));\n    });\n    __privateAdd(this, _handleSuggestError3, (e) => {\n      this.dispatchEvent(new MapboxHTMLEvent(e.type, e.detail));\n    });\n    __privateAdd(this, _handleRetrieve2, (e) => __async(this, null, function* () {\n      var _a;\n      this.dispatchEvent(new MapboxHTMLEvent(e.type, e.detail));\n      const featureCollection = e.detail;\n      if (!featureCollection || !featureCollection.features.length) {\n        return;\n      }\n      const suggestion = (0,_mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.featureToSuggestion)(featureCollection.features[0]);\n      __privateGet(this, _input2).value = suggestion.feature_name;\n      const map = __privateGet(this, _map);\n      if (!map) {\n        return;\n      }\n      const feature = featureCollection.features[0];\n      if (!feature) {\n        return;\n      }\n      const placeType = (_a = feature.properties.place_type) == null ? void 0 : _a[0];\n      const bounds = feature.bbox;\n      if (bounds) {\n        map.flyTo(bboxViewport(map, _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.LngLatBounds.convert(bounds).toFlatArray()));\n      } else {\n        const center = feature.geometry.coordinates;\n        const zoom = getMaxZoom(placeType);\n        map.flyTo({\n          center,\n          zoom,\n          speed: FLY_TO_SPEED\n        });\n      }\n    }));\n    __privateAdd(this, _handleInput2, (e) => {\n      const event = new MapboxHTMLEvent(\"input\");\n      Object.assign(event, __spreadValues({}, e));\n      this.dispatchEvent(event);\n    });\n    __privateAdd(this, _handleMoveEnd, () => {\n      const map = __privateGet(this, _map);\n      const options = __spreadValues({}, __privateGet(this, _listbox2).options);\n      if (map.getZoom() <= MAX_ZOOM) {\n        delete options.proximity;\n        __privateGet(this, _listbox2).options = options;\n        return;\n      }\n      const center = map.getCenter();\n      __privateGet(this, _listbox2).options = __spreadProps(__spreadValues({}, options), {\n        proximity: center\n      });\n    });\n  }\n  get accessToken() {\n    return __privateGet(this, _search).accessToken;\n  }\n  set accessToken(newToken) {\n    __privateGet(this, _search).accessToken = newToken;\n  }\n  get value() {\n    return __privateGet(this, _input2).value;\n  }\n  set value(newValue) {\n    __privateGet(this, _input2).value = newValue;\n  }\n  get template() {\n    return TEMPLATE5;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".Input\", __privateGet(this, _listbox2).theme);\n  }\n  get options() {\n    return __privateGet(this, _listbox2).options;\n  }\n  set options(newOptions) {\n    __privateGet(this, _listbox2).options = newOptions;\n  }\n  get theme() {\n    return __privateGet(this, _listbox2).theme;\n  }\n  set theme(theme) {\n    __privateGet(this, _listbox2).theme = theme;\n    const input = __privateGet(this, _input2);\n    if (!input) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".Input\", theme));\n    __privateGet(this, _listbox2).updatePopover();\n  }\n  get popoverOptions() {\n    return __privateGet(this, _listbox2).popoverOptions;\n  }\n  set popoverOptions(newOptions) {\n    __privateGet(this, _listbox2).popoverOptions = newOptions;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    const input = this.querySelector(\".Input\");\n    input.addEventListener(\"input\", __privateGet(this, _handleInput2));\n    __privateSet(this, _input2, input);\n    __privateGet(this, _listbox2).session = __privateGet(this, _session2);\n    __privateGet(this, _listbox2).input = input;\n    __privateGet(this, _listbox2).addEventListener(\"suggest\", __privateGet(this, _handleSuggest3));\n    __privateGet(this, _listbox2).addEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError3));\n    __privateGet(this, _listbox2).addEventListener(\"retrieve\", __privateGet(this, _handleRetrieve2));\n    document.body.appendChild(__privateGet(this, _listbox2));\n  }\n  disconnectedCallback() {\n    __privateGet(this, _listbox2).remove();\n    __privateGet(this, _listbox2).input = null;\n    __privateGet(this, _listbox2).removeEventListener(\"suggest\", __privateGet(this, _handleSuggest3));\n    __privateGet(this, _listbox2).removeEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError3));\n    __privateGet(this, _listbox2).removeEventListener(\"retrieve\", __privateGet(this, _handleRetrieve2));\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"access-token\") {\n      __privateGet(this, _search).accessToken = newValue;\n      return;\n    }\n    if (name === \"theme\") {\n      this.theme = tryParseJSON(newValue);\n      return;\n    }\n    if (name === \"popover-options\") {\n      this.popoverOptions = tryParseJSON(newValue);\n      return;\n    }\n    const optionName = name.split(\"-\").join(\"_\");\n    if (!newValue) {\n      delete __privateGet(this, _listbox2).options[optionName];\n    }\n    __privateGet(this, _listbox2).options[optionName] = newValue;\n  }\n  focus() {\n    __privateGet(this, _listbox2).focus();\n  }\n  bindMap(map) {\n    if (__privateGet(this, _map)) {\n      __privateGet(this, _map).off(\"moveend\", __privateGet(this, _handleMoveEnd));\n    }\n    if (map) {\n      map.on(\"moveend\", __privateGet(this, _handleMoveEnd));\n    }\n    __privateSet(this, _map, map);\n  }\n  unbindMap() {\n    this.bindMap(null);\n  }\n  onAdd(map) {\n    this.bindMap(map);\n    this.remove();\n    const container = document.createElement(\"div\");\n    container.className = \"mapboxgl-ctrl\";\n    container.style.width = \"300px\";\n    container.appendChild(this);\n    return container;\n  }\n  onRemove() {\n    this.remove();\n    this.unbindMap();\n  }\n  getDefaultPosition() {\n    return \"top-right\";\n  }\n};\n_search = new WeakMap();\n_session2 = new WeakMap();\n_map = new WeakMap();\n_input2 = new WeakMap();\n_listbox2 = new WeakMap();\n_handleSuggest3 = new WeakMap();\n_handleSuggestError3 = new WeakMap();\n_handleRetrieve2 = new WeakMap();\n_handleInput2 = new WeakMap();\n_handleMoveEnd = new WeakMap();\nMapboxSearchBox.observedAttributes = [\n  \"access-token\",\n  \"theme\",\n  \"popover-options\",\n  \"language\",\n  \"country\",\n  \"bbox\",\n  \"limit\",\n  \"navigation-profile\",\n  \"origin\",\n  \"proximity\",\n  \"eta-type\",\n  \"types\"\n];\nwindow.MapboxSearchBox = MapboxSearchBox;\nif (!window.customElements.get(\"mapbox-search-box\")) {\n  customElements.define(\"mapbox-search-box\", MapboxSearchBox);\n}\n\n// src/components/MapboxAddressMinimap.ts\n\n\n// src/utils/minimap.ts\n\nvar merc = new (_mapbox_sphericalmercator__WEBPACK_IMPORTED_MODULE_4___default())({ size: 512, antimeridian: true });\nvar MAX_IMAGE_DIM = 1280;\nfunction getAnchorOffset(marker, anchor) {\n  const { width, height } = getElementSize(marker, true);\n  switch (anchor) {\n    case \"center\":\n      return [0, 0];\n    case \"top\":\n      return [0, height / 2];\n    case \"bottom\":\n      return [0, -1 * height / 2];\n    case \"left\":\n      return [width / 2, 0];\n    case \"right\":\n      return [-1 * width / 2, 0];\n    case \"top-left\":\n      return [width / 2, height / 2];\n    case \"top-right\":\n      return [-1 * width / 2, height / 2];\n    case \"bottom-left\":\n      return [width / 2, -1 * height / 2];\n    case \"bottom-right\":\n      return [-1 * width / 2, -1 * height / 2];\n  }\n}\nvar _anchor, _handleAnchorResize, _markerTransform, _isActive, _originalCoordinate, _onPointerDownMarker, _onPointerUpMarker, _onPointerMoveMarker, _onPointerDownImage, _onPointerUpImage, _onPointerMoveImage, _updatePointerPosition, _updateMarkerTransform, _updateMarkerCorrection;\nvar MarkerController = class {\n  constructor(imageContainer, imageElement, marker, keepMarkerCentered, zoom, anchor) {\n    __privateAdd(this, _anchor, void 0);\n    __privateAdd(this, _handleAnchorResize, () => {\n      [this.anchorOffsetX, this.anchorOffsetY] = getAnchorOffset(this.markerElement, this.anchor);\n      this.markerTransform = {\n        anchorX: this.anchorOffsetX,\n        anchorY: this.anchorOffsetY\n      };\n    });\n    __privateAdd(this, _markerTransform, {\n      anchorX: 0,\n      anchorY: 0,\n      globalX: 0,\n      globalY: 0,\n      correctionX: 0,\n      correctionY: 0\n    });\n    __privateAdd(this, _isActive, false);\n    __privateAdd(this, _originalCoordinate, void 0);\n    __privateAdd(this, _onPointerDownMarker, (m) => {\n      if (!this.isActive)\n        return;\n      m.preventDefault();\n      m.stopPropagation();\n      __privateGet(this, _updatePointerPosition).call(this, m);\n      window.addEventListener(\"pointermove\", __privateGet(this, _onPointerMoveMarker));\n      window.addEventListener(\"pointerup\", __privateGet(this, _onPointerUpMarker));\n    });\n    __privateAdd(this, _onPointerUpMarker, () => {\n      window.removeEventListener(\"pointermove\", __privateGet(this, _onPointerMoveMarker));\n      window.removeEventListener(\"pointerup\", __privateGet(this, _onPointerUpMarker));\n    });\n    __privateAdd(this, _onPointerMoveMarker, (m) => {\n      m.preventDefault();\n      m.stopPropagation();\n      const diffX = this.curPointerXPos - m.pageX;\n      const diffY = this.curPointerYPos - m.pageY;\n      this.markerDeltaX += diffX;\n      this.markerDeltaY -= diffY;\n      this.markerDeltaX = Math.max(Math.min(this.imgElement.width / 2, this.markerDeltaX), this.imgElement.width / 2 * -1);\n      this.markerDeltaY = Math.max(Math.min(this.imgElement.height / 2, this.markerDeltaY), this.imgElement.height / 2 * -1);\n      const imageOffsetX = this.imgCenterPx[0] - this.imgCenterAdjustedPx[0];\n      const imageOffsetY = this.imgCenterPx[1] - this.imgCenterAdjustedPx[1];\n      const deltaX = this.markerDeltaX - imageOffsetX;\n      const deltaY = this.markerDeltaY + imageOffsetY;\n      this.markerTransform = { globalX: deltaX, globalY: deltaY };\n      __privateGet(this, _updatePointerPosition).call(this, m);\n    });\n    __privateAdd(this, _onPointerDownImage, (m) => {\n      if (!this.isActive)\n        return;\n      m.preventDefault();\n      m.stopPropagation();\n      __privateGet(this, _updatePointerPosition).call(this, m);\n      window.addEventListener(\"pointermove\", __privateGet(this, _onPointerMoveImage));\n      window.addEventListener(\"pointerup\", __privateGet(this, _onPointerUpImage));\n    });\n    __privateAdd(this, _onPointerUpImage, () => {\n      window.removeEventListener(\"pointermove\", __privateGet(this, _onPointerMoveImage));\n      window.removeEventListener(\"pointerup\", __privateGet(this, _onPointerUpImage));\n    });\n    __privateAdd(this, _onPointerMoveImage, (m) => {\n      m.preventDefault();\n      let top = Math.round(this.imgContainerElement.scrollTop + (this.curPointerYPos - m.pageY));\n      top = Math.max(Math.min(this.imgElement.height - this.imgContainerElement.clientHeight, top), 0);\n      let left = Math.round(this.imgContainerElement.scrollLeft + (this.curPointerXPos - m.pageX));\n      left = Math.max(Math.min(this.imgElement.width - this.imgContainerElement.clientWidth, left), 0);\n      this.imgContainerElement.scrollTop = top;\n      this.imgContainerElement.scrollLeft = left;\n      const diffX = Math.round(left - (this.imgElement.width - this.imgContainerElement.clientWidth) / 2);\n      const diffY = Math.round((this.imgElement.height - this.imgContainerElement.clientHeight) / 2 - top);\n      this.imgCenterAdjustedPx = [\n        this.imgCenterPx[0] + diffX,\n        this.imgCenterPx[1] - diffY\n      ];\n      if (!this.keepMarkerCentered) {\n        const deltaX = this.markerDeltaX + diffX;\n        const deltaY = this.markerDeltaY + diffY;\n        this.markerTransform = { globalX: deltaX, globalY: deltaY };\n      }\n      __privateGet(this, _updateMarkerCorrection).call(this, left, top);\n      __privateGet(this, _updatePointerPosition).call(this, m);\n    });\n    __privateAdd(this, _updatePointerPosition, (m) => {\n      this.curPointerXPos = m.pageX;\n      this.curPointerYPos = m.pageY;\n    });\n    __privateAdd(this, _updateMarkerTransform, () => {\n      const { anchorX, anchorY, globalX, globalY, correctionX, correctionY } = __privateGet(this, _markerTransform);\n      const transformX = anchorX - globalX + correctionX;\n      const transformY = anchorY + globalY + correctionY;\n      this.markerElement.style.transform = `translate(calc(-50% + ${transformX}px), calc(-50% + ${transformY}px))`;\n    });\n    this.reCenter = () => {\n      const top = (this.imgElement.height - this.imgContainerElement.clientHeight) / 2;\n      const left = (this.imgElement.width - this.imgContainerElement.clientWidth) / 2;\n      this.imgContainerElement.scrollTop = top;\n      this.imgContainerElement.scrollLeft = left;\n      this.imgCenterAdjustedPx = this.imgCenterPx;\n      this.markerDeltaX = this.markerDeltaY = 0;\n      this.markerTransform = {\n        globalX: 0,\n        globalY: 0,\n        correctionX: 0,\n        correctionY: 0\n      };\n    };\n    this.handleMinimapResize = () => {\n      if (!this.imgElement.height || !this.imgElement.width)\n        return;\n      const centerOffsetX = this.imgCenterOffset.x;\n      const centerOffsetY = this.imgCenterOffset.y;\n      const left = this.imgElement.width / 2 - centerOffsetX - this.imgContainerElement.clientWidth / 2;\n      const top = this.imgElement.height / 2 - centerOffsetY - this.imgContainerElement.clientHeight / 2;\n      this.imgContainerElement.scrollLeft = left;\n      this.imgContainerElement.scrollTop = top;\n      __privateGet(this, _updateMarkerCorrection).call(this, left, top);\n    };\n    __privateAdd(this, _updateMarkerCorrection, (scrollLeft, scrollTop) => {\n      const centerOffsetX = this.imgCenterOffset.x;\n      const centerOffsetY = this.imgCenterOffset.y;\n      const { correctionX, correctionY } = this.markerTransform;\n      const corrections = {};\n      if (scrollLeft / 2 < centerOffsetX * -1) {\n        const markerTranslateX = centerOffsetX * -1 - scrollLeft / 2;\n        corrections.correctionX = markerTranslateX * 2;\n      } else if (scrollLeft < 0) {\n        corrections.correctionX = scrollLeft;\n      } else if (correctionX !== 0) {\n        corrections.correctionX = 0;\n      }\n      if (scrollTop / 2 < centerOffsetY * -1) {\n        const markerTranslateY = centerOffsetY * -1 - scrollTop / 2;\n        corrections.correctionY = markerTranslateY * 2;\n      } else if (scrollTop < 0) {\n        corrections.correctionY = scrollTop;\n      } else if (correctionY !== 0) {\n        corrections.correctionY = 0;\n      }\n      this.markerTransform = corrections;\n    });\n    this.markerElement = marker;\n    this.imgContainerElement = imageContainer;\n    this.imgElement = imageElement;\n    this.keepMarkerCentered = keepMarkerCentered;\n    this.zoom = zoom;\n    this.anchor = anchor;\n    this.curPointerXPos = 0;\n    this.curPointerYPos = 0;\n    this.markerDeltaX = 0;\n    this.markerDeltaY = 0;\n    this.imgContainerElement.addEventListener(\"pointerdown\", __privateGet(this, _onPointerDownImage));\n    if (!this.keepMarkerCentered) {\n      this.markerElement.addEventListener(\"pointerdown\", __privateGet(this, _onPointerDownMarker));\n    }\n    const resizeObserver = new ResizeObserver(__privateGet(this, _handleAnchorResize));\n    resizeObserver.observe(this.markerElement);\n  }\n  get anchor() {\n    return __privateGet(this, _anchor);\n  }\n  set anchor(newAnchor) {\n    __privateSet(this, _anchor, newAnchor);\n    [this.anchorOffsetX, this.anchorOffsetY] = getAnchorOffset(this.markerElement, newAnchor);\n    this.markerTransform = {\n      anchorX: this.anchorOffsetX,\n      anchorY: this.anchorOffsetY\n    };\n  }\n  get markerTransform() {\n    return __privateGet(this, _markerTransform);\n  }\n  set markerTransform(val) {\n    __privateSet(this, _markerTransform, __spreadValues(__spreadValues({}, __privateGet(this, _markerTransform)), val));\n    __privateGet(this, _updateMarkerTransform).call(this);\n  }\n  get isActive() {\n    return __privateGet(this, _isActive);\n  }\n  set isActive(val) {\n    this.imgContainerElement.style.touchAction = val ? \"none\" : \"\";\n    __privateSet(this, _isActive, val);\n  }\n  get coordinate() {\n    const adjustedPx = this.keepMarkerCentered ? this.imgCenterAdjustedPx : [\n      this.imgCenterPx[0] - this.markerDeltaX,\n      this.imgCenterPx[1] + this.markerDeltaY\n    ];\n    if (deepEquals(adjustedPx, this.imgCenterPx)) {\n      return __privateGet(this, _originalCoordinate);\n    } else {\n      const lngLat = merc.ll(adjustedPx, this.zoom);\n      return [round(lngLat[0], 6), round(lngLat[1], 6)];\n    }\n  }\n  set coordinate(lngLat) {\n    __privateSet(this, _originalCoordinate, lngLat);\n    this.imgCenterPx = this.imgCenterAdjustedPx = merc.px(lngLat, this.zoom);\n  }\n  get imgCenterOffset() {\n    return {\n      x: this.imgCenterPx[0] - this.imgCenterAdjustedPx[0],\n      y: this.imgCenterPx[1] - this.imgCenterAdjustedPx[1]\n    };\n  }\n};\n_anchor = new WeakMap();\n_handleAnchorResize = new WeakMap();\n_markerTransform = new WeakMap();\n_isActive = new WeakMap();\n_originalCoordinate = new WeakMap();\n_onPointerDownMarker = new WeakMap();\n_onPointerUpMarker = new WeakMap();\n_onPointerMoveMarker = new WeakMap();\n_onPointerDownImage = new WeakMap();\n_onPointerUpImage = new WeakMap();\n_onPointerMoveImage = new WeakMap();\n_updatePointerPosition = new WeakMap();\n_updateMarkerTransform = new WeakMap();\n_updateMarkerCorrection = new WeakMap();\n\n// src/icons/mapboxgl-ctrl-logo.svg\nvar mapboxgl_ctrl_logo_default = '<svg width=\"88\" height=\"23\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill-rule=\"evenodd\"><defs><path id=\"g\" d=\"M11.5 2.25a9.25 9.25 0 1 1 0 18.5 9.25 9.25 0 0 1 0-18.5zM7 15.98c-.05-.33-.83-5.8 2.23-8.87a4.4 4.4 0 0 1 3.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39a4.4 4.4 0 0 1-1.28 3.13C12.72 16.93 7 16 7 16v-.02zm8.3-5.48-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z\"/><path id=\"b\" d=\"M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19A3.77 3.77 0 0 1 50.86 15v3.77c0 .13-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01.01-.01c.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V15a3.7 3.7 0 0 1-2.73 1.19c-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.38-.19a4.24 4.24 0 0 0-4.16 3.29 4.07 4.07 0 0 0 0 1.77 4.23 4.23 0 0 0 4.17 3.3 4.22 4.22 0 0 0 4.26-4.19 4.2 4.2 0 0 0-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18a4 4 0 0 1 3.84 3.28c.13.59.13 1.2 0 1.8a4 4 0 0 1-3.84 3.29A3.77 3.77 0 0 1 60.86 15v.77c0 .12-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4a.23.23 0 0 1-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55a2.73 2.73 0 0 1 2.44-1.56c1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41a.23.23 0 0 1-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41a.23.23 0 0 1-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.62 0h-1.61a.27.27 0 0 1-.12-.03c-.1-.06-.13-.19-.06-.28l2.43-3.71-2.4-3.65a.21.21 0 0 1-.02-.12.2.2 0 0 1 .2-.21h1.61c.13 0 .24.06.3.17L82 10.54l1.4-2.37a.34.34 0 0 1 .3-.17h1.6l.12.03c.1.06.13.19.06.28l-2.37 3.65 2.43 3.7.01.13a.2.2 0 0 1-.2.21h-1.61a.33.33 0 0 1-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 0 1-.3.17zm-7.12-1.49A2.47 2.47 0 0 1 70.7 12a2.47 2.47 0 0 1 2.42-2.52 2.47 2.47 0 0 1 2.42 2.51 2.48 2.48 0 0 1-2.42 2.52zm-19.87 0a2.48 2.48 0 0 1-2.42-2.48v-.07a2.47 2.47 0 0 1 2.4-2.49 2.47 2.47 0 0 1 2.41 2.51 2.47 2.47 0 0 1-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51a2.47 2.47 0 0 1 2.4-2.52 2.46 2.46 0 0 1 2.41 2.48l.02.08zm18.12 2.47a2.47 2.47 0 0 1-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51a2.47 2.47 0 0 1-2.42 2.51z\"/></defs><mask id=\"c\"><rect width=\"100%\" height=\"100%\" fill=\"#fff\"/><use xlink:href=\"#g\"/><use xlink:href=\"#b\"/></mask><g opacity=\".3\" stroke=\"#000\" stroke-width=\"3\"><circle mask=\"url(#c)\" cx=\"11.5\" cy=\"11.5\" r=\"9.25\"/><use xlink:href=\"#b\" mask=\"url(#c)\"/></g><g opacity=\".9\" fill=\"#fff\"><use xlink:href=\"#g\"/><use xlink:href=\"#b\"/></g></svg>';\n\n// src/components/MapboxAddressMinimap.ts\nvar ZOOM = 16;\nvar TEMPLATE6 = createElementFromString(`\n<template>\n  <div class=\"MapboxAddressMinimap\" aria-hidden=\"true\">\n    <div class=\"MinimapImageContainer\">\n      <img class=\"MinimapImage\" draggable=\"false\"></img>\n      <div class=\"MinimapInnerFrame\">\n        <div class=\"MinimapMarker\"></div>\n        <div class=\"MinimapAttribution\">\n          <div class=\"MinimapAttributionLogo\">\n            <a target=\"_blank\" rel=\"noopener nofollow\" href=\"https://www.mapbox.com/\" aria-label=\"Mapbox logo\">\n              ${mapboxgl_ctrl_logo_default}\n            </a>\n          </div>\n          <div class=\"MinimapAttributionText\">\n            <a target=\"_blank\" href='https://www.mapbox.com/about/maps/'>\\xA9 Mapbox</a><a target=\"_blank\" href='http://www.openstreetmap.org/copyright'>\\xA9 OpenStreetMap</a>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n`);\nvar STYLE_TOGGLE_TEMPLATE = createElementFromString(`\n<template>\n  <button type=\"button\" class=\"MinimapStyleToggle\"></button>\n</template>\n`);\nvar FOOTER_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"MinimapFooter\">Adjust the marker on the map if it doesn't precisely match your location. This helps improve address data quality.</div>\n</template>\n`);\nvar EDIT_BUTTONS_TEMPLATE = createElementFromString(`\n<template>\n  <div class=\"MinimapEditButtons\">\n    <div class=\"Button ButtonPrimary MinimapButtonAdjust\">Adjust pin</div>\n    <div class=\"Button ButtonPrimary MinimapButtonSave\" aria-hidden=\"true\">Save</div>\n    <div class=\"Button MinimapButtonCancel\" aria-hidden=\"true\">Cancel</div>\n  </div>\n</template>\n`);\nvar _canAdjustMarkerInternal, _isAdjustMarkerEditing, _imageLoaded, _feature2, _url, _width, _height, _binding5, _markerController, _accessToken, _themeInternal5, _satelliteToggleInternal, _mapStyleMode, _defaultMapStyle, _footer, _container, _toggleMarkerEditing, _handleStartMarkerEditing, _handleSaveMarkerEditing, _handleCancelMarkerEditing, _handleToggleMapStyle, _handleImageLoad, _handleImageError, _getImageUrl, _updateImageSrc, _getToggleBackgroundImageUrl, _setSize, _addMarkerEditControls, _removeMarkerEditControls, _addSatelliteToggle, _removeSatelliteToggle;\nvar MapboxAddressMinimap = class extends HTMLScopedElement {\n  constructor() {\n    super(...arguments);\n    __privateAdd(this, _canAdjustMarkerInternal, false);\n    this.keepMarkerCentered = false;\n    this.markerAnchor = \"bottom\";\n    __privateAdd(this, _isAdjustMarkerEditing, false);\n    __privateAdd(this, _imageLoaded, false);\n    __privateAdd(this, _feature2, void 0);\n    __privateAdd(this, _url, \"\");\n    __privateAdd(this, _width, void 0);\n    __privateAdd(this, _height, void 0);\n    __privateAdd(this, _binding5, void 0);\n    __privateAdd(this, _markerController, void 0);\n    __privateAdd(this, _accessToken, void 0);\n    __privateAdd(this, _themeInternal5, {});\n    __privateAdd(this, _satelliteToggleInternal, false);\n    __privateAdd(this, _mapStyleMode, \"default\");\n    __privateAdd(this, _defaultMapStyle, [\"mapbox\", \"streets-v11\"]);\n    __privateAdd(this, _footer, void 0);\n    __privateAdd(this, _container, void 0);\n    __privateAdd(this, _toggleMarkerEditing, () => {\n      const { ImageContainer, ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding5);\n      if (__privateGet(this, _isAdjustMarkerEditing)) {\n        ImageContainer.classList.add(`${this.dataset.seed}--draggable`);\n        __privateGet(this, _markerController).isActive = true;\n        ButtonAdjust.setAttribute(\"aria-hidden\", \"true\");\n        ButtonSave.removeAttribute(\"aria-hidden\");\n        ButtonCancel.removeAttribute(\"aria-hidden\");\n      } else {\n        ImageContainer.classList.remove(`${this.dataset.seed}--draggable`);\n        __privateGet(this, _markerController).isActive = false;\n        ButtonAdjust.removeAttribute(\"aria-hidden\");\n        ButtonSave.setAttribute(\"aria-hidden\", \"true\");\n        ButtonCancel.setAttribute(\"aria-hidden\", \"true\");\n      }\n    });\n    __privateAdd(this, _handleStartMarkerEditing, () => {\n      __privateSet(this, _isAdjustMarkerEditing, true);\n      __privateGet(this, _toggleMarkerEditing).call(this);\n    });\n    __privateAdd(this, _handleSaveMarkerEditing, () => {\n      if (this.feature.properties.full_address && !deepEquals(this.feature.geometry.coordinates, __privateGet(this, _markerController).coordinate)) {\n        const [lng, lat] = __privateGet(this, _markerController).coordinate;\n        sendFeedback(this.accessToken, {\n          originalCoordinate: this.feature.geometry.coordinates,\n          originalAddress: this.feature.properties.full_address,\n          changes: {\n            location: { longitude: lng, latitude: lat }\n          }\n        });\n      }\n      if (this.onSaveMarkerLocation) {\n        this.onSaveMarkerLocation(__privateGet(this, _markerController).coordinate);\n      }\n      __privateSet(this, _isAdjustMarkerEditing, false);\n      __privateGet(this, _toggleMarkerEditing).call(this);\n    });\n    __privateAdd(this, _handleCancelMarkerEditing, () => {\n      __privateGet(this, _markerController).reCenter();\n      __privateSet(this, _isAdjustMarkerEditing, false);\n      __privateGet(this, _toggleMarkerEditing).call(this);\n    });\n    __privateAdd(this, _handleToggleMapStyle, () => {\n      this.mapStyleMode = this.mapStyleMode === \"default\" ? \"satellite\" : \"default\";\n    });\n    __privateAdd(this, _handleImageLoad, () => {\n      if (!__privateGet(this, _imageLoaded)) {\n        __privateGet(this, _markerController).reCenter();\n      }\n      __privateSet(this, _imageLoaded, true);\n      __privateGet(this, _markerController) && __privateGet(this, _markerController).handleMinimapResize();\n    });\n    __privateAdd(this, _handleImageError, () => {\n      __privateSet(this, _imageLoaded, false);\n    });\n    __privateAdd(this, _getImageUrl, (lngLatLike) => {\n      if (__privateGet(this, _width) === 0 || __privateGet(this, _height) === 0)\n        return \"\";\n      const [username, styleId] = this.defaultMapStyle;\n      const defaultBaseUrl = getStaticBaseUrl(username, styleId);\n      const baseUrl = this.mapStyleMode === \"default\" ? defaultBaseUrl : STATIC_BASE_URL_SATELLITE;\n      const skuToken = AUTOFILL_SKU_TOKEN_PREFIX + config.autofillSessionToken.toString();\n      let imgUrl = baseUrl + _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.LngLat.convert(lngLatLike).toArray().join(\",\") + \",\" + ZOOM + \",0/\" + Math.min(__privateGet(this, _width) * 2, MAX_IMAGE_DIM) + \"x\" + Math.min(__privateGet(this, _height) * 2, MAX_IMAGE_DIM) + \"?access_token=\" + this.accessToken + \"&attribution=false&logo=false\";\n      if (config.autofillSessionEnabled) {\n        imgUrl += `&sku=${skuToken}`;\n      }\n      return imgUrl;\n    });\n    __privateAdd(this, _updateImageSrc, () => {\n      if (__privateGet(this, _feature2)) {\n        const lngLat = __privateGet(this, _feature2).geometry.coordinates;\n        __privateSet(this, _url, __privateGet(this, _getImageUrl).call(this, lngLat));\n        const { Image } = __privateGet(this, _binding5);\n        Image.src = __privateGet(this, _url);\n      }\n    });\n    __privateAdd(this, _getToggleBackgroundImageUrl, (styleMode) => {\n      return `url(\"${getImage(styleMode === \"default\" ? \"styleToggleDefault\" : \"styleToggleSatellite\", this.theme)}\")`;\n    });\n    __privateAdd(this, _setSize, () => {\n      const { MapboxAddressMinimap: MapboxAddressMinimap2, ImageContainer, Image } = __privateGet(this, _binding5);\n      const { width, height } = getElementSize(this.container);\n      const [oldWidth, oldHeight] = [__privateGet(this, _width), __privateGet(this, _height)];\n      __privateSet(this, _width, Math.min(width, MAX_IMAGE_DIM));\n      __privateSet(this, _height, Math.min(height, MAX_IMAGE_DIM));\n      MapboxAddressMinimap2.style.setProperty(\"width\", `${__privateGet(this, _width)}px`);\n      MapboxAddressMinimap2.style.setProperty(\"height\", `${__privateGet(this, _height)}px`);\n      ImageContainer.style.setProperty(\"height\", `${__privateGet(this, _height)}px`);\n      ImageContainer.style.setProperty(\"width\", `${__privateGet(this, _width)}px`);\n      const [imgWidth, imgHeight] = [Image.width, Image.height];\n      if (__privateGet(this, _width) > oldWidth && __privateGet(this, _width) > imgWidth / 2 && imgWidth < MAX_IMAGE_DIM || __privateGet(this, _height) > oldHeight && __privateGet(this, _height) > imgHeight / 2 && imgHeight < MAX_IMAGE_DIM) {\n        __privateGet(this, _updateImageSrc).call(this);\n      } else {\n        __privateGet(this, _markerController) && __privateGet(this, _markerController).handleMinimapResize();\n      }\n    });\n    __privateAdd(this, _addMarkerEditControls, () => {\n      const existingFooter = this.querySelector(\".MinimapFooter\");\n      if (existingFooter)\n        return;\n      const footerElement = this.prepareTemplate(FOOTER_TEMPLATE);\n      const minimapElement = this.querySelector(\".MapboxAddressMinimap\");\n      if (!minimapElement)\n        return;\n      minimapElement.appendChild(footerElement);\n      const existingEditBtns = this.querySelector(\".MinimapEditButtons\");\n      if (existingEditBtns)\n        return;\n      const editButtonsElement = this.prepareTemplate(EDIT_BUTTONS_TEMPLATE);\n      const innerFrame = this.querySelector(\".MinimapInnerFrame\");\n      innerFrame.appendChild(editButtonsElement);\n      __privateSet(this, _binding5, __spreadProps(__spreadValues({}, __privateGet(this, _binding5)), {\n        EditButtons: this.querySelector(\".MinimapEditButtons\"),\n        ButtonAdjust: this.querySelector(\".MinimapButtonAdjust\"),\n        ButtonSave: this.querySelector(\".MinimapButtonSave\"),\n        ButtonCancel: this.querySelector(\".MinimapButtonCancel\")\n      }));\n      const { ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding5);\n      ButtonAdjust.addEventListener(\"click\", __privateGet(this, _handleStartMarkerEditing));\n      ButtonSave.addEventListener(\"click\", __privateGet(this, _handleSaveMarkerEditing));\n      ButtonCancel.addEventListener(\"click\", __privateGet(this, _handleCancelMarkerEditing));\n    });\n    __privateAdd(this, _removeMarkerEditControls, () => {\n      if (!__privateGet(this, _binding5))\n        return;\n      const { EditButtons, ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding5);\n      const existingFooter = this.querySelector(\".MinimapFooter\");\n      existingFooter == null ? void 0 : existingFooter.remove();\n      EditButtons == null ? void 0 : EditButtons.remove();\n      if (ButtonAdjust) {\n        ButtonAdjust.remove();\n        ButtonAdjust.removeEventListener(\"click\", __privateGet(this, _handleStartMarkerEditing));\n      }\n      if (ButtonSave) {\n        ButtonSave.remove();\n        ButtonSave.removeEventListener(\"click\", __privateGet(this, _handleSaveMarkerEditing));\n      }\n      if (ButtonCancel) {\n        ButtonCancel.remove();\n        ButtonCancel.removeEventListener(\"click\", __privateGet(this, _handleCancelMarkerEditing));\n      }\n      delete __privateGet(this, _binding5).EditButtons;\n      delete __privateGet(this, _binding5).ButtonAdjust;\n      delete __privateGet(this, _binding5).ButtonSave;\n      delete __privateGet(this, _binding5).ButtonCancel;\n    });\n    __privateAdd(this, _addSatelliteToggle, () => {\n      const existingToggle = this.querySelector(\".MinimapStyleToggle\");\n      if (existingToggle)\n        return;\n      const toggleElement = this.prepareTemplate(STYLE_TOGGLE_TEMPLATE);\n      const innerFrame = this.querySelector(\".MinimapInnerFrame\");\n      if (!innerFrame)\n        return;\n      innerFrame.appendChild(toggleElement);\n      __privateGet(this, _binding5).MapStyleToggle = toggleElement;\n      toggleElement.addEventListener(\"click\", __privateGet(this, _handleToggleMapStyle));\n      toggleElement.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, this.mapStyleMode === \"default\" ? \"satellite\" : \"default\");\n      toggleElement.setAttribute(\"title\", `Switch to ${this.mapStyleMode === \"default\" ? \"Satellite\" : \"Default\"}`);\n    });\n    __privateAdd(this, _removeSatelliteToggle, () => {\n      if (!__privateGet(this, _binding5))\n        return;\n      const { MapStyleToggle } = __privateGet(this, _binding5);\n      if (!MapStyleToggle)\n        return;\n      MapStyleToggle.remove();\n      MapStyleToggle.removeEventListener(\"click\", __privateGet(this, _handleToggleMapStyle));\n      delete __privateGet(this, _binding5).MapStyleToggle;\n    });\n  }\n  get canAdjustMarker() {\n    return __privateGet(this, _canAdjustMarkerInternal);\n  }\n  set canAdjustMarker(val) {\n    __privateSet(this, _canAdjustMarkerInternal, val);\n    val ? __privateGet(this, _addMarkerEditControls).call(this) : __privateGet(this, _removeMarkerEditControls).call(this);\n  }\n  get accessToken() {\n    return __privateGet(this, _accessToken) || config.accessToken;\n  }\n  set accessToken(newToken) {\n    __privateSet(this, _accessToken, newToken);\n  }\n  get feature() {\n    return __privateGet(this, _feature2);\n  }\n  set feature(feature) {\n    __privateSet(this, _feature2, feature);\n    if (!feature) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n  get template() {\n    return TEMPLATE6;\n  }\n  get templateStyle() {\n    return style_default;\n  }\n  get templateUserStyle() {\n    return getThemeCSS(\".MapboxAddressMinimap\", this.theme);\n  }\n  get satelliteToggle() {\n    return __privateGet(this, _satelliteToggleInternal);\n  }\n  set satelliteToggle(val) {\n    __privateSet(this, _satelliteToggleInternal, val);\n    val ? __privateGet(this, _addSatelliteToggle).call(this) : __privateGet(this, _removeSatelliteToggle).call(this);\n  }\n  get theme() {\n    return __privateGet(this, _themeInternal5);\n  }\n  set theme(theme) {\n    __privateSet(this, _themeInternal5, theme);\n    if (!__privateGet(this, _binding5) || !theme) {\n      return;\n    }\n    this.updateTemplateUserStyle(getThemeCSS(\".MapboxAddressMinimap\", theme));\n    const { Marker, MapStyleToggle } = __privateGet(this, _binding5);\n    Marker.innerHTML = getIcon(\"marker\", theme);\n    if (MapStyleToggle) {\n      MapStyleToggle.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, this.mapStyleMode === \"default\" ? \"satellite\" : \"default\");\n    }\n  }\n  get mapStyleMode() {\n    return __privateGet(this, _mapStyleMode);\n  }\n  set mapStyleMode(styleMode) {\n    const prevStyleMode = __privateGet(this, _mapStyleMode);\n    __privateSet(this, _mapStyleMode, styleMode);\n    if (!__privateGet(this, _binding5)) {\n      return;\n    }\n    const { MapStyleToggle } = __privateGet(this, _binding5);\n    if (!MapStyleToggle) {\n      return;\n    }\n    MapStyleToggle.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, prevStyleMode);\n    MapStyleToggle.setAttribute(\"title\", `Switch to ${prevStyleMode === \"satellite\" ? \"Satellite\" : \"Default\"}`);\n    __privateGet(this, _updateImageSrc).call(this);\n  }\n  get defaultMapStyle() {\n    return __privateGet(this, _defaultMapStyle);\n  }\n  set defaultMapStyle(style) {\n    __privateSet(this, _defaultMapStyle, style);\n    __privateGet(this, _updateImageSrc).call(this);\n  }\n  get footer() {\n    return __privateGet(this, _footer);\n  }\n  set footer(val) {\n    __privateSet(this, _footer, val);\n    const footerEl = this.querySelector(\".MinimapFooter\");\n    if (footerEl) {\n      if (typeof val === \"string\") {\n        footerEl.textContent = val;\n        footerEl.removeAttribute(\"aria-hidden\");\n      } else if (!val) {\n        footerEl.setAttribute(\"aria-hidden\", \"true\");\n      } else {\n        footerEl.removeAttribute(\"aria-hidden\");\n      }\n    }\n  }\n  get container() {\n    return __privateGet(this, _container);\n  }\n  set container(newContainer) {\n    if (newContainer) {\n      newContainer.style.position = \"relative\";\n      __privateSet(this, _container, newContainer);\n    }\n  }\n  show() {\n    if (!__privateGet(this, _feature2)) {\n      return;\n    }\n    const lngLat = __privateGet(this, _feature2).geometry.coordinates;\n    __privateGet(this, _markerController).coordinate = lngLat;\n    __privateSet(this, _url, __privateGet(this, _getImageUrl).call(this, lngLat));\n    const { MapboxAddressMinimap: MapboxAddressMinimap2, Image } = __privateGet(this, _binding5);\n    Image.src = __privateGet(this, _url);\n    MapboxAddressMinimap2.removeAttribute(\"aria-hidden\");\n  }\n  hide() {\n    const { MapboxAddressMinimap: MapboxAddressMinimap2 } = __privateGet(this, _binding5);\n    MapboxAddressMinimap2.setAttribute(\"aria-hidden\", \"true\");\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    __privateSet(this, _binding5, bindElements(this, {\n      MapboxAddressMinimap: \".MapboxAddressMinimap\",\n      ImageContainer: \".MinimapImageContainer\",\n      Image: \".MinimapImage\",\n      Marker: \".MinimapMarker\",\n      MapStyleToggle: \".MinimapStyleToggle\",\n      EditButtons: \".MinimapEditButtons\",\n      ButtonAdjust: \".MinimapButtonAdjust\",\n      ButtonSave: \".MinimapButtonSave\",\n      ButtonCancel: \".MinimapButtonCancel\"\n    }));\n    this.mapStyleMode = __privateGet(this, _mapStyleMode);\n    this.theme = __spreadValues({}, this.theme);\n    if (this.canAdjustMarker) {\n      __privateGet(this, _addMarkerEditControls).call(this);\n    }\n    if (this.satelliteToggle) {\n      __privateGet(this, _addSatelliteToggle).call(this);\n    }\n    this.container = this.parentElement;\n    const resizeObserver = new ResizeObserver(__privateGet(this, _setSize));\n    resizeObserver.observe(this.container);\n    __privateGet(this, _setSize).call(this);\n    const { MapboxAddressMinimap: MapboxAddressMinimap2, ImageContainer, Image, Marker } = __privateGet(this, _binding5);\n    __privateSet(this, _markerController, new MarkerController(ImageContainer, Image, Marker, this.keepMarkerCentered, ZOOM, this.markerAnchor));\n    __privateGet(this, _markerController).reCenter();\n    Image.onload = __privateGet(this, _handleImageLoad);\n    Image.onerror = __privateGet(this, _handleImageError);\n    Image.src = __privateGet(this, _url);\n    if (__privateGet(this, _feature2))\n      MapboxAddressMinimap2.removeAttribute(\"aria-hidden\");\n    else\n      MapboxAddressMinimap2.setAttribute(\"aria-hidden\", \"true\");\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === \"access-token\") {\n      this.accessToken = newValue;\n    } else if (name === \"can-adjust-marker\") {\n      this.canAdjustMarker = newValue === \"true\";\n    } else if (name === \"keep-marker-centered\") {\n      this.keepMarkerCentered = newValue === \"true\";\n    } else if (name === \"marker-anchor\") {\n      const newAnchor = newValue;\n      this.markerAnchor = newAnchor;\n      __privateGet(this, _markerController) && (__privateGet(this, _markerController).anchor = newAnchor);\n    } else if (name === \"satellite-toggle\") {\n      this.satelliteToggle = newValue === \"true\";\n    }\n  }\n};\n_canAdjustMarkerInternal = new WeakMap();\n_isAdjustMarkerEditing = new WeakMap();\n_imageLoaded = new WeakMap();\n_feature2 = new WeakMap();\n_url = new WeakMap();\n_width = new WeakMap();\n_height = new WeakMap();\n_binding5 = new WeakMap();\n_markerController = new WeakMap();\n_accessToken = new WeakMap();\n_themeInternal5 = new WeakMap();\n_satelliteToggleInternal = new WeakMap();\n_mapStyleMode = new WeakMap();\n_defaultMapStyle = new WeakMap();\n_footer = new WeakMap();\n_container = new WeakMap();\n_toggleMarkerEditing = new WeakMap();\n_handleStartMarkerEditing = new WeakMap();\n_handleSaveMarkerEditing = new WeakMap();\n_handleCancelMarkerEditing = new WeakMap();\n_handleToggleMapStyle = new WeakMap();\n_handleImageLoad = new WeakMap();\n_handleImageError = new WeakMap();\n_getImageUrl = new WeakMap();\n_updateImageSrc = new WeakMap();\n_getToggleBackgroundImageUrl = new WeakMap();\n_setSize = new WeakMap();\n_addMarkerEditControls = new WeakMap();\n_removeMarkerEditControls = new WeakMap();\n_addSatelliteToggle = new WeakMap();\n_removeSatelliteToggle = new WeakMap();\nMapboxAddressMinimap.observedAttributes = [\n  \"access-token\",\n  \"can-adjust-marker\",\n  \"keep-marker-centered\",\n  \"marker-anchor\",\n  \"satellite-toggle\"\n];\nwindow.MapboxAddressMinimap = MapboxAddressMinimap;\nif (!window.customElements.get(\"mapbox-address-minimap\")) {\n  customElements.define(\"mapbox-address-minimap\", MapboxAddressMinimap);\n}\n\n// src/autofill.ts\n\nvar _input3, _collection, _handleSuggest4, _handleSuggestError4, _handleRetrieve3;\nvar AutofillInstance = class {\n  constructor(collection, input, autofillRef) {\n    __privateAdd(this, _input3, void 0);\n    __privateAdd(this, _collection, void 0);\n    this.listbox = new MapboxSearchListbox();\n    __privateAdd(this, _handleSuggest4, (e) => {\n      const eventClone = new MapboxHTMLEvent(e.type, e.detail);\n      Object.defineProperty(eventClone, \"target\", { value: __privateGet(this, _input3) });\n      __privateGet(this, _collection).fire(\"suggest\", eventClone);\n    });\n    __privateAdd(this, _handleSuggestError4, (e) => {\n      const eventClone = new MapboxHTMLEvent(e.type, e.detail);\n      Object.defineProperty(eventClone, \"target\", { value: __privateGet(this, _input3) });\n      __privateGet(this, _collection).fire(\"suggesterror\", eventClone);\n    });\n    __privateAdd(this, _handleRetrieve3, (e) => {\n      const eventClone = new MapboxHTMLEvent(e.type, e.detail);\n      Object.defineProperty(eventClone, \"target\", { value: __privateGet(this, _input3) });\n      __privateGet(this, _collection).fire(\"retrieve\", eventClone);\n      if (!__privateGet(this, _input3)) {\n        return;\n      }\n      const featureCollection = e.detail;\n      if (!featureCollection || !featureCollection.features || !featureCollection.features.length) {\n        return;\n      }\n      fillFormWithFeature(featureCollection.features[0], __privateGet(this, _input3));\n    });\n    __privateSet(this, _input3, input);\n    __privateSet(this, _collection, collection);\n    this.listbox.input = __privateGet(this, _input3);\n    this.listbox.session = new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.SearchSession(autofillRef);\n    this.listbox.session.sessionToken = config.autofillSessionToken;\n    this.listbox.addEventListener(\"suggest\", __privateGet(this, _handleSuggest4));\n    this.listbox.addEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError4));\n    this.listbox.addEventListener(\"retrieve\", __privateGet(this, _handleRetrieve3));\n    document.body.appendChild(this.listbox);\n  }\n  remove() {\n    this.listbox.remove();\n    this.listbox.removeEventListener(\"suggest\", __privateGet(this, _handleSuggest4));\n    this.listbox.removeEventListener(\"suggesterror\", __privateGet(this, _handleSuggestError4));\n    this.listbox.removeEventListener(\"retrieve\", __privateGet(this, _handleRetrieve3));\n  }\n};\n_input3 = new WeakMap();\n_collection = new WeakMap();\n_handleSuggest4 = new WeakMap();\n_handleSuggestError4 = new WeakMap();\n_handleRetrieve3 = new WeakMap();\nvar _currentInputs, _autofill2, _options2, _theme, _popoverOptions2, _handleObserve2, _observer2, _handleBrowserAutofill2;\nvar AutofillCollection = class extends _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.Evented {\n  constructor({\n    accessToken,\n    options,\n    theme,\n    popoverOptions,\n    confirmOnBrowserAutofill\n  }) {\n    super();\n    this.instances = [];\n    __privateAdd(this, _currentInputs, void 0);\n    __privateAdd(this, _autofill2, new _mapbox_search_js_core__WEBPACK_IMPORTED_MODULE_0__.MapboxAutofill());\n    __privateAdd(this, _options2, void 0);\n    __privateAdd(this, _theme, void 0);\n    __privateAdd(this, _popoverOptions2, void 0);\n    this.confirmOnBrowserAutofill = false;\n    __privateAdd(this, _handleObserve2, () => {\n      if (!deepEquals(findAddressInputs(), __privateGet(this, _currentInputs))) {\n        this.update();\n      }\n    });\n    __privateAdd(this, _observer2, new MutationObserver(__privateGet(this, _handleObserve2)));\n    __privateAdd(this, _handleBrowserAutofill2, (e) => __async(this, null, function* () {\n      this.instances.forEach((instance) => instance.listbox.blur());\n      for (const instance of this.instances) {\n        const input = instance.listbox.input;\n        yield tryConfirmBrowserAutofill(input, e, this.confirmOnBrowserAutofill, this.accessToken);\n      }\n    }));\n    initDetectBrowserAutofill();\n    window.addEventListener(\"browserautofill\", __privateGet(this, _handleBrowserAutofill2));\n    config.autofillSessionEnabled = true;\n    this.accessToken = accessToken || config.accessToken;\n    options && (this.options = options);\n    theme && (this.theme = theme);\n    popoverOptions && (this.popoverOptions = popoverOptions);\n    confirmOnBrowserAutofill && (this.confirmOnBrowserAutofill = confirmOnBrowserAutofill);\n    this.update();\n  }\n  get accessToken() {\n    return __privateGet(this, _autofill2).accessToken;\n  }\n  set accessToken(newToken) {\n    __privateGet(this, _autofill2).accessToken = newToken;\n  }\n  get options() {\n    return __privateGet(this, _options2);\n  }\n  set options(newOptions) {\n    __privateSet(this, _options2, __spreadValues(__spreadValues({}, __privateGet(this, _options2)), newOptions));\n    this.instances.forEach((instance) => {\n      instance.listbox.options = __spreadValues(__spreadValues({}, instance.listbox.options), newOptions);\n    });\n  }\n  get theme() {\n    return __privateGet(this, _theme);\n  }\n  set theme(newTheme) {\n    __privateSet(this, _theme, newTheme);\n    this.instances.forEach((instance) => {\n      instance.listbox.theme = newTheme;\n    });\n  }\n  get popoverOptions() {\n    return __privateGet(this, _popoverOptions2);\n  }\n  set popoverOptions(newOptions) {\n    __privateSet(this, _popoverOptions2, newOptions);\n    this.instances.forEach((instance) => {\n      instance.listbox.popoverOptions = newOptions;\n    });\n  }\n  update() {\n    this.instances.forEach((instance) => {\n      instance.remove();\n    });\n    __privateSet(this, _currentInputs, findAddressInputs());\n    this.instances = [];\n    __privateGet(this, _currentInputs).forEach((input) => {\n      const autofillInstance = new AutofillInstance(this, input, __privateGet(this, _autofill2));\n      autofillInstance.listbox.options = this.options;\n      autofillInstance.listbox.theme = this.theme;\n      autofillInstance.listbox.popoverOptions = this.popoverOptions;\n      this.instances.push(autofillInstance);\n    });\n  }\n  observe() {\n    __privateGet(this, _observer2).observe(document, {\n      subtree: true,\n      childList: true\n    });\n    __privateGet(this, _handleObserve2).call(this);\n  }\n  unobserve() {\n    __privateGet(this, _observer2).disconnect();\n  }\n  remove() {\n    this.instances.forEach((instance) => {\n      instance.remove();\n    });\n    this.unobserve();\n    window.removeEventListener(\"browserautofill\", __privateGet(this, _handleBrowserAutofill2));\n  }\n};\n_currentInputs = new WeakMap();\n_autofill2 = new WeakMap();\n_options2 = new WeakMap();\n_theme = new WeakMap();\n_popoverOptions2 = new WeakMap();\n_handleObserve2 = new WeakMap();\n_observer2 = new WeakMap();\n_handleBrowserAutofill2 = new WeakMap();\nfunction autofill(optionsArg) {\n  return new AutofillCollection(optionsArg);\n}\n\n//# sourceMappingURL=index-esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hcGJveC9zZWFyY2gtanMtd2ViL2Rpc3QvaW5kZXgtZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEUsbUVBQW1FLElBQUksS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWSxFQUFFLHFCQUFxQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVMsRUFBRSw4Q0FBOEM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVMsR0FBRyxRQUFRO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsZ0VBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRLElBQUk7QUFDekY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEIsSUFBSSxVQUFVO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUUsUUFBUTtBQUMzRSxpRUFBaUUsUUFBUTtBQUN6RTtBQUNBLCtEQUErRCxrQkFBa0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLG9EQUFvRCxpREFBaUQ7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSSxJQUFJLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsS0FBSyxFQUFFLFNBQVM7QUFDcEY7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0IsRUFBRSxnQkFBZ0IsSUFBSSxJQUFJLElBQUksYUFBYSxlQUFlO0FBQ2xHLDBCQUEwQixJQUFJLElBQUksY0FBYztBQUNoRDtBQUNBLHNCQUFzQixnQkFBZ0IsRUFBRSxnQkFBZ0I7QUFDeEQ7QUFDQSxxQ0FBcUM7QUFDckMsZ0RBQWdELHlDQUF5QztBQUN6RjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaURBQWlELDJDQUEyQztBQUM1RjtBQUNBO0FBQ0E7O0FBRUE7QUFNMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0RBQU07QUFDaEIsK0JBQStCLHNEQUFJO0FBQ25DO0FBQ0E7QUFDQSxjQUFjLE9BQU8sUUFBUSxpRUFBZTtBQUM1QztBQUNBLGlCQUFpQixFQUFFO0FBQ25CLGdCQUFnQixFQUFFO0FBQ2xCLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxtQkFBbUIsNERBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixnQ0FBZ0MsY0FBYyxlQUFlLGNBQWMsVUFBVSxhQUFhLFNBQVMsd0NBQXdDLHFCQUFxQixrQ0FBa0MsNEJBQTRCLHVCQUF1Qiw4QkFBOEIsc0JBQXNCLDhCQUE4Qiw4QkFBOEIsMEJBQTBCLGdCQUFnQixrQkFBa0Isd0JBQXdCLHNDQUFzQyxtQkFBbUIsYUFBYSxpQ0FBaUMsbUJBQW1CLDJCQUEyQiwrREFBK0Qsa0JBQWtCLFlBQVksdUJBQXVCLGtCQUFrQixlQUFlLGdDQUFnQyw2Q0FBNkMsbUJBQW1CLDhDQUE4QyxnQkFBZ0Isa0NBQWtDLG9CQUFvQix1QkFBdUIsc0JBQXNCLDRCQUE0QixrQ0FBa0MscUJBQXFCLGFBQWEsZ0JBQWdCLFNBQVMsVUFBVSxPQUFPLGFBQWEsT0FBTyx3Q0FBd0MscUJBQXFCLGtDQUFrQyw0QkFBNEIsdUJBQXVCLDhCQUE4QixzQkFBc0IsOEJBQThCLDhCQUE4Qix1QkFBdUIsV0FBVywrR0FBK0csYUFBYSwyQkFBMkIsbUJBQW1CLHNDQUFzQyxTQUFTLGFBQWEsdUJBQXVCLE9BQU8sZUFBZSxRQUFRLE1BQU0sd0JBQXdCLGFBQWEsbURBQW1ELHVEQUF1RCxtQkFBbUIsNkNBQTZDLGtCQUFrQixrQ0FBa0Msc0JBQXNCLE9BQU8sd0NBQXdDLHFCQUFxQixrQ0FBa0MsNEJBQTRCLHVCQUF1Qiw4QkFBOEIsc0JBQXNCLDhCQUE4Qiw4QkFBOEIsNEJBQTRCLFdBQVcsb0NBQW9DLDJCQUEyQixxQkFBcUIsa0NBQWtDLFdBQVcsT0FBTyw0QkFBNEIsOEJBQThCLGFBQWEsbUJBQW1CLDBCQUEwQixhQUFhLDRCQUE0QixrQ0FBa0MsNkJBQTZCLGlCQUFpQixXQUFXLFVBQVUsa0NBQWtDLHlDQUF5Qyx5Q0FBeUMsNEJBQTRCLGFBQWEsTUFBTSx5QkFBeUIsd0JBQXdCLGdCQUFnQiw0QkFBNEIsa0JBQWtCLE9BQU8sa0JBQWtCLGFBQWEsNEJBQTRCLDBCQUEwQixrQkFBa0IsK0JBQStCLGFBQWEsZ0JBQWdCLGtDQUFrQyxpQkFBaUIsa0JBQWtCLDBCQUEwQiw4QkFBOEIsNkJBQTZCLGtDQUFrQywwQkFBMEIsUUFBUSxrQ0FBa0MsZUFBZSxzQ0FBc0MsMEJBQTBCLHVCQUF1QixrQkFBa0IsaUJBQWlCLFdBQVcsMEJBQTBCLGFBQWEsc0JBQXNCLHFDQUFxQyw2QkFBNkIsd0JBQXdCLHVDQUF1Qyw0QkFBNEIsa0JBQWtCLEdBQUcsVUFBVSxHQUFHLFdBQVcsc0JBQXNCLDhCQUE4QixzQkFBc0IsOEJBQThCLDhCQUE4Qix3Q0FBd0MsYUFBYSx1QkFBdUIsa0NBQWtDLGdCQUFnQixjQUFjLGFBQWEsaUJBQWlCLGdCQUFnQixrQkFBa0IsWUFBWSxtQkFBbUIscUJBQXFCLHNCQUFzQixlQUFlLE9BQU8sZ0JBQWdCLGtCQUFrQixNQUFNLGNBQWMsZUFBZSxTQUFTLGtCQUFrQixRQUFRLG1CQUFtQiwwQkFBMEIsd0JBQXdCLHdCQUF3QixTQUFTLE9BQU8sbUJBQW1CLGtCQUFrQiwwQkFBMEIsZUFBZSxjQUFjLFlBQVksV0FBVyx3QkFBd0IscUNBQXFDLFNBQVMseURBQXlELGNBQWMsa0JBQWtCLFFBQVEsMEJBQTBCLHNCQUFzQixxQkFBcUIsZ0NBQWdDLGNBQWMsMEJBQTBCLDRDQUE0QyxnQkFBZ0Isb0JBQW9CLHNCQUFzQiw0QkFBNEIsd0JBQXdCLHNCQUFzQixrQkFBa0IsNEJBQTRCLGVBQWUsV0FBVyxrQkFBa0IscUJBQXFCLG1CQUFtQixVQUFVLGVBQWUsNEJBQTRCLDhCQUE4QixzQkFBc0IsMEJBQTBCLGlDQUFpQyxhQUFhLG9CQUFvQixZQUFZLGFBQWEsOEJBQThCLGtCQUFrQixxQkFBcUIsNEJBQTRCLDRCQUE0QixxQkFBcUIsd0NBQXdDLDJCQUEyQixXQUFXLFlBQVksWUFBWSxrQkFBa0IsZ0JBQWdCOztBQUV4bUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhLEdBQUcsRUFBRTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MseUNBQXlDO0FBQ3pDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsTUFBTTtBQUN4RDtBQUNBLCtDQUErQyxHQUFHO0FBQ2xEO0FBQ0E7QUFDQSw2RUFBNkUsY0FBYyxLQUFLLHdCQUF3QjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUNBQXVDO0FBQ2pEO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBR2dDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJFQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR2dDOztBQUVoQztBQUlnQztBQUNDO0FBQ1k7O0FBRTdDO0FBQ3VFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnRUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHdEQUF3RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1DQUFtQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQXdEO0FBQ3BFO0FBQ0E7QUFDQSxJQUFJLG9EQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxjQUFjLDBGQUEwRjtBQUN4RyxjQUFjLDhDQUE4QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbURBQVc7QUFDakI7QUFDQSxxQ0FBcUMsMkRBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQywyQkFBMkIsa0VBQWM7QUFDekM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw4RkFBOEYsNkVBQXlCO0FBQ3ZILGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsNkJBQTZCLDJFQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0NBQXdDLEVBQUUsb0NBQW9DO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxJQUFJO0FBQ3BFO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTLEdBQUcseUJBQXlCLHdCQUF3QixZQUFZO0FBQzFGLFVBQVUsK0NBQStDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRLEdBQUcsb0JBQW9CO0FBQ3ZFO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUF3RDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGlFQUFpRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQ0FBc0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJZ0M7O0FBRWhDO0FBQ2tEOztBQUVsRDtBQUNBLGdIQUFnSCxzQ0FBc0MsMkZBQTJGLHVDQUF1QyxrQ0FBa0MsR0FBRyx3Q0FBd0MsR0FBRyx5Q0FBeUMsbUNBQW1DLEdBQUcseUNBQXlDLEdBQUcsMENBQTBDOztBQUU3Z0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0VBQWM7QUFDcEQscUNBQXFDLGlFQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBTWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdFQUFZLEdBQUc7QUFDbkQsc0NBQXNDLGlFQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyRUFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHdFQUFvQjtBQUN4RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNnRDs7QUFFaEQ7QUFDMEQ7QUFDMUQsZUFBZSxrRUFBaUIsR0FBRywrQkFBK0I7QUFDbEU7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLCtEQUErRDtBQUM3RTtBQUNBO0FBQ0Esb0VBQW9FLFdBQVcsbUJBQW1CLFdBQVc7QUFDN0csS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseURBQXlEO0FBQ3ZFO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwyQ0FBMkMsa0JBQWtCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtFQUFjO0FBQzNDO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsOEZBQThGO0FBQ25ILEtBQUs7QUFDTDtBQUNBLGNBQWMscUVBQXFFO0FBQ25GLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwyQkFBMkI7QUFDckYsMkRBQTJELDRCQUE0QjtBQUN2RixvREFBb0QsNEJBQTRCO0FBQ2hGLG1EQUFtRCwyQkFBMkI7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGNBQWMseUNBQXlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMERBQTBEO0FBQ2pILEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3REFBd0Q7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQXFEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkVBQTZFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUtnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9DQUFvQztBQUN4RjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0RBQW9ELG9DQUFvQztBQUN4RjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0RBQW9ELG9DQUFvQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlFQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJEQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0VBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsaUVBQWlFO0FBQ2pFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG1hcGJveC9zZWFyY2gtanMtd2ViL2Rpc3QvaW5kZXgtZXNtLmpzPzhhNzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKTtcbiAgcmV0dXJuIG1ldGhvZDtcbn07XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvdXRpbHMvZG9tLnRzXG52YXIgc3ViZG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG5mdW5jdGlvbiBiaW5kRWxlbWVudHMocm9vdCwgZWxlbWVudHMpIHtcbiAgY29uc3QgYmluZGluZyA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHNlbGVjdG9yXSBvZiBPYmplY3QuZW50cmllcyhlbGVtZW50cykpIHtcbiAgICBiaW5kaW5nW2tleV0gPSByb290LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9XG4gIHJldHVybiBiaW5kaW5nO1xufVxuZnVuY3Rpb24gZ2V0Q2hpbGRFbGVtZW50cyhub2RlKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcyB8fCBbXSkuZmlsdGVyKChlbCkgPT4gZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRGcm9tU3RyaW5nKGlubmVySFRNTCkge1xuICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaW5uZXJIVE1MO1xuICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNTU1N0eWxlU2hlZXQodGV4dCkge1xuICBjb25zdCBzdHlsZSA9IHN1YmRvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgc3ViZG9jLmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICByZXR1cm4gc3R5bGUuc2hlZXQ7XG59XG5mdW5jdGlvbiBpc1Zpc2libGUoZWxlbWVudCkge1xuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICByZXR1cm4gc3R5bGUuZGlzcGxheSAhPT0gXCJub25lXCI7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgaWYgKCFpbnB1dCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZXQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGlucHV0LmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJ2YWx1ZVwiKS5zZXQ7XG4gIHNldC5jYWxsKGlucHV0LCB2YWx1ZSk7XG4gIGNvbnN0IHdyYXBwZXJTdGF0ZSA9IGlucHV0O1xuICBpZiAod3JhcHBlclN0YXRlLl92YWx1ZVRyYWNrZXIpIHtcbiAgICB3cmFwcGVyU3RhdGUuX3ZhbHVlVHJhY2tlci5zZXRWYWx1ZShcIlwiKTtcbiAgfVxuICBjb25zdCBvbklucHV0RXZlbnQgPSBuZXcgRXZlbnQoXCJpbnB1dFwiLCB7XG4gICAgYnViYmxlczogdHJ1ZVxuICB9KTtcbiAgb25JbnB1dEV2ZW50LnNpbXVsYXRlZCA9IHRydWU7XG4gIGlucHV0LmRpc3BhdGNoRXZlbnQob25JbnB1dEV2ZW50KTtcbiAgY29uc3Qgb25DaGFuZ2VFdmVudCA9IG5ldyBFdmVudChcImNoYW5nZVwiLCB7XG4gICAgYnViYmxlczogdHJ1ZVxuICB9KTtcbiAgb25DaGFuZ2VFdmVudC5zaW11bGF0ZWQgPSB0cnVlO1xuICBpbnB1dC5kaXNwYXRjaEV2ZW50KG9uQ2hhbmdlRXZlbnQpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFNpemUoZWxlbWVudCwgZGVlcCA9IGZhbHNlKSB7XG4gIGxldCB3aWR0aDtcbiAgbGV0IGhlaWdodDtcbiAgY29uc3QgZWxlbWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAoZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtZW50UmVjdC5oZWlnaHQgPT09IDAgJiYgZWxlbWVudFJlY3Qud2lkdGggPT09IDApIHtcbiAgICBjb25zdCBjbG9uZSA9IGVsZW1lbnQuY2xvbmVOb2RlKGRlZXApO1xuICAgIGVsZW1lbnQucGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgY2xvbmUuc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgY29uc3QgY2xvbmVSZWN0ID0gY2xvbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgd2lkdGggPSBjbG9uZVJlY3Qud2lkdGg7XG4gICAgaGVpZ2h0ID0gY2xvbmVSZWN0LmhlaWdodDtcbiAgICBjbG9uZS5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgIGNsb25lLnJlbW92ZSgpO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gZWxlbWVudFJlY3Qud2lkdGg7XG4gICAgaGVpZ2h0ID0gZWxlbWVudFJlY3QuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBNYXRoLmZsb29yKGhlaWdodCksXG4gICAgd2lkdGg6IE1hdGguZmxvb3Iod2lkdGgpXG4gIH07XG59XG5mdW5jdGlvbiBhZGREb2N1bWVudFN0eWxlKGNzcykge1xuICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuaW5uZXJIVE1MID0gY3NzO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NsYXNzX25hbWVfdHJhbnNmb3JtZXJzLnRzXG52YXIgSURFTlRJRklFUl9SRUdFWCA9IG5ldyBSZWdFeHAoXCJbX2EtekEtWl0rW19hLXpBLVowLTktXSpcIiwgXCJnXCIpO1xudmFyIENMQVNTX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKGBcXFxcLiR7SURFTlRJRklFUl9SRUdFWC5zb3VyY2V9YCwgXCJnXCIpO1xudmFyIENPTkRJVElPTl9SVUxFX1JFR0VYID0gbmV3IFJlZ0V4cChgXlxcXFxzKihAKD86bWVkaWF8c3VwcG9ydHMpW157XSopeyguKil9XFxcXHMqJGApO1xuZnVuY3Rpb24gdHJhbnNmb3JtQ2xhc3NTZWxlY3RvcnMoY3NzLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGNzcy5yZXBsYWNlKENMQVNTX05BTUVfUkVHRVgsIChjbGFzc05hbWUpID0+IHtcbiAgICByZXR1cm4gXCIuXCIgKyB0cmFuc2Zvcm0oY2xhc3NOYW1lLnNsaWNlKDEpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1DU1NDbGFzc1J1bGVzKHRleHQsIHRyYW5zZm9ybSkge1xuICBjb25zdCBzaGVldCA9IGNyZWF0ZUNTU1N0eWxlU2hlZXQodGV4dCk7XG4gIGNvbnN0IHJ1bGVzID0gc2hlZXQuY3NzUnVsZXM7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUNTU1J1bGUocnVsZSkge1xuICAgIGlmIChydWxlIGluc3RhbmNlb2YgQ1NTU3R5bGVSdWxlKSB7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IHRyYW5zZm9ybUNsYXNzU2VsZWN0b3JzKHJ1bGUuc2VsZWN0b3JUZXh0LCB0cmFuc2Zvcm0pO1xuICAgICAgcmV0dXJuIGAke3NlbGVjdG9yfSB7ICR7cnVsZS5zdHlsZS5jc3NUZXh0fSB9YDtcbiAgICB9XG4gICAgY29uc3QgYXRSdWxlID0gQ09ORElUSU9OX1JVTEVfUkVHRVguZXhlYyhydWxlLmNzc1RleHQuc3BsaXQoXCJcXG5cIikuam9pbihcIlwiKSk7XG4gICAgaWYgKGF0UnVsZSAmJiBhdFJ1bGUubGVuZ3RoID4gMikge1xuICAgICAgY29uc3QgcnVsZTIgPSBhdFJ1bGVbMV07XG4gICAgICBjb25zdCBjb250ZW50cyA9IGF0UnVsZVsyXTtcbiAgICAgIHJldHVybiBgJHtydWxlMn0geyAke3RyYW5zZm9ybUNTU0NsYXNzUnVsZXMoY29udGVudHMsIHRyYW5zZm9ybSl9IH1gO1xuICAgIH1cbiAgICByZXR1cm4gcnVsZS5jc3NUZXh0O1xuICB9XG4gIGxldCBzdHlsZSA9IFwiXCI7XG4gIGZvciAoY29uc3QgcnVsZSBvZiBBcnJheS5mcm9tKHJ1bGVzKSkge1xuICAgIHN0eWxlICs9IHRyYW5zZm9ybUNTU1J1bGUocnVsZSkgKyBcIlxcblxcblwiO1xuICB9XG4gIHJldHVybiBzdHlsZS50cmltKCk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1ET01DbGFzc0F0dHJpYnV0ZXMoY29udGVudCwgdHJhbnNmb3JtKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gQXJyYXkuZnJvbShjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbY2xhc3NdXCIpKTtcbiAgZWxlbWVudHMucHVzaChjb250ZW50KTtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgY29uc3QgeyBjbGFzc0xpc3QgfSA9IGVsZW1lbnQ7XG4gICAgZm9yIChjb25zdCBjbGFzc05hbWUgb2YgQXJyYXkuZnJvbShjbGFzc0xpc3QpKSB7XG4gICAgICBjbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICBjbGFzc0xpc3QuYWRkKHRyYW5zZm9ybShjbGFzc05hbWUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8vIHNyYy91dGlscy9pbmRleC50c1xuaW1wb3J0IHsgU2Vzc2lvblRva2VuIH0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcblxuLy8gc3JjL3V0aWxzL21hcC50c1xudmFyIEZMWV9UT19TUEVFRCA9IDEuNDtcbmZ1bmN0aW9uIGJib3hWaWV3cG9ydChtYXAsIGJvdW5kcywgZGVsdGEgPSAwLjUpIHtcbiAgY29uc3QgeyBjZW50ZXIsIHpvb20gfSA9IG1hcC5jYW1lcmFGb3JCb3VuZHMoYm91bmRzKTtcbiAgY29uc3QgdHJhbnNmb3JtZWRab29tID0gTWF0aC5tYXgoem9vbSAtIGRlbHRhLCAwKTtcbiAgcmV0dXJuIHtcbiAgICBjZW50ZXIsXG4gICAgem9vbTogdHJhbnNmb3JtZWRab29tLFxuICAgIHNwZWVkOiBGTFlfVE9fU1BFRURcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE1heFpvb20ocGxhY2VUeXBlKSB7XG4gIHN3aXRjaCAocGxhY2VUeXBlKSB7XG4gICAgY2FzZSBcInN0cmVldFwiOlxuICAgICAgcmV0dXJuIDE1O1xuICAgIGNhc2UgXCJsb2NhbGl0eVwiOlxuICAgIGNhc2UgXCJvYXphXCI6XG4gICAgICByZXR1cm4gMTQ7XG4gICAgY2FzZSBcInBsYWNlXCI6XG4gICAgY2FzZSBcImNpdHlcIjpcbiAgICAgIHJldHVybiAxMztcbiAgICBjYXNlIFwiZGlzdHJpY3RcIjpcbiAgICAgIHJldHVybiA5O1xuICAgIGNhc2UgXCJyZWdpb25cIjpcbiAgICBjYXNlIFwicHJlZmVjdHVyZVwiOlxuICAgICAgcmV0dXJuIDY7XG4gICAgY2FzZSBcImNvdW50cnlcIjpcbiAgICAgIHJldHVybiA0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMTY7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN0YXRpY0Jhc2VVcmwodXNlcm5hbWUsIHN0eWxlSWQpIHtcbiAgcmV0dXJuIGBodHRwczovL2FwaS5tYXBib3guY29tL3N0eWxlcy92MS8ke3VzZXJuYW1lfS8ke3N0eWxlSWR9L3N0YXRpYy9gO1xufVxuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgU1RBVElDX0JBU0VfVVJMX1NBVEVMTElURSA9IGdldFN0YXRpY0Jhc2VVcmwoXCJtYXBib3hcIiwgXCJzYXRlbGxpdGUtc3RyZWV0cy12MTFcIik7XG52YXIgQVVUT0ZJTExfU0tVX1RPS0VOX1BSRUZJWCA9IFwiMjBkMDFcIjtcbnZhciBNQVBCT1hfRE9NQUlOUyA9IFtcIm1hcGJveC5jb21cIiwgXCJtYXBib3guY25cIiwgXCJ0aWxlc3RyZWFtLm5ldFwiXTtcblxuLy8gc3JjL3V0aWxzL2luZGV4LnRzXG5mdW5jdGlvbiByYW5kb21WYWxpZElEKCkge1xuICByZXR1cm4gYG1ieGAgKyBuZXcgU2Vzc2lvblRva2VuKCkuaWQuc2xpY2UoMCwgOCk7XG59XG5mdW5jdGlvbiB0cnlQYXJzZUpTT04oanNvbikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZXBFcXVhbHMoYSwgYikge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIGlmICh0eXBlb2YgYSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gIGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBhS2V5cykge1xuICAgIGlmICghZGVlcEVxdWFscyhhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByb3VuZChudW0sIGRlY2ltYWxQbGFjZXMpIHtcbiAgY29uc3QgZmFjdG9yT2ZUZW4gPSBNYXRoLnBvdygxMCwgZGVjaW1hbFBsYWNlcyk7XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIGZhY3Rvck9mVGVuKSAvIGZhY3Rvck9mVGVuO1xufVxuZnVuY3Rpb24gaXNMb2NhbFNlcnZlcihob3N0bmFtZSkge1xuICByZXR1cm4gQm9vbGVhbihob3N0bmFtZS5tYXRjaCgvbG9jYWxob3N0fFswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM318OjoxfFxcLmxvY2FsfF4kL2dpKSk7XG59XG5mdW5jdGlvbiBpc01hcGJveERvbWFpbihob3N0bmFtZSkge1xuICByZXR1cm4gQm9vbGVhbihNQVBCT1hfRE9NQUlOUy5zb21lKChkb21haW4pID0+IGhvc3RuYW1lLmluY2x1ZGVzKGRvbWFpbikpKTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvSFRNTFNjb3BlZEVsZW1lbnQudHNcbnZhciBfc2VlZCwgX3RlbXBsYXRlVXNlclN0eWxlRWxlbWVudCwgX3RyYW5zZm9ybTtcbnZhciBIVE1MU2NvcGVkRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2VlZCwgcmFuZG9tVmFsaWRJRCgpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3RlbXBsYXRlVXNlclN0eWxlRWxlbWVudCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3RyYW5zZm9ybSwgKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGAke19fcHJpdmF0ZUdldCh0aGlzLCBfc2VlZCl9LS0ke2NsYXNzTmFtZX1gO1xuICAgIH0pO1xuICB9XG4gIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgdGVtcGxhdGVTdHlsZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgdGVtcGxhdGVVc2VyU3R5bGUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY2xvbmVkQ2FsbGJhY2sob2xkU2VlZCwgbmV3U2VlZCkge1xuICAgIGNvbnN0IHNlZWRUcmFuc2Zvcm0gPSAoY2xhc3NOYW1lKSA9PiBjbGFzc05hbWUucmVwbGFjZShvbGRTZWVkLCBuZXdTZWVkKTtcbiAgICB0cmFuc2Zvcm1ET01DbGFzc0F0dHJpYnV0ZXModGhpcywgc2VlZFRyYW5zZm9ybSk7XG4gICAgY29uc3Qgc3R5bGVzID0gQXJyYXkuZnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVwiKSk7XG4gICAgZm9yIChjb25zdCBzdHlsZSBvZiBzdHlsZXMpIHtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gdHJhbnNmb3JtQ2xhc3NTZWxlY3RvcnMoc3R5bGUudGV4dENvbnRlbnQsIHNlZWRUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoc3R5bGVzLmxlbmd0aCkge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF90ZW1wbGF0ZVVzZXJTdHlsZUVsZW1lbnQsIHN0eWxlc1tzdHlsZXMubGVuZ3RoIC0gMV0pO1xuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5jaGlsZEVsZW1lbnRDb3VudCA+IDApIHtcbiAgICAgIGNvbnN0IG9sZFNlZWQgPSB0aGlzLmRhdGFzZXQuc2VlZDtcbiAgICAgIGNvbnN0IG5ld1NlZWQgPSBfX3ByaXZhdGVHZXQodGhpcywgX3NlZWQpO1xuICAgICAgaWYgKG9sZFNlZWQgJiYgb2xkU2VlZCAhPT0gbmV3U2VlZCkge1xuICAgICAgICB0aGlzLmNsb25lZENhbGxiYWNrKG9sZFNlZWQsIG5ld1NlZWQpO1xuICAgICAgICB0aGlzLmRhdGFzZXQuc2VlZCA9IG5ld1NlZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGF0YXNldC5zZWVkID0gX19wcml2YXRlR2V0KHRoaXMsIF9zZWVkKTtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5wcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gICAgY29uc3QgdGVtcGxhdGVTdHlsZSA9IHRoaXMudGVtcGxhdGVTdHlsZTtcbiAgICBpZiAodGVtcGxhdGVTdHlsZSkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRoaXMucHJlcGFyZUNTUyh0ZW1wbGF0ZVN0eWxlKTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgICBjb25zdCB1c2VyU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgaWYgKHRoaXMudGVtcGxhdGVVc2VyU3R5bGUpIHtcbiAgICAgIHVzZXJTdHlsZS50ZXh0Q29udGVudCA9IHRoaXMucHJlcGFyZUNTUyh0aGlzLnRlbXBsYXRlVXNlclN0eWxlKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmRDaGlsZCh1c2VyU3R5bGUpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdGVtcGxhdGVVc2VyU3R5bGVFbGVtZW50LCB1c2VyU3R5bGUpO1xuICB9XG4gIHByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkO1xuICAgIHJldHVybiB0cmFuc2Zvcm1ET01DbGFzc0F0dHJpYnV0ZXMoZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSksIF9fcHJpdmF0ZUdldCh0aGlzLCBfdHJhbnNmb3JtKSk7XG4gIH1cbiAgcHJlcGFyZUNTUyhjc3MpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtQ1NTQ2xhc3NSdWxlcyhjc3MsIF9fcHJpdmF0ZUdldCh0aGlzLCBfdHJhbnNmb3JtKSk7XG4gIH1cbiAgdXBkYXRlVGVtcGxhdGVVc2VyU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfdGVtcGxhdGVVc2VyU3R5bGVFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3RlbXBsYXRlVXNlclN0eWxlRWxlbWVudCkudGV4dENvbnRlbnQgPSB0aGlzLnByZXBhcmVDU1Moc3R5bGUpO1xuICB9XG4gIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JzKSB7XG4gICAgcmV0dXJuIHN1cGVyLnF1ZXJ5U2VsZWN0b3IodHJhbnNmb3JtQ2xhc3NTZWxlY3RvcnMoc2VsZWN0b3JzLCBfX3ByaXZhdGVHZXQodGhpcywgX3RyYW5zZm9ybSkpKTtcbiAgfVxuICBxdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9ycykge1xuICAgIHJldHVybiBzdXBlci5xdWVyeVNlbGVjdG9yQWxsKHRyYW5zZm9ybUNsYXNzU2VsZWN0b3JzKHNlbGVjdG9ycywgX19wcml2YXRlR2V0KHRoaXMsIF90cmFuc2Zvcm0pKSk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBzdXBlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgfVxuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHN1cGVyLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG59O1xuX3NlZWQgPSBuZXcgV2Vha01hcCgpO1xuX3RlbXBsYXRlVXNlclN0eWxlRWxlbWVudCA9IG5ldyBXZWFrTWFwKCk7XG5fdHJhbnNmb3JtID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gc3JjL01hcGJveEhUTUxFdmVudC50c1xudmFyIE1hcGJveEhUTUxFdmVudCA9IGNsYXNzIGV4dGVuZHMgQ3VzdG9tRXZlbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBkZXRhaWwpIHtcbiAgICBzdXBlcih0eXBlLCB7XG4gICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgIGRldGFpbFxuICAgIH0pO1xuICB9XG4gIGNsb25lKG5ld1RhcmdldCkge1xuICAgIGNvbnN0IGV2ZW50Q2xvbmUgPSBuZXcgTWFwYm94SFRNTEV2ZW50KHRoaXMudHlwZSwgdGhpcy5kZXRhaWwpO1xuICAgIGlmIChuZXdUYXJnZXQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudENsb25lLCBcInRhcmdldFwiLCB7IHZhbHVlOiBuZXdUYXJnZXQgfSk7XG4gICAgfVxuICAgIHJldHVybiBldmVudENsb25lO1xuICB9XG59O1xuXG4vLyBzcmMvaWNvbnMvY2xvc2Uuc3ZnXG52YXIgY2xvc2VfZGVmYXVsdCA9ICc8c3ZnIHZpZXdCb3g9XCIwIDAgMTggMThcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTMuOCAzLjhhMSAxIDAgMCAxIDEuNCAwTDkgNy41OGwzLjgtMy44YTEgMSAwIDEgMSAxLjQgMS40MkwxMC40MiA5bDMuOCAzLjhhMSAxIDAgMCAxLTEuNDIgMS40TDkgMTAuNDJsLTMuOCAzLjhhMSAxIDAgMCAxLTEuNC0xLjQyTDcuNTggOWwtMy44LTMuOGExIDEgMCAwIDEgMC0xLjRaXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiLz48L3N2Zz4nO1xuXG4vLyBzcmMvaWNvbnMvcXVlc3Rpb24uc3ZnXG52YXIgcXVlc3Rpb25fZGVmYXVsdCA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiIHN0YW5kYWxvbmU9XCJ5ZXNcIj8+PHN2ZyB2aWV3Qm94PVwiMCAwIDE4IDE4XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgZD1cIk05IDE2QTcgNyAwIDEgMCA5IDJhNyA3IDAgMCAwIDAgMTRaTTYuODggNC44OGEyLjU4IDIuNTggMCAwIDEgMS44My0uNzVoMS4wOGEyLjU4IDIuNTggMCAwIDEgMi41OSAyLjU4di4xNmMwIDEtLjUzIDEuOTQtMS40IDIuNDZsLS41Ni4zNGMtLjI3LjE2LS40NS40Mi0uNTIuNzEtLjAzLjE0LS4xNC4yNS0uMjguMjVIOC4zOGEuMjMuMjMgMCAwIDEtLjI0LS4yNWMuMDgtLjkxLjU5LTEuNzQgMS4zOC0yLjIxbC41Ni0uMzRjLjM0LS4yLjU0LS41Ny41NC0uOTZWNi43YS44My44MyAwIDAgMC0uODMtLjgzSDguNzFhLjgzLjgzIDAgMCAwLS44NC44M3YuMThhLjg3Ljg3IDAgMSAxLTEuNzUgMFY2LjdjMC0uNjkuMjgtMS4zNC43Ni0xLjgzWk0xMCAxM2ExIDEgMCAxIDEtMiAwIDEgMSAwIDAgMSAyIDBaXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiLz48L3N2Zz4nO1xuXG4vLyBzcmMvaWNvbnMvbWFya2VyLnN2Z1xudmFyIG1hcmtlcl9kZWZhdWx0ID0gJzxzdmcgd2lkdGg9XCI0OFwiIGhlaWdodD1cIjU2XCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PGcgZmlsdGVyPVwidXJsKCNhKVwiPjxwYXRoIGQ9XCJtMjQgNTAuNCAxMy43OS0xNC4xMmExOC44MiAxOC44MiAwIDAgMCA0LjIzLTIwLjg2IDE5LjIzIDE5LjIzIDAgMCAwLTcuMTktOC42IDE5Ljc2IDE5Ljc2IDAgMCAwLTIxLjY2IDBjLTMuMjEgMi4xMS01LjcxIDUuMS03LjE5IDguNmExOC44MiAxOC44MiAwIDAgMCA0LjIzIDIwLjg2TDI0IDUwLjRaXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiLz48cGF0aCBkPVwiTTM3LjI2IDM1Ljc1IDI0IDQ5LjM0IDEwLjc1IDM1Ljc2bC0uMDEtLjAxQTE4LjA3IDE4LjA3IDAgMCAxIDYuNjggMTUuN2ExOC40OCAxOC40OCAwIDAgMSA2LjktOC4yNiAxOSAxOSAwIDAgMSAyMC44NCAwIDE4LjQ4IDE4LjQ4IDAgMCAxIDYuOSA4LjI2IDE4LjA3IDE4LjA3IDAgMCAxLTQuMDYgMjAuMDRaXCIgc3Ryb2tlPVwiI2ZmZlwiIHN0cm9rZS13aWR0aD1cIjEuNVwiLz48L2c+PGNpcmNsZSBjeD1cIjI0XCIgY3k9XCIyMi40NVwiIGZpbGw9XCIjZmZmXCIgcj1cIjUuODVcIi8+PGRlZnM+PGZpbHRlciBpZD1cImFcIiB4PVwiLjVcIiB5PVwiLjZcIiB3aWR0aD1cIjQ3XCIgaGVpZ2h0PVwiNTQuOFwiIGZpbHRlclVuaXRzPVwidXNlclNwYWNlT25Vc2VcIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9XCJzUkdCXCI+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT1cIjBcIiByZXN1bHQ9XCJCYWNrZ3JvdW5kSW1hZ2VGaXhcIi8+PGZlQ29sb3JNYXRyaXggaW49XCJTb3VyY2VBbHBoYVwiIHZhbHVlcz1cIjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwXCIgcmVzdWx0PVwiaGFyZEFscGhhXCIvPjxmZU9mZnNldCBkeT1cIjFcIi8+PGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj1cIjJcIi8+PGZlQ29sb3JNYXRyaXggdmFsdWVzPVwiMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMC4yIDBcIi8+PGZlQmxlbmQgaW4yPVwiQmFja2dyb3VuZEltYWdlRml4XCIgcmVzdWx0PVwiZWZmZWN0MV9kcm9wU2hhZG93XzE3Xzg3MVwiLz48ZmVCbGVuZCBpbj1cIlNvdXJjZUdyYXBoaWNcIiBpbjI9XCJlZmZlY3QxX2Ryb3BTaGFkb3dfMTdfODcxXCIgcmVzdWx0PVwic2hhcGVcIi8+PC9maWx0ZXI+PC9kZWZzPjwvc3ZnPic7XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIHZlcnNpb24gPSBcIjEuMC4wLWJldGEuMTNcIjtcblxuLy8gc3JjL3RoZW1lLnRzXG52YXIgc3R5bGVUb2dnbGVTYXRlbGxpdGVJbWcgPSBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9zZWFyY2gtanMvdiR7dmVyc2lvbn0vaW1nL3N0eWxlLXRvZ2dsZS1zYXRlbGxpdGUuanBnYDtcbnZhciBzdHlsZVRvZ2dsZURlZmF1bHRJbWcgPSBgaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9zZWFyY2gtanMvdiR7dmVyc2lvbn0vaW1nL3N0eWxlLXRvZ2dsZS1kZWZhdWx0LmpwZ2A7XG52YXIgTU9CSUxFX0JSRUFLUE9JTlQgPSA3NjggLSAxO1xudmFyIE1PQklMRV9NRURJQV9RVUVSWSA9IGBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6ICR7TU9CSUxFX0JSRUFLUE9JTlR9cHgpYDtcbnZhciBERUZBVUxUX1RIRU1FID0ge1xuICB2YXJpYWJsZXM6IHtcbiAgICB1bml0OiBbXCJtb2JpbGVcIiwgXCIxNnB4XCIsIFwiMTRweFwiXSxcbiAgICB1bml0SGVhZGVyOiBbXCJtb2JpbGVcIiwgXCIyNHB4XCIsIFwiMThweFwiXSxcbiAgICBtaW5XaWR0aDogXCJtaW4oMzAwcHgsIDEwMHZ3KVwiLFxuICAgIHNwYWNpbmc6IFwiMC43NWVtXCIsXG4gICAgcGFkZGluZzogXCIwLjVlbSAwLjc1ZW1cIixcbiAgICBwYWRkaW5nTW9kYWw6IFwiMS4yNWVtXCIsXG4gICAgY29sb3JUZXh0OiBcInJnYmEoMCwgMCwgMCwgMC43NSlcIixcbiAgICBjb2xvclByaW1hcnk6IFwiIzQyNjRGQlwiLFxuICAgIGNvbG9yU2Vjb25kYXJ5OiBcIiM2NjdGOTFcIixcbiAgICBjb2xvckJhY2tncm91bmQ6IFwiI2ZmZlwiLFxuICAgIGNvbG9yQmFja2dyb3VuZEhvdmVyOiBcIiNmNWY1ZjVcIixcbiAgICBjb2xvckJhY2tncm91bmRBY3RpdmU6IFwiI2YwZjBmMFwiLFxuICAgIGNvbG9yQmFja2Ryb3A6IFwicmdiYSgxMDIsIDEyNywgMTQ1LCAwLjMpXCIsXG4gICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICBib3JkZXJSYWRpdXM6IFwiNHB4XCIsXG4gICAgYm94U2hhZG93OiBgXG4gICAgICAwIDAgMTBweCAycHggcmdiYSgwLCAwLCAwLCAwLjA1KSxcbiAgICAgIDAgMCA2cHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xKSxcbiAgICAgIDAgMCAwIDFweCByZ2JhKDAsIDAsIDAsIDAuMSlcbiAgICBgLFxuICAgIGxpbmVIZWlnaHQ6IFwiMS4yZW1cIixcbiAgICBmb250RmFtaWx5OiBgXG4gICAgICAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsXG4gICAgICBhdmVuaXIgbmV4dCwgYXZlbmlyLFxuICAgICAgc2Vnb2UgdWksXG4gICAgICBoZWx2ZXRpY2EgbmV1ZSwgaGVsdmV0aWNhLFxuICAgICAgVWJ1bnR1LCByb2JvdG8sIG5vdG8sIGFyaWFsLCBzYW5zLXNlcmlmXG4gICAgYCxcbiAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICAgIGZvbnRXZWlnaHRTZW1pYm9sZDogXCI2MDBcIixcbiAgICBmb250V2VpZ2h0Qm9sZDogXCJib2xkXCIsXG4gICAgZHVyYXRpb246IFwiMTUwbXNcIixcbiAgICBjdXJ2ZTogXCJlYXNlLW91dFwiXG4gIH0sXG4gIGljb25zOiB7XG4gICAgY2xvc2U6IGNsb3NlX2RlZmF1bHQsXG4gICAgcXVlc3Rpb246IHF1ZXN0aW9uX2RlZmF1bHQsXG4gICAgbWFya2VyOiBtYXJrZXJfZGVmYXVsdFxuICB9LFxuICBpbWFnZXM6IHtcbiAgICBzdHlsZVRvZ2dsZURlZmF1bHQ6IHN0eWxlVG9nZ2xlRGVmYXVsdEltZyxcbiAgICBzdHlsZVRvZ2dsZVNhdGVsbGl0ZTogc3R5bGVUb2dnbGVTYXRlbGxpdGVJbWdcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFRoZW1lQ1NTKHJvb3RTZWxlY3RvciwgdGhlbWUgPSB7fSkge1xuICBjb25zdCB2YXJpYWJsZXMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgREVGQVVMVF9USEVNRS52YXJpYWJsZXMpLCB0aGVtZS52YXJpYWJsZXMgfHwge30pO1xuICBsZXQgY3NzVGV4dCA9IHRoZW1lLmNzc1RleHQgfHwgXCJcIjtcbiAgbGV0IHJvb3RWYXJpYWJsZXMgPSBcIlwiO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YXJpYWJsZXMpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcm9vdFZhcmlhYmxlcyArPSBgLS0ke2tleX06ICR7dmFsdWV9O2A7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlWzBdICE9PSBcIm1vYmlsZVwiKSB7XG4gICAgICBjb25zdCB2YWx1ZVN0ciA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZXhwcmVzc2lvbiBpbiB0aGVtZSB2YXJpYWJsZXM6ICR7a2V5fSAke3ZhbHVlU3RyfWApO1xuICAgIH1cbiAgICBjb25zdCBbLCBtb2JpbGVWYWx1ZSwgZGVza3RvcFZhbHVlXSA9IHZhbHVlO1xuICAgIGNzc1RleHQgKz0gYCR7TU9CSUxFX01FRElBX1FVRVJZfSB7ICR7cm9vdFNlbGVjdG9yfSB7IC0tJHtrZXl9OiAke21vYmlsZVZhbHVlfSAhaW1wb3J0YW50OyB9IH1gO1xuICAgIHJvb3RWYXJpYWJsZXMgKz0gYC0tJHtrZXl9OiAke2Rlc2t0b3BWYWx1ZX07YDtcbiAgfVxuICByZXR1cm4gY3NzVGV4dCArIGAke3Jvb3RTZWxlY3Rvcn0geyAke3Jvb3RWYXJpYWJsZXN9IH1gO1xufVxuZnVuY3Rpb24gZ2V0SWNvbihpY29uTmFtZSwgdGhlbWUgPSB7fSkge1xuICBjb25zdCBpY29ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBERUZBVUxUX1RIRU1FLmljb25zKSwgdGhlbWUuaWNvbnMgfHwge30pO1xuICBjb25zdCBzdmdTdHJpbmcgPSBpY29uc1tpY29uTmFtZV07XG4gIHJldHVybiBzdmdTdHJpbmc7XG59XG5mdW5jdGlvbiBnZXRJbWFnZShpbWFnZU5hbWUsIHRoZW1lID0ge30pIHtcbiAgY29uc3QgaW1hZ2VzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIERFRkFVTFRfVEhFTUUuaW1hZ2VzKSwgdGhlbWUuaW1hZ2VzIHx8IHt9KTtcbiAgY29uc3QgaW1nU3RyaW5nID0gaW1hZ2VzW2ltYWdlTmFtZV07XG4gIHJldHVybiBpbWdTdHJpbmc7XG59XG5cbi8vIHNyYy91dGlscy9wb3BvdmVyLnRzXG5pbXBvcnQge1xuICBjb21wdXRlUG9zaXRpb24sXG4gIGF1dG9VcGRhdGUsXG4gIGZsaXAsXG4gIG9mZnNldFxufSBmcm9tIFwiQGZsb2F0aW5nLXVpL2RvbVwiO1xudmFyIF9vcHRpb25zLCBfZGVmYXVsdE9wdGlvbnM7XG52YXIgUG9wb3ZlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocmVmZXJlbmNlRWwsIGZsb2F0aW5nRWwsIG9wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29wdGlvbnMsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9kZWZhdWx0T3B0aW9ucywge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiLFxuICAgICAgZmxpcDogZmFsc2UsXG4gICAgICBvZmZzZXQ6IDEwXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGUgPSAoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBjb25maWcyID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IHRoaXMub3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmU6IFtcbiAgICAgICAgICBvZmZzZXQodGhpcy5vcHRpb25zLm9mZnNldCksXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZsaXAgJiYgZmxpcCgpXG4gICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pXG4gICAgICB9O1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSB5aWVsZCBjb21wdXRlUG9zaXRpb24odGhpcy5yZWZlcmVuY2VFbCwgdGhpcy5mbG9hdGluZ0VsLCBjb25maWcyKTtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5mbG9hdGluZ0VsLnN0eWxlLCB7XG4gICAgICAgIGxlZnQ6IGAke3h9cHhgLFxuICAgICAgICB0b3A6IGAke3l9cHhgXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZmVyZW5jZUVsID0gcmVmZXJlbmNlRWw7XG4gICAgdGhpcy5mbG9hdGluZ0VsID0gZmxvYXRpbmdFbDtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29wdGlvbnMsIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBfX3ByaXZhdGVHZXQodGhpcywgX2RlZmF1bHRPcHRpb25zKSksIG9wdGlvbnMpKTtcbiAgICB0aGlzLmRlc3Ryb3kgPSBhdXRvVXBkYXRlKHRoaXMucmVmZXJlbmNlRWwsIHRoaXMuZmxvYXRpbmdFbCwgdGhpcy51cGRhdGUpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX29wdGlvbnMpO1xuICB9XG4gIHNldCBvcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29wdGlvbnMsIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBfX3ByaXZhdGVHZXQodGhpcywgX29wdGlvbnMpKSwgbmV3T3B0aW9ucykpO1xuICB9XG59O1xuX29wdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuX2RlZmF1bHRPcHRpb25zID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gc3JjL3N0eWxlLmNzc1xudmFyIHN0eWxlX2RlZmF1bHQgPSBcIip7Ym94LXNpemluZzpib3JkZXItYm94IWltcG9ydGFudH1bcm9sZT1idXR0b25de2N1cnNvcjpwb2ludGVyfS5NYXBib3hTZWFyY2h7LS13aWR0aDowO2Rpc3BsYXk6bm9uZX0uUmVzdWx0c3tiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yQmFja2dyb3VuZCk7Ym9yZGVyOnZhcigtLWJvcmRlcik7Ym9yZGVyLXJhZGl1czp2YXIoLS1ib3JkZXJSYWRpdXMpO2JveC1zaGFkb3c6dmFyKC0tYm94U2hhZG93KTtjb2xvcjp2YXIoLS1jb2xvclRleHQpO2ZvbnQtZmFtaWx5OnZhcigtLWZvbnRGYW1pbHkpO2ZvbnQtc2l6ZTp2YXIoLS11bml0KTtmb250LXdlaWdodDp2YXIoLS1mb250V2VpZ2h0KTtsaW5lLWhlaWdodDp2YXIoLS1saW5lSGVpZ2h0KTttaW4td2lkdGg6dmFyKC0tbWluV2lkdGgpO292ZXJmbG93LXk6YXV0bztwb3NpdGlvbjphYnNvbHV0ZTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKTt0cmFuc2l0aW9uOnZpc2liaWxpdHkgdmFyKC0tZHVyYXRpb24pO3dpZHRoOnZhcigtLXdpZHRoKTt6LWluZGV4OjEwMDB9LlJlc3VsdHM6bm90KFthcmlhLWhpZGRlbj10cnVlXSl7dmlzaWJpbGl0eTp2aXNpYmxlfS5SZXN1bHRzW2FyaWEtaGlkZGVuPXRydWVde2FuaW1hdGlvbjpmYWRlaW4gdmFyKC0tZHVyYXRpb24pIHZhcigtLWN1cnZlKSByZXZlcnNlIGZvcndhcmRzO3Zpc2liaWxpdHk6aGlkZGVufS5TdWdnZXN0aW9ue3BhZGRpbmc6dmFyKC0tcGFkZGluZyl9LlN1Z2dlc3Rpb246aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9LlN1Z2dlc3Rpb25bYXJpYS1zZWxlY3RlZD10cnVlXXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yQmFja2dyb3VuZEhvdmVyKX0uU3VnZ2VzdGlvbjphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvckJhY2tncm91bmRBY3RpdmUpfS5TdWdnZXN0aW9uTmFtZXtmb250LXdlaWdodDp2YXIoLS1mb250V2VpZ2h0Qm9sZCl9LlJlc3VsdHNBdHRyaWJ1dGlvbntwYWRkaW5nOnZhcigtLXBhZGRpbmcpfS5SZXN1bHRzQXR0cmlidXRpb24gYXtjb2xvcjp2YXIoLS1jb2xvclNlY29uZGFyeSl9LlJlc3VsdHNBdHRyaWJ1dGlvbiBhOm5vdCg6aG92ZXIpe3RleHQtZGVjb3JhdGlvbjpub25lfS5SZXN1bHRzTGlzdHtsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowfS5MYWJlbHtkaXNwbGF5Om5vbmV9LklucHV0e2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3JCYWNrZ3JvdW5kKTtib3JkZXI6dmFyKC0tYm9yZGVyKTtib3JkZXItcmFkaXVzOnZhcigtLWJvcmRlclJhZGl1cyk7Ym94LXNoYWRvdzp2YXIoLS1ib3hTaGFkb3cpO2NvbG9yOnZhcigtLWNvbG9yVGV4dCk7Zm9udC1mYW1pbHk6dmFyKC0tZm9udEZhbWlseSk7Zm9udC1zaXplOnZhcigtLXVuaXQpO2ZvbnQtd2VpZ2h0OnZhcigtLWZvbnRXZWlnaHQpO2xpbmUtaGVpZ2h0OnZhcigtLWxpbmVIZWlnaHQpO3BhZGRpbmc6dmFyKC0tcGFkZGluZyk7d2lkdGg6MTAwJX1tYXBib3gtYWRkcmVzcy1jb25maXJtYXRpb24tZmVhdHVyZVthcmlhLWhpZGRlbj10cnVlXSxtYXBib3gtYWRkcmVzcy1jb25maXJtYXRpb24tbm8tZmVhdHVyZVthcmlhLWhpZGRlbj10cnVlXXtkaXNwbGF5Om5vbmV9Lk1hcGJveEFkZHJlc3NDb25maXJtYXRpb257YWxpZ24taXRlbXM6Y2VudGVyO2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3JCYWNrZHJvcCk7Ym90dG9tOjA7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7bGVmdDowO3Bvc2l0aW9uOmZpeGVkO3JpZ2h0OjA7dG9wOjA7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7ei1pbmRleDoxMDAwfS5NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uOm5vdChbYXJpYS1oaWRkZW49dHJ1ZV0pe2FuaW1hdGlvbjpmYWRlaW4gdmFyKC0tZHVyYXRpb24pIHZhcigtLWN1cnZlKSBmb3J3YXJkczt2aXNpYmlsaXR5OnZpc2libGV9Lk1hcGJveEFkZHJlc3NDb25maXJtYXRpb25bYXJpYS1oaWRkZW49dHJ1ZV17dmlzaWJpbGl0eTpoaWRkZW59LkNvbnRlbnRGZWF0dXJlLC5Db250ZW50Tm9GZWF0dXJle3dpZHRoOnZhcigtLW1pbldpZHRoKX0uTW9kYWx7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvckJhY2tncm91bmQpO2JvcmRlcjp2YXIoLS1ib3JkZXIpO2JvcmRlci1yYWRpdXM6dmFyKC0tYm9yZGVyUmFkaXVzKTtib3gtc2hhZG93OnZhcigtLWJveFNoYWRvdyk7Y29sb3I6dmFyKC0tY29sb3JUZXh0KTtmb250LWZhbWlseTp2YXIoLS1mb250RmFtaWx5KTtmb250LXNpemU6dmFyKC0tdW5pdCk7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udFdlaWdodCk7bGluZS1oZWlnaHQ6dmFyKC0tbGluZUhlaWdodCk7cGFkZGluZzp2YXIoLS1wYWRkaW5nTW9kYWwpO3dpZHRoOjEwMCV9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo0ODBweCl7Lk1hcGJveEFkZHJlc3NDb25maXJtYXRpb257YWxpZ24taXRlbXM6ZmxleC1lbmR9LkNvbnRlbnRGZWF0dXJlLC5Db250ZW50Tm9GZWF0dXJle3dpZHRoOjEwMCV9Lk1vZGFse2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowfX0uTW9kYWxIZWFkZXJ7YWxpZ24taXRlbXM6Y2VudGVyO2NvbG9yOnZhcigtLWNvbG9yUHJpbWFyeSk7ZGlzcGxheTpmbGV4O2ZvbnQtc2l6ZTp2YXIoLS11bml0SGVhZGVyKTtmb250LXdlaWdodDp2YXIoLS1mb250V2VpZ2h0Qm9sZCk7bWFyZ2luLWJvdHRvbTp2YXIoLS1zcGFjaW5nKTt1c2VyLXNlbGVjdDpub25lO3dpZHRoOjEwMCV9Lk1vZGFsTWFwe2hlaWdodDpjYWxjKHZhcigtLW1pbldpZHRoKSo5LzE2KTttYXJnaW4tbGVmdDpjYWxjKHZhcigtLXBhZGRpbmdNb2RhbCkqLTEpO3dpZHRoOmNhbGMoMTAwJSArIHZhcigtLXBhZGRpbmdNb2RhbCkqMil9Lk1vZGFsTWFwW2FyaWEtaGlkZGVuPXRydWVde2Rpc3BsYXk6bm9uZX0uSWNvbntoZWlnaHQ6dmFyKC0tdW5pdEhlYWRlcik7d2lkdGg6dmFyKC0tdW5pdEhlYWRlcil9Lkljb24uSWNvbkNsb3Nle2NvbG9yOnZhcigtLWNvbG9yU2Vjb25kYXJ5KX0uTW9kYWxIZWFkZXJUaXRsZXtmbGV4OjE7bWFyZ2luLWxlZnQ6LjI1ZW19Lk1vZGFsRm9vdGVye2NvbG9yOnZhcigtLWNvbG9yU2Vjb25kYXJ5KTttYXJnaW4tdG9wOnZhcigtLXNwYWNpbmcpO3RleHQtYWxpZ246Y2VudGVyfS5Nb2RhbEZvb3RlclthcmlhLWhpZGRlbj10cnVlXXtkaXNwbGF5Om5vbmV9Lk1vZGFsU3ViaGVhZGVye2ZvbnQtd2VpZ2h0OnZhcigtLWZvbnRXZWlnaHRCb2xkKTt1c2VyLXNlbGVjdDpub25lfS5Nb2RhbERlc2NyaXB0aW9ue2NvbG9yOnZhcigtLWNvbG9yUHJpbWFyeSl9Lk1vZGFsQWRkcmVzcywuTW9kYWxTdWJoZWFkZXJ7bWFyZ2luLWJvdHRvbTp2YXIoLS1zcGFjaW5nKX0uTW9kYWxBZGRyZXNzLk1vZGFsQWRkcmVzc0FwcHJvdmV7Y29sb3I6dmFyKC0tY29sb3JQcmltYXJ5KX0uQnV0dG9ue2JvcmRlci1yYWRpdXM6dmFyKC0tYm9yZGVyUmFkaXVzKTtjdXJzb3I6cG9pbnRlcjtmb250LXdlaWdodDp2YXIoLS1mb250V2VpZ2h0U2VtaWJvbGQpO21hcmdpbi10b3A6dmFyKC0tc3BhY2luZyk7cGFkZGluZzp2YXIoLS1wYWRkaW5nKTt0ZXh0LWFsaWduOmNlbnRlcjt1c2VyLXNlbGVjdDpub25lO3dpZHRoOjEwMCV9LkJ1dHRvblthcmlhLWhpZGRlbj10cnVlXXtkaXNwbGF5Om5vbmV9LkJ1dHRvbi5CdXR0b25QcmltYXJ5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3JQcmltYXJ5KTtjb2xvcjp2YXIoLS1jb2xvckJhY2tncm91bmQpfS5CdXR0b24uQnV0dG9uU2Vjb25kYXJ5e2JvcmRlcjoxcHggc29saWQgdmFyKC0tY29sb3JTZWNvbmRhcnkpO2NvbG9yOnZhcigtLWNvbG9yU2Vjb25kYXJ5KX1Aa2V5ZnJhbWVzIGZhZGVpbnswJXtvcGFjaXR5OjB9dG97b3BhY2l0eToxfX0uTWFwYm94QWRkcmVzc01pbmltYXB7Zm9udC1mYW1pbHk6dmFyKC0tZm9udEZhbWlseSk7Zm9udC1zaXplOnZhcigtLXVuaXQpO2ZvbnQtd2VpZ2h0OnZhcigtLWZvbnRXZWlnaHQpO2xpbmUtaGVpZ2h0OnZhcigtLWxpbmVIZWlnaHQpfS5NYXBib3hBZGRyZXNzTWluaW1hcFthcmlhLWhpZGRlbj10cnVlXXtkaXNwbGF5Om5vbmV9Lk1pbmltYXBJbWFnZUNvbnRhaW5lcntib3JkZXItcmFkaXVzOnZhcigtLWJvcmRlclJhZGl1cyk7b3ZlcmZsb3c6aGlkZGVufS5NaW5pbWFwSW1hZ2V7aGVpZ2h0OnVuc2V0O21heC1oZWlnaHQ6dW5zZXQ7bWF4LXdpZHRoOnVuc2V0O3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOnVuc2V0fS5NaW5pbWFwSW5uZXJGcmFtZXtib3JkZXI6dmFyKC0tYm9yZGVyKTtib3JkZXItcmFkaXVzOmluaGVyaXQ7aGVpZ2h0OmluaGVyaXQ7bGVmdDowO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDt3aWR0aDppbmhlcml0fS5NaW5pbWFwTWFya2Vye2xlZnQ6NTAlO3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCV9Lk1pbmltYXBNYXJrZXI+c3Zne2NvbG9yOnZhcigtLWNvbG9yUHJpbWFyeSk7ZGlzcGxheTpibG9jayFpbXBvcnRhbnR9Lk1pbmltYXBBdHRyaWJ1dGlvbkxvZ297Ym90dG9tOjA7bGVmdDowO21hcmdpbjowIDAgNnB4IDZweDtwb3NpdGlvbjphYnNvbHV0ZX0uTWluaW1hcEF0dHJpYnV0aW9uTG9nbyBhe2N1cnNvcjpwb2ludGVyO2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjIzcHg7d2lkdGg6ODhweH0uTWluaW1hcEF0dHJpYnV0aW9uVGV4dHtiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMCwwJSwxMDAlLC42NSk7Ym90dG9tOjA7Zm9udDoxMXB4LzE2cHggSGVsdmV0aWNhIE5ldWUsQXJpYWwsSGVsdmV0aWNhLHNhbnMtc2VyaWY7cGFkZGluZzowIDVweDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowfS5NaW5pbWFwQXR0cmlidXRpb25UZXh0IGF7Y29sb3I6cmdiYSgwLDAsMCwuNzUpO3RleHQtZGVjb3JhdGlvbjpub25lfS5NaW5pbWFwQXR0cmlidXRpb25UZXh0IGE6aG92ZXJ7Y29sb3I6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS5NaW5pbWFwQXR0cmlidXRpb25UZXh0IGE6bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLWxlZnQ6M3B4fS5NaW5pbWFwU3R5bGVUb2dnbGV7YmFja2dyb3VuZC1wb3NpdGlvbjowO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLXNpemU6Y29udGFpbjtib3JkZXI6MnB4IHNvbGlkICNmZmY7Ym9yZGVyLXJhZGl1czozcHg7Ym94LXNoYWRvdzp2YXIoLS1ib3hTaGFkb3cpO2N1cnNvcjpwb2ludGVyO2hlaWdodDoyZW07cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6dmFyKC0tc3BhY2luZyk7dG9wOnZhcigtLXNwYWNpbmcpO3dpZHRoOjJlbX0uTWluaW1hcEZvb3Rlcntjb2xvcjp2YXIoLS1jb2xvclNlY29uZGFyeSk7Zm9udC1mYW1pbHk6dmFyKC0tZm9udEZhbWlseSk7Zm9udC1zaXplOnZhcigtLXVuaXQpO21hcmdpbi10b3A6dmFyKC0tc3BhY2luZyl9Lk1pbmltYXBGb290ZXJbYXJpYS1oaWRkZW49dHJ1ZV17ZGlzcGxheTpub25lfS5NaW5pbWFwRWRpdEJ1dHRvbnN7Ym90dG9tOjI2cHg7ZGlzcGxheTpmbGV4O2ZvbnQtZmFtaWx5OnZhcigtLWZvbnRGYW1pbHkpO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OnZhcigtLXNwYWNpbmcpfS5NaW5pbWFwRWRpdEJ1dHRvbnMgLkJ1dHRvbntib3gtc2hhZG93OnZhcigtLWJveFNoYWRvdyl9Lk1pbmltYXBCdXR0b25DYW5jZWx7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvckJhY2tncm91bmQpO21hcmdpbi1sZWZ0OnZhcigtLXNwYWNpbmcpfS5kcmFnZ2FibGV7Y3Vyc29yOm1vdmU7Y3Vyc29yOmdyYWJ9LmRyYWdnYWJsZTphY3RpdmV7Y3Vyc29yOmdyYWJiaW5nfVwiO1xuXG4vLyBzcmMvY29tcG9uZW50cy9NYXBib3hTZWFyY2hMaXN0Ym94LnRzXG52YXIgVEVNUExBVEUgPSBjcmVhdGVFbGVtZW50RnJvbVN0cmluZyhgXG48dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJNYXBib3hTZWFyY2hcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJMYWJlbFwiIHJvbGU9XCJsYWJlbFwiIGFyaWEtbGl2ZT1cInBvbGl0ZVwiIGFyaWEtYXRvbWljPVwidHJ1ZVwiPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiUmVzdWx0c1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiUmVzdWx0c0xpc3RcIiByb2xlPVwibGlzdGJveFwiPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIlJlc3VsdHNBdHRyaWJ1dGlvblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICAgIDxhIGhyZWY9XCJodHRwczovL3d3dy5tYXBib3guY29tL3NlYXJjaC1zZXJ2aWNlXCIgdGFyZ2V0PVwiX2JsYW5rXCIgdGFiaW5kZXg9XCItMVwiPlxuICAgICAgICAgICAgUG93ZXJlZCBieSBNYXBib3hcbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbmApO1xudmFyIFJFTkRFUl9URU1QTEFURSA9IGNyZWF0ZUVsZW1lbnRGcm9tU3RyaW5nKGBcbjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIlN1Z2dlc3Rpb25cIiByb2xlPVwib3B0aW9uXCI+XG4gICAgPGRpdiBjbGFzcz1cIlN1Z2dlc3Rpb25OYW1lXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIlN1Z2dlc3Rpb25EZXNjXCI+PC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbmApO1xuZnVuY3Rpb24gZ2V0QXJpYUlkRm9yU3VnZ2VzdGlvbihyZXN1bHRMaXN0SWQsIGkpIHtcbiAgcmV0dXJuIGAke3Jlc3VsdExpc3RJZH0tJHtpfWA7XG59XG52YXIgX3Nlc3Npb25JbnRlcm5hbCwgX3BvcG92ZXIsIF9iaW5kaW5nLCBfbGFiZWxJRCwgX3Jlc3VsdExpc3RJRCwgX2lucHV0SW50ZXJuYWwsIF9zZWxlY3RlZEluZGV4SW50ZXJuYWwsIF9zaG93UmVzdWx0cywgc2hvd1Jlc3VsdHNfZm4sIF9oaWRlUmVzdWx0cywgaGlkZVJlc3VsdHNfZm4sIF9yZW5kZXJSZXN1bHRzTGlzdCwgcmVuZGVyUmVzdWx0c0xpc3RfZm4sIF9vcHRpb25zSW50ZXJuYWwsIF90aGVtZUludGVybmFsLCBfcG9wb3Zlck9wdGlvbnMsIF9oYW5kbGVJbnB1dCwgX2hhbmRsZVN1Z2dlc3QsIF9oYW5kbGVTdWdnZXN0RXJyb3IsIF9oYW5kbGVGb2N1cywgX2hhbmRsZUJsdXIsIF9oYW5kbGVLZXlEb3duO1xudmFyIE1hcGJveFNlYXJjaExpc3Rib3ggPSBjbGFzcyBleHRlbmRzIEhUTUxTY29wZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3Nob3dSZXN1bHRzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hpZGVSZXN1bHRzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3JlbmRlclJlc3VsdHNMaXN0KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3Nlc3Npb25JbnRlcm5hbCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3BvcG92ZXIsIG51bGwpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYmluZGluZywgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2xhYmVsSUQsIHJhbmRvbVZhbGlkSUQoKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9yZXN1bHRMaXN0SUQsIHJhbmRvbVZhbGlkSUQoKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9pbnB1dEludGVybmFsLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2VsZWN0ZWRJbmRleEludGVybmFsLCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29wdGlvbnNJbnRlcm5hbCwge30pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdGhlbWVJbnRlcm5hbCwge30pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfcG9wb3Zlck9wdGlvbnMsIHt9KTtcbiAgICB0aGlzLnJldHJpZXZlRmVhdHVyZSA9IG51bGw7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVJbnB1dCwgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgUmVzdWx0cyB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nKTtcbiAgICAgIGNvbnN0IGlucHV0ID0gZS50YXJnZXQ7XG4gICAgICBpZiAoaW5wdXQuZGF0YXNldFtcIm1hcGJveFN1Y2Nlc3NcIl0pIHtcbiAgICAgICAgZGVsZXRlIGlucHV0LmRhdGFzZXRbXCJtYXBib3hTdWNjZXNzXCJdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzZWFyY2hUZXh0ID0gaW5wdXQudmFsdWU7XG4gICAgICBSZXN1bHRzLnNldEF0dHJpYnV0ZShcImFyaWEtYnVzeVwiLCBcInRydWVcIik7XG4gICAgICB0aGlzLnNlc3Npb24uc3VnZ2VzdChzZWFyY2hUZXh0LCB0aGlzLm9wdGlvbnMpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlU3VnZ2VzdCwgKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC5zdWdnZXN0aW9ucykge1xuICAgICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX2hpZGVSZXN1bHRzLCBoaWRlUmVzdWx0c19mbikuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9yZW5kZXJSZXN1bHRzTGlzdCwgcmVuZGVyUmVzdWx0c0xpc3RfZm4pLmNhbGwodGhpcyk7XG4gICAgICBpZiAocmVzdWx0LnN1Z2dlc3Rpb25zLmxlbmd0aCkge1xuICAgICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3Nob3dSZXN1bHRzLCBzaG93UmVzdWx0c19mbikuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwic3VnZ2VzdFwiLCByZXN1bHQpKTtcbiAgICAgIGNvbnN0IHsgUmVzdWx0cyB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nKTtcbiAgICAgIFJlc3VsdHMuc2V0QXR0cmlidXRlKFwiYXJpYS1idXN5XCIsIFwiZmFsc2VcIik7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVTdWdnZXN0RXJyb3IsIChlcnJvcikgPT4ge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBib3hIVE1MRXZlbnQoXCJzdWdnZXN0ZXJyb3JcIiwgZXJyb3IpKTtcbiAgICAgIGNvbnN0IHsgUmVzdWx0cyB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nKTtcbiAgICAgIFJlc3VsdHMuc2V0QXR0cmlidXRlKFwiYXJpYS1idXN5XCIsIFwiZmFsc2VcIik7XG4gICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX2hpZGVSZXN1bHRzLCBoaWRlUmVzdWx0c19mbikuY2FsbCh0aGlzKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUZvY3VzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgICBkZWxldGUgaW5wdXQuZGF0YXNldFtcIm1hcGJveFN1Y2Nlc3NcIl07XG4gICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3Nob3dSZXN1bHRzLCBzaG93UmVzdWx0c19mbikuY2FsbCh0aGlzKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUJsdXIsICgpID0+IHtcbiAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLmlucHV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2Vzc2lvbi5hYm9ydCgpO1xuICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9oaWRlUmVzdWx0cywgaGlkZVJlc3VsdHNfZm4pLmNhbGwodGhpcyk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVLZXlEb3duLCAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfaGlkZVJlc3VsdHMsIGhpZGVSZXN1bHRzX2ZuKS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZS5rZXkgPT09IFwiQXJyb3dVcFwiKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gTWF0aC5tYXgoMCwgdGhpcy5zZWxlY3RlZEluZGV4IC0gMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlLmtleSA9PT0gXCJBcnJvd0Rvd25cIikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IE1hdGgubWluKHRoaXMuc2VsZWN0ZWRJbmRleCArIDEsIHRoaXMuc3VnZ2VzdGlvbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlLmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5yZXRyaWV2ZSh0aGlzLnN1Z2dlc3Rpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBURU1QTEFURTtcbiAgfVxuICBnZXQgdGVtcGxhdGVTdHlsZSgpIHtcbiAgICByZXR1cm4gc3R5bGVfZGVmYXVsdDtcbiAgfVxuICBnZXQgdGVtcGxhdGVVc2VyU3R5bGUoKSB7XG4gICAgcmV0dXJuIGdldFRoZW1lQ1NTKFwiLk1hcGJveFNlYXJjaFwiLCB0aGlzLnRoZW1lKTtcbiAgfVxuICBnZXQgc2Vzc2lvbigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zZXNzaW9uSW50ZXJuYWwpO1xuICB9XG4gIHNldCBzZXNzaW9uKG5ld1Nlc3Npb24pIHtcbiAgICBjb25zdCBvbGRTZXNzaW9uID0gX19wcml2YXRlR2V0KHRoaXMsIF9zZXNzaW9uSW50ZXJuYWwpO1xuICAgIGlmIChvbGRTZXNzaW9uKSB7XG4gICAgICBuZXdTZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU3VnZ2VzdCkpO1xuICAgICAgbmV3U2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdGVycm9yXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU3VnZ2VzdEVycm9yKSk7XG4gICAgfVxuICAgIGlmIChuZXdTZXNzaW9uKSB7XG4gICAgICBuZXdTZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU3VnZ2VzdCkpO1xuICAgICAgbmV3U2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKFwic3VnZ2VzdGVycm9yXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU3VnZ2VzdEVycm9yKSk7XG4gICAgfVxuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfc2Vzc2lvbkludGVybmFsLCBuZXdTZXNzaW9uKTtcbiAgfVxuICBnZXQgc3VnZ2VzdGlvbnMoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnNlc3Npb24uc3VnZ2VzdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdWdnZXN0aW9ucztcbiAgfVxuICBnZXQgaW5wdXQoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXRJbnRlcm5hbCk7XG4gIH1cbiAgc2V0IGlucHV0KG5ld0lucHV0KSB7XG4gICAgY29uc3Qgb2xkSW5wdXQgPSBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0SW50ZXJuYWwpO1xuICAgIGlmIChvbGRJbnB1dCkge1xuICAgICAgb2xkSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlSW5wdXQpKTtcbiAgICAgIG9sZElucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUZvY3VzKSk7XG4gICAgICBvbGRJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUJsdXIpKTtcbiAgICAgIG9sZElucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlS2V5RG93bikpO1xuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9wb3ZlcikpIHtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9wb3BvdmVyKS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdJbnB1dCkge1xuICAgICAgbmV3SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlSW5wdXQpKTtcbiAgICAgIG5ld0lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUZvY3VzKSk7XG4gICAgICBuZXdJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUJsdXIpKTtcbiAgICAgIG5ld0lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlS2V5RG93bikpO1xuICAgICAgbmV3SW5wdXQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbWJvYm94XCIpO1xuICAgICAgbmV3SW5wdXQuc2V0QXR0cmlidXRlKFwiYXJpYS1hdXRvY29tcGxldGVcIiwgXCJsaXN0XCIpO1xuICAgICAgbmV3SW5wdXQuc2V0QXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX3Jlc3VsdExpc3RJRCkpO1xuICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9wb3BvdmVyLCBuZXcgUG9wb3ZlcihuZXdJbnB1dCwgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nKS5SZXN1bHRzLCB0aGlzLnBvcG92ZXJPcHRpb25zKSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaW5wdXRJbnRlcm5hbCwgbmV3SW5wdXQpO1xuICB9XG4gIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3NlbGVjdGVkSW5kZXhJbnRlcm5hbCk7XG4gIH1cbiAgc2V0IHNlbGVjdGVkSW5kZXgobmV3SW5kZXgpIHtcbiAgICBjb25zdCBvbGRJbmRleCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfc2VsZWN0ZWRJbmRleEludGVybmFsKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3NlbGVjdGVkSW5kZXhJbnRlcm5hbCwgbmV3SW5kZXgpO1xuICAgIGNvbnN0IHsgUmVzdWx0c0xpc3QsIExhYmVsIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpO1xuICAgIGNvbnN0IGlkID0gZ2V0QXJpYUlkRm9yU3VnZ2VzdGlvbihfX3ByaXZhdGVHZXQodGhpcywgX3Jlc3VsdExpc3RJRCksIG5ld0luZGV4KTtcbiAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCBpZCk7XG4gICAgUmVzdWx0c0xpc3Quc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIGlkKTtcbiAgICBpZiAob2xkSW5kZXggIT09IG5ld0luZGV4KSB7XG4gICAgICBjb25zdCBvbGRJZCA9IGdldEFyaWFJZEZvclN1Z2dlc3Rpb24oX19wcml2YXRlR2V0KHRoaXMsIF9yZXN1bHRMaXN0SUQpLCBvbGRJbmRleCk7XG4gICAgICBjb25zdCBvbGRFbCA9IFJlc3VsdHNMaXN0LnF1ZXJ5U2VsZWN0b3IoYCMke29sZElkfWApO1xuICAgICAgb2xkRWwgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZEVsLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIik7XG4gICAgICBjb25zdCBlbCA9IFJlc3VsdHNMaXN0LnF1ZXJ5U2VsZWN0b3IoYCMke2lkfWApO1xuICAgICAgZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgIH1cbiAgICBMYWJlbC50ZXh0Q29udGVudCA9IHRoaXMuc3VnZ2VzdGlvbnNbbmV3SW5kZXhdLmFkZHJlc3MgKyBgOiBTdWdnZXN0aW9uICR7bmV3SW5kZXggKyAxfSBvZiAke3RoaXMuc3VnZ2VzdGlvbnMubGVuZ3RofWA7XG4gIH1cbiAgcmVuZGVySXRlbShpKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMucHJlcGFyZVRlbXBsYXRlKFJFTkRFUl9URU1QTEFURSk7XG4gICAgZWxlbWVudC5pZCA9IGdldEFyaWFJZEZvclN1Z2dlc3Rpb24oX19wcml2YXRlR2V0KHRoaXMsIF9yZXN1bHRMaXN0SUQpLCBpKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBmaWxsSXRlbShlbCwgaXRlbSwgaSkge1xuICAgIGNvbnN0IFtuYW1lRWwsIGRlc2NyaXB0aW9uRWxdID0gQXJyYXkuZnJvbShlbC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cIm9wdGlvblwiXSA+IConKSk7XG4gICAgbmFtZUVsLnRleHRDb250ZW50ID0gXCJhZGRyZXNzX2xpbmUxXCIgaW4gaXRlbSA/IGl0ZW0uYWRkcmVzc19saW5lMSB8fCBpdGVtLm1hdGNoaW5nX25hbWUgfHwgaXRlbS5mZWF0dXJlX25hbWUgOiBpdGVtLm1hdGNoaW5nX25hbWUgfHwgaXRlbS5mZWF0dXJlX25hbWU7XG4gICAgZGVzY3JpcHRpb25FbC50ZXh0Q29udGVudCA9IGl0ZW0uZGVzY3JpcHRpb247XG4gICAgaWYgKGkgPT09IHRoaXMuc2VsZWN0ZWRJbmRleCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIik7XG4gICAgfVxuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX29wdGlvbnNJbnRlcm5hbCk7XG4gIH1cbiAgc2V0IG9wdGlvbnMobmV3T3B0aW9ucykge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfb3B0aW9uc0ludGVybmFsLCBuZXdPcHRpb25zKTtcbiAgfVxuICBnZXQgdGhlbWUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfdGhlbWVJbnRlcm5hbCk7XG4gIH1cbiAgc2V0IHRoZW1lKHRoZW1lKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF90aGVtZUludGVybmFsLCB0aGVtZSk7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpIHx8ICF0aGVtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlVXNlclN0eWxlKGdldFRoZW1lQ1NTKFwiLk1hcGJveFNlYXJjaFwiLCB0aGVtZSkpO1xuICB9XG4gIGdldCBwb3BvdmVyT3B0aW9ucygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9wb3BvdmVyT3B0aW9ucyk7XG4gIH1cbiAgc2V0IHBvcG92ZXJPcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3BvcG92ZXJPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9wb3BvdmVyKSkge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9wb3BvdmVyKS5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9wb3ZlcikudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9iaW5kaW5nLCBiaW5kRWxlbWVudHModGhpcywge1xuICAgICAgTWFwYm94U2VhcmNoOiBcIi5NYXBib3hTZWFyY2hcIixcbiAgICAgIFJlc3VsdHM6IFwiLlJlc3VsdHNcIixcbiAgICAgIFJlc3VsdHNMaXN0OiBcIi5SZXN1bHRzTGlzdFwiLFxuICAgICAgTGFiZWw6IFwiLkxhYmVsXCJcbiAgICB9KSk7XG4gICAgY29uc3QgeyBSZXN1bHRzLCBSZXN1bHRzTGlzdCwgTGFiZWwgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZyk7XG4gICAgTGFiZWwuaWQgPSBfX3ByaXZhdGVHZXQodGhpcywgX2xhYmVsSUQpO1xuICAgIFJlc3VsdHNMaXN0LmlkID0gX19wcml2YXRlR2V0KHRoaXMsIF9yZXN1bHRMaXN0SUQpO1xuICAgIFJlc3VsdHNMaXN0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2xhYmVsSUQpKTtcbiAgICBSZXN1bHRzLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlQmx1cikpO1xuICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9wb3BvdmVyKSAmJiB0aGlzLmlucHV0KSB7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX3BvcG92ZXIsIG5ldyBQb3BvdmVyKHRoaXMuaW5wdXQsIF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZykuUmVzdWx0cywgdGhpcy5wb3BvdmVyT3B0aW9ucykpO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9wb3ZlcikpIHtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9wb3BvdmVyKS51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmlucHV0ID0gbnVsbDtcbiAgICBjb25zdCB7IFJlc3VsdHMgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZyk7XG4gICAgUmVzdWx0cy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUJsdXIpKTtcbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9wb3BvdmVyKSlcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfcG9wb3ZlcikuZGVzdHJveSgpO1xuICB9XG4gIHJldHJpZXZlKHN1Z2dlc3Rpb24pIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgIGlucHV0LmRhdGFzZXRbXCJtYXBib3hTdWNjZXNzXCJdID0gXCJ0cnVlXCI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnNlc3Npb24ucmV0cmlldmUoc3VnZ2VzdGlvbiwgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMucmV0cmlldmVGZWF0dXJlID0gKF9hID0gcmVzdWx0LmZlYXR1cmVzKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF07XG4gICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX2hpZGVSZXN1bHRzLCBoaWRlUmVzdWx0c19mbikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwicmV0cmlldmVcIiwgcmVzdWx0KSk7XG4gICAgfSk7XG4gIH1cbiAgc2ltdWxhdGVSZXRyaWV2ZShmZWF0dXJlKSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgIGlmIChpbnB1dCkge1xuICAgICAgaW5wdXQuZGF0YXNldFtcIm1hcGJveFN1Y2Nlc3NcIl0gPSBcInRydWVcIjtcbiAgICB9XG4gICAgdGhpcy5yZXRyaWV2ZUZlYXR1cmUgPSBmZWF0dXJlO1xuICAgIGNvbnN0IHNpbVJlc3VsdCA9IHtcbiAgICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgIGZlYXR1cmVzOiBbZmVhdHVyZV1cbiAgICB9O1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfaGlkZVJlc3VsdHMsIGhpZGVSZXN1bHRzX2ZuKS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwicmV0cmlldmVcIiwgc2ltUmVzdWx0KSk7XG4gIH1cbiAgZm9jdXMoKSB7XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuaW5wdXQpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlRm9jdXMpLmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgYmx1cigpIHtcbiAgICB0aGlzLmlucHV0LmJsdXIoKTtcbiAgfVxuICB1cGRhdGVQb3BvdmVyKCkge1xuICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX3BvcG92ZXIpKSB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3BvcG92ZXIpLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxufTtcbl9zZXNzaW9uSW50ZXJuYWwgPSBuZXcgV2Vha01hcCgpO1xuX3BvcG92ZXIgPSBuZXcgV2Vha01hcCgpO1xuX2JpbmRpbmcgPSBuZXcgV2Vha01hcCgpO1xuX2xhYmVsSUQgPSBuZXcgV2Vha01hcCgpO1xuX3Jlc3VsdExpc3RJRCA9IG5ldyBXZWFrTWFwKCk7XG5faW5wdXRJbnRlcm5hbCA9IG5ldyBXZWFrTWFwKCk7XG5fc2VsZWN0ZWRJbmRleEludGVybmFsID0gbmV3IFdlYWtNYXAoKTtcbl9zaG93UmVzdWx0cyA9IG5ldyBXZWFrU2V0KCk7XG5zaG93UmVzdWx0c19mbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuc3VnZ2VzdGlvbnMgfHwgIXRoaXMuc3VnZ2VzdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHsgUmVzdWx0cywgTWFwYm94U2VhcmNoOiBNYXBib3hTZWFyY2gyIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpO1xuICBjb25zdCByZWN0ID0gdGhpcy5pbnB1dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgTWFwYm94U2VhcmNoMi5zdHlsZS5zZXRQcm9wZXJ0eShcIi0td2lkdGhcIiwgYCR7cmVjdC53aWR0aH1weGApO1xuICBNYXBib3hTZWFyY2gyLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJ0cnVlXCIpO1xuICBSZXN1bHRzLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICB0aGlzLnNlbGVjdGVkSW5kZXggPSAwO1xufTtcbl9oaWRlUmVzdWx0cyA9IG5ldyBXZWFrU2V0KCk7XG5oaWRlUmVzdWx0c19mbiA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB7IFJlc3VsdHMsIFJlc3VsdHNMaXN0IH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpO1xuICBSZXN1bHRzLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIpO1xuICBSZXN1bHRzTGlzdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xufTtcbl9yZW5kZXJSZXN1bHRzTGlzdCA9IG5ldyBXZWFrU2V0KCk7XG5yZW5kZXJSZXN1bHRzTGlzdF9mbiA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB7IFJlc3VsdHNMaXN0IH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcpO1xuICBjb25zdCBzdWdnZXN0aW9ucyA9IHRoaXMuc3VnZ2VzdGlvbnM7XG4gIGlmICghc3VnZ2VzdGlvbnMgfHwgIXN1Z2dlc3Rpb25zLmxlbmd0aCkge1xuICAgIFJlc3VsdHNMaXN0LmlubmVySFRNTCA9IFwiXCI7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9oaWRlUmVzdWx0cywgaGlkZVJlc3VsdHNfZm4pLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGVsZW1lbnRzID0gZ2V0Q2hpbGRFbGVtZW50cyhSZXN1bHRzTGlzdCk7XG4gIGlmIChzdWdnZXN0aW9ucy5sZW5ndGggPiBlbGVtZW50cy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgc3VnZ2VzdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLnJlbmRlckl0ZW0oaSk7XG4gICAgICBlbGVtZW50cy5wdXNoKGl0ZW0pO1xuICAgICAgaXRlbS5vbm1vdXNlZW50ZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICB9O1xuICAgICAgUmVzdWx0c0xpc3QuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgfVxuICB9XG4gIGlmIChzdWdnZXN0aW9ucy5sZW5ndGggPCBlbGVtZW50cy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gc3VnZ2VzdGlvbnMubGVuZ3RoOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVsZW1lbnRzW2ldLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IHN1Z2dlc3Rpb24gb2Ygc3VnZ2VzdGlvbnMpIHtcbiAgICBjb25zdCBpID0gc3VnZ2VzdGlvbnMuaW5kZXhPZihzdWdnZXN0aW9uKTtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgdGhpcy5maWxsSXRlbShlbGVtZW50LCBzdWdnZXN0aW9uLCBpKTtcbiAgICBlbGVtZW50Lm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJldHJpZXZlKHN1Z2dlc3Rpb24pO1xuICAgIH07XG4gIH1cbn07XG5fb3B0aW9uc0ludGVybmFsID0gbmV3IFdlYWtNYXAoKTtcbl90aGVtZUludGVybmFsID0gbmV3IFdlYWtNYXAoKTtcbl9wb3BvdmVyT3B0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlSW5wdXQgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVN1Z2dlc3QgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVN1Z2dlc3RFcnJvciA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlRm9jdXMgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZUJsdXIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZUtleURvd24gPSBuZXcgV2Vha01hcCgpO1xud2luZG93Lk1hcGJveFNlYXJjaExpc3Rib3ggPSBNYXBib3hTZWFyY2hMaXN0Ym94O1xuaWYgKCF3aW5kb3cuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWFwYm94LXNlYXJjaC1saXN0Ym94XCIpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcIm1hcGJveC1zZWFyY2gtbGlzdGJveFwiLCBNYXBib3hTZWFyY2hMaXN0Ym94KTtcbn1cblxuLy8gc3JjL3V0aWxzL2FyaWEudHNcbmZ1bmN0aW9uIGFyaWFCdXR0b25LZXlEb3duKGUpIHtcbiAgY29uc3QgZWwgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gIGlmIChlLmtleSA9PT0gXCIgXCIgfHwgZS5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9KSk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2F1dG9maWxsLnRzXG5pbXBvcnQge1xuICBmZWF0dXJlVG9TdWdnZXN0aW9uXG59IGZyb20gXCJAbWFwYm94L3NlYXJjaC1qcy1jb3JlXCI7XG52YXIgQVVUT0ZJTExfVE9LRU5TID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcInN0cmVldC1hZGRyZXNzXCIsXG4gIFwiYWRkcmVzcy1saW5lMVwiLFxuICBcImFkZHJlc3MtbGluZTJcIixcbiAgXCJhZGRyZXNzLWxpbmUzXCIsXG4gIFwiYWRkcmVzcy1sZXZlbDRcIixcbiAgXCJhZGRyZXNzLWxldmVsM1wiLFxuICBcImFkZHJlc3MtbGV2ZWwyXCIsXG4gIFwiYWRkcmVzcy1sZXZlbDFcIixcbiAgXCJjb3VudHJ5XCIsXG4gIFwiY291bnRyeS1uYW1lXCIsXG4gIFwicG9zdGFsLWNvZGVcIlxuXSk7XG52YXIgQVVUT0ZJTExfU0tJUF9UT0tFTlMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJvZmZcIiwgXCJvblwiLCBcInRydWVcIiwgXCJmYWxzZVwiXSk7XG5mdW5jdGlvbiBmaW5kUGFyZW50Rm9ybShlbCkge1xuICBsZXQgbm9kZSA9IGVsLnBhcmVudE5vZGU7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZEFkZHJlc3NJbnB1dHMoZm9ybSkge1xuICBjb25zdCBwYXJlbnQgPSBmb3JtIHx8IGRvY3VtZW50O1xuICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbYXV0b2NvbXBsZXRlfj1cImFkZHJlc3MtbGluZTFcIl0sIGlucHV0W2F1dG9jb21wbGV0ZX49XCJzdHJlZXQtYWRkcmVzc1wiXScpKTtcbn1cbnZhciBTRUNUSU9OID0gXCJzZWN0aW9uLVwiO1xudmFyIFNFQ1RJT05fREVGQVVMVCA9IFwic2VjdGlvbi1kZWZhdWx0XCI7XG52YXIgU0VDVElPTl9TSElQUElORyA9IFwic2VjdGlvbi1zaGlwcGluZ1wiO1xudmFyIFNFQ1RJT05fQklMTElORyA9IFwic2VjdGlvbi1iaWxsaW5nXCI7XG5mdW5jdGlvbiBwYXJzZUZvcm1TdHJ1Y3R1cmUoZm9ybSkge1xuICBjb25zdCBpbnB1dHMgPSBBcnJheS5mcm9tKGZvcm0ucXVlcnlTZWxlY3RvckFsbChcIlthdXRvY29tcGxldGVdXCIpKS5maWx0ZXIoKGVsKSA9PiB7XG4gICAgY29uc3QgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gdGFnTmFtZSA9PT0gXCJpbnB1dFwiIHx8IHRhZ05hbWUgPT09IFwic2VsZWN0XCIgfHwgdGFnTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiO1xuICB9KTtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgaWYgKCFpc1Zpc2libGUoaW5wdXQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYXV0b2NvbXBsZXRlID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlXCIpIHx8IFwiXCI7XG4gICAgaWYgKCFhdXRvY29tcGxldGUgfHwgQVVUT0ZJTExfU0tJUF9UT0tFTlMuaGFzKGF1dG9jb21wbGV0ZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0b2tlbnMgPSBhdXRvY29tcGxldGUudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIik7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPiAzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZmllbGQgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgIGlmICghQVVUT0ZJTExfVE9LRU5TLmhhcyhmaWVsZCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0b2tlbnMucG9wKCk7XG4gICAgbGV0IHNlY3Rpb24gPSBTRUNUSU9OX0RFRkFVTFQ7XG4gICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNlY3Rpb25Ub2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoc2VjdGlvblRva2VuID09PSBcInNoaXBwaW5nXCIpIHtcbiAgICAgICAgc2VjdGlvbiA9IFNFQ1RJT05fU0hJUFBJTkc7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWN0aW9uVG9rZW4gPT09IFwiYmlsbGluZ1wiKSB7XG4gICAgICAgIHNlY3Rpb24gPSBTRUNUSU9OX0JJTExJTkc7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNlY3Rpb25Ub2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoc2VjdGlvblRva2VuLnN0YXJ0c1dpdGgoU0VDVElPTikpIHtcbiAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb25Ub2tlbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzLnB1c2goe1xuICAgICAgaW5wdXQsXG4gICAgICBzZWN0aW9uLFxuICAgICAgZmllbGRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZmluZEFkZHJlc3NBdXRvZmlsbElucHV0cyhmb3JtLCByZWYpIHtcbiAgY29uc3QgbG9naWNhbFNlY3Rpb25zID0gW107XG4gIGNvbnN0IGxvZ2ljYWxTZWN0aW9uU2VjdGlvbnMgPSBbXTtcbiAgY29uc3QgZm9ybVN0cnVjdHVyZSA9IHBhcnNlRm9ybVN0cnVjdHVyZShmb3JtKTtcbiAgbGV0IGZvdW5kU2VjdGlvbiA9IG51bGw7XG4gIGZvciAoY29uc3QgeyBpbnB1dCwgc2VjdGlvbiwgZmllbGQgfSBvZiBmb3JtU3RydWN0dXJlKSB7XG4gICAgbGV0IGxhc3RJbmRleCA9IGxvZ2ljYWxTZWN0aW9ucy5sZW5ndGggLSAxO1xuICAgIGxldCBjcmVhdGVOZXdTZWN0aW9uID0gZmFsc2U7XG4gICAgaWYgKCFsb2dpY2FsU2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjcmVhdGVOZXdTZWN0aW9uID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGxvZ2ljYWxTZWN0aW9uU2VjdGlvbnNbbGFzdEluZGV4XSAhPT0gc2VjdGlvbikge1xuICAgICAgY3JlYXRlTmV3U2VjdGlvbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChsb2dpY2FsU2VjdGlvbnNbbGFzdEluZGV4XVtmaWVsZF0pIHtcbiAgICAgIGNyZWF0ZU5ld1NlY3Rpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlTmV3U2VjdGlvbikge1xuICAgICAgaWYgKGZvdW5kU2VjdGlvbikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxvZ2ljYWxTZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgW2ZpZWxkXTogaW5wdXRcbiAgICAgIH0pO1xuICAgICAgbG9naWNhbFNlY3Rpb25TZWN0aW9ucy5wdXNoKHNlY3Rpb24pO1xuICAgICAgbGFzdEluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2ljYWxTZWN0aW9uc1tsYXN0SW5kZXhdW2ZpZWxkXSA9IGlucHV0O1xuICAgIH1cbiAgICBpZiAoaW5wdXQgPT09IHJlZikge1xuICAgICAgZm91bmRTZWN0aW9uID0gbG9naWNhbFNlY3Rpb25zW2xhc3RJbmRleF07XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3VuZFNlY3Rpb24gIT0gbnVsbCA/IGZvdW5kU2VjdGlvbiA6IHt9O1xufVxuZnVuY3Rpb24gc2V0Rm9ybUF1dG9maWxsVmFsdWVzKGZvcm0sIHJlZiwgc3VnZ2VzdGlvbikge1xuICB2YXIgX2E7XG4gIGNvbnN0IG1hcCA9IGZpbmRBZGRyZXNzQXV0b2ZpbGxJbnB1dHMoZm9ybSwgcmVmKTtcbiAgY29uc3Qgc3RyZWV0QWRkcmVzcyA9IFtcbiAgICBzdWdnZXN0aW9uLmFkZHJlc3NfbGluZTEsXG4gICAgc3VnZ2VzdGlvbi5hZGRyZXNzX2xpbmUyLFxuICAgIHN1Z2dlc3Rpb24uYWRkcmVzc19saW5lM1xuICBdLmZpbHRlcigocGFydCkgPT4gQm9vbGVhbihwYXJ0KSkuam9pbihcIiwgXCIpO1xuICBzZXRWYWx1ZShtYXBbXCJzdHJlZXQtYWRkcmVzc1wiXSwgc3RyZWV0QWRkcmVzcyk7XG4gIHNldFZhbHVlKG1hcFtcImFkZHJlc3MtbGluZTFcIl0sIHN1Z2dlc3Rpb24uYWRkcmVzc19saW5lMSB8fCBcIlwiKTtcbiAgc2V0VmFsdWUobWFwW1wiYWRkcmVzcy1sZXZlbDFcIl0sIHN1Z2dlc3Rpb24uYWRkcmVzc19sZXZlbDEgfHwgXCJcIik7XG4gIHNldFZhbHVlKG1hcFtcImFkZHJlc3MtbGV2ZWwyXCJdLCBzdWdnZXN0aW9uLmFkZHJlc3NfbGV2ZWwyIHx8IFwiXCIpO1xuICBzZXRWYWx1ZShtYXBbXCJhZGRyZXNzLWxldmVsM1wiXSwgc3VnZ2VzdGlvbi5hZGRyZXNzX2xldmVsMyB8fCBcIlwiKTtcbiAgY29uc3QgY291bnRyeUNvZGUgPSAoKF9hID0gc3VnZ2VzdGlvbi5tZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmlzb18zMTY2XzEpIHx8IFwiXCI7XG4gIGlmIChtYXAuY291bnRyeSAmJiBtYXAuY291bnRyeSBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSB7XG4gICAgY29uc3QgZmlyc3RPcHRpb24gPSBtYXAuY291bnRyeS5xdWVyeVNlbGVjdG9yKGBvcHRpb25gKS52YWx1ZTtcbiAgICBjb25zdCBpc1VwcGVyQ2FzZSA9IGZpcnN0T3B0aW9uID09PSBmaXJzdE9wdGlvbi50b1VwcGVyQ2FzZSgpO1xuICAgIHNldFZhbHVlKG1hcFtcImNvdW50cnlcIl0sIGlzVXBwZXJDYXNlID8gY291bnRyeUNvZGUudG9VcHBlckNhc2UoKSA6IGNvdW50cnlDb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRWYWx1ZShtYXBbXCJjb3VudHJ5XCJdLCBjb3VudHJ5Q29kZSk7XG4gIH1cbiAgc2V0VmFsdWUobWFwW1wiY291bnRyeS1uYW1lXCJdLCBzdWdnZXN0aW9uLmNvdW50cnkgfHwgXCJcIik7XG4gIHNldFZhbHVlKG1hcFtcInBvc3RhbC1jb2RlXCJdLCBzdWdnZXN0aW9uLnBvc3Rjb2RlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybUF1dG9maWxsVmFsdWVzKGZvcm0sIHJlZikge1xuICBjb25zdCBtYXAgPSBmaW5kQWRkcmVzc0F1dG9maWxsSW5wdXRzKGZvcm0sIHJlZik7XG4gIGNvbnN0IHZhbHVlcyA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIGlucHV0XSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XG4gICAgaWYgKGlucHV0ID09IG51bGwgPyB2b2lkIDAgOiBpbnB1dC52YWx1ZSkge1xuICAgICAgdmFsdWVzW2tleV0gPSBpbnB1dC52YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGdldEF1dG9maWxsU2VhcmNoVGV4dChzbmFwc2hvdCkge1xuICBjb25zdCBzZWFyY2hUZXh0ID0gW107XG4gIGlmIChzbmFwc2hvdFtcInN0cmVldC1hZGRyZXNzXCJdKSB7XG4gICAgc2VhcmNoVGV4dC5wdXNoKHNuYXBzaG90W1wic3RyZWV0LWFkZHJlc3NcIl0pO1xuICB9IGVsc2Uge1xuICAgIHNlYXJjaFRleHQucHVzaChzbmFwc2hvdFtcImFkZHJlc3MtbGluZTFcIl0gfHwgXCJcIik7XG4gICAgc2VhcmNoVGV4dC5wdXNoKHNuYXBzaG90W1wiYWRkcmVzcy1saW5lMlwiXSB8fCBcIlwiKTtcbiAgICBzZWFyY2hUZXh0LnB1c2goc25hcHNob3RbXCJhZGRyZXNzLWxpbmUzXCJdIHx8IFwiXCIpO1xuICB9XG4gIHNlYXJjaFRleHQucHVzaChzbmFwc2hvdFtcImFkZHJlc3MtbGV2ZWwzXCJdIHx8IFwiXCIpO1xuICBzZWFyY2hUZXh0LnB1c2goc25hcHNob3RbXCJhZGRyZXNzLWxldmVsMlwiXSB8fCBcIlwiKTtcbiAgc2VhcmNoVGV4dC5wdXNoKHNuYXBzaG90W1wiYWRkcmVzcy1sZXZlbDFcIl0gfHwgXCJcIik7XG4gIHNlYXJjaFRleHQucHVzaChzbmFwc2hvdFtcInBvc3RhbC1jb2RlXCJdIHx8IFwiXCIpO1xuICBpZiAoc25hcHNob3RbXCJjb3VudHJ5LW5hbWVcIl0pIHtcbiAgICBzZWFyY2hUZXh0LnB1c2goc25hcHNob3RbXCJjb3VudHJ5LW5hbWVcIl0pO1xuICB9IGVsc2Uge1xuICAgIHNlYXJjaFRleHQucHVzaChzbmFwc2hvdFtcImNvdW50cnlcIl0gfHwgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFRleHQuZmlsdGVyKChwYXJ0KSA9PiBCb29sZWFuKHBhcnQpKS5qb2luKFwiLCBcIik7XG59XG5mdW5jdGlvbiBmaWxsRm9ybVdpdGhGZWF0dXJlKGZlYXR1cmUsIGlucHV0KSB7XG4gIGNvbnN0IGZvcm0gPSBmaW5kUGFyZW50Rm9ybShpbnB1dCk7XG4gIGlmICghZm9ybSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdWdnZXN0aW9uID0gZmVhdHVyZVRvU3VnZ2VzdGlvbihmZWF0dXJlKTtcbiAgc2V0Rm9ybUF1dG9maWxsVmFsdWVzKGZvcm0sIGlucHV0LCBzdWdnZXN0aW9uKTtcbn1cbmZ1bmN0aW9uIGZlYXR1cmVUb0F1dG9maWxsVmFsdWVNYXAoZmVhdHVyZSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHZhbHVlcyA9IHt9O1xuICBjb25zdCBzdHJlZXRBZGRyZXNzID0gW1xuICAgIGZlYXR1cmUucHJvcGVydGllcy5hZGRyZXNzX2xpbmUxLFxuICAgIGZlYXR1cmUucHJvcGVydGllcy5hZGRyZXNzX2xpbmUyLFxuICAgIGZlYXR1cmUucHJvcGVydGllcy5hZGRyZXNzX2xpbmUzXG4gIF0uZmlsdGVyKChwYXJ0KSA9PiBCb29sZWFuKHBhcnQpKS5qb2luKFwiLCBcIik7XG4gIHZhbHVlc1tcInN0cmVldC1hZGRyZXNzXCJdID0gc3RyZWV0QWRkcmVzcztcbiAgdmFsdWVzW1wiYWRkcmVzcy1saW5lMVwiXSA9IGZlYXR1cmUucHJvcGVydGllcy5hZGRyZXNzX2xpbmUxO1xuICB2YWx1ZXNbXCJhZGRyZXNzLWxpbmUyXCJdID0gZmVhdHVyZS5wcm9wZXJ0aWVzLmFkZHJlc3NfbGluZTI7XG4gIHZhbHVlc1tcImFkZHJlc3MtbGluZTNcIl0gPSBmZWF0dXJlLnByb3BlcnRpZXMuYWRkcmVzc19saW5lMztcbiAgdmFsdWVzW1wiYWRkcmVzcy1sZXZlbDFcIl0gPSBmZWF0dXJlLnByb3BlcnRpZXMuYWRkcmVzc19sZXZlbDE7XG4gIHZhbHVlc1tcImFkZHJlc3MtbGV2ZWwyXCJdID0gZmVhdHVyZS5wcm9wZXJ0aWVzLmFkZHJlc3NfbGV2ZWwyO1xuICB2YWx1ZXNbXCJhZGRyZXNzLWxldmVsM1wiXSA9IGZlYXR1cmUucHJvcGVydGllcy5hZGRyZXNzX2xldmVsMztcbiAgdmFsdWVzW1wiY291bnRyeVwiXSA9IChfYSA9IGZlYXR1cmUucHJvcGVydGllcy5tZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmlzb18zMTY2XzE7XG4gIHZhbHVlc1tcImNvdW50cnktbmFtZVwiXSA9IGZlYXR1cmUucHJvcGVydGllcy5jb3VudHJ5O1xuICB2YWx1ZXNbXCJwb3N0YWwtY29kZVwiXSA9IGZlYXR1cmUucHJvcGVydGllcy5wb3N0Y29kZTtcbiAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGNoZWNrQXV0b2ZpbGxWYWx1ZXNDaGFuZ2VkKHRhcmdldE1hcCwgcmVmZXJlbmNlTWFwKSB7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRhcmdldE1hcCkpIHtcbiAgICBpZiAocmVmZXJlbmNlTWFwW2tleV0gIT09IHZhbHVlKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvY29uZmlybUFkZHJlc3MudHNcbmltcG9ydCB7XG4gIGZlYXR1cmVUb1N1Z2dlc3Rpb24gYXMgZmVhdHVyZVRvU3VnZ2VzdGlvbjJcbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcblxuLy8gc3JjL2NvbXBvbmVudHMvTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbi50c1xuaW1wb3J0IHtcbiAgTWF0Y2hDb2RlQ29uZmlkZW5jZSxcbiAgTWFwYm94VmFsaWRhdGVcbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcbmltcG9ydCBub1Njcm9sbCBmcm9tIFwibm8tc2Nyb2xsXCI7XG5pbXBvcnQgeyBjcmVhdGVGb2N1c1RyYXAgfSBmcm9tIFwiZm9jdXMtdHJhcFwiO1xuXG4vLyBzcmMvY29uZmlnLnRzXG5pbXBvcnQgeyBTZXNzaW9uVG9rZW4gYXMgU2Vzc2lvblRva2VuMiB9IGZyb20gXCJAbWFwYm94L3NlYXJjaC1qcy1jb3JlXCI7XG52YXIgQ29uZmlnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmZlZWRiYWNrRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5hdXRvZmlsbFNlc3Npb25Ub2tlbiA9IG5ldyBTZXNzaW9uVG9rZW4yKCk7XG4gICAgdGhpcy5hdXRvZmlsbFNlc3Npb25FbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXRlY3RCcm93c2VyQXV0b2ZpbGxFbmFibGVkID0gZmFsc2U7XG4gIH1cbn07XG52YXIgY29uZmlnID0gbmV3IENvbmZpZygpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbmZpZywgXCJhdXRvZmlsbFNlc3Npb25Ub2tlblwiLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZVxufSk7XG5cbi8vIHNyYy9jb21wb25lbnRzL01hcGJveEFkZHJlc3NDb25maXJtYXRpb24udHNcbnZhciBURU1QTEFURTIgPSBjcmVhdGVFbGVtZW50RnJvbVN0cmluZyhgXG48dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgPG1hcGJveC1hZGRyZXNzLWNvbmZpcm1hdGlvbi1mZWF0dXJlIGNsYXNzPVwiQ29udGVudEZlYXR1cmVcIj48L21hcGJveC1hZGRyZXNzLWNvbmZpcm1hdGlvbi1mZWF0dXJlPlxuICAgIDxtYXBib3gtYWRkcmVzcy1jb25maXJtYXRpb24tbm8tZmVhdHVyZSBjbGFzcz1cIkNvbnRlbnROb0ZlYXR1cmVcIj48L21hcGJveC1hZGRyZXNzLWNvbmZpcm1hdGlvbi1uby1mZWF0dXJlPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5gKTtcbnZhciBfc2hvdywgX2JpbmRpbmcyLCBfZm9jdXNUcmFwLCBfdGhlbWVJbnRlcm5hbDI7XG52YXIgTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbiA9IGNsYXNzIGV4dGVuZHMgSFRNTFNjb3BlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2hvdywgZmFsc2UpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYmluZGluZzIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9mb2N1c1RyYXAsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90aGVtZUludGVybmFsMiwge30pO1xuICB9XG4gIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gVEVNUExBVEUyO1xuICB9XG4gIGdldCB0ZW1wbGF0ZVN0eWxlKCkge1xuICAgIHJldHVybiBzdHlsZV9kZWZhdWx0O1xuICB9XG4gIGdldCB0ZW1wbGF0ZVVzZXJTdHlsZSgpIHtcbiAgICByZXR1cm4gZ2V0VGhlbWVDU1MoXCIuTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvblwiLCB0aGlzLnRoZW1lKTtcbiAgfVxuICBnZXQgdGhlbWUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfdGhlbWVJbnRlcm5hbDIpO1xuICB9XG4gIHNldCB0aGVtZSh0aGVtZSkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdGhlbWVJbnRlcm5hbDIsIHRoZW1lKTtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzIpIHx8ICF0aGVtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlVXNlclN0eWxlKGdldFRoZW1lQ1NTKFwiLk1hcGJveEFkZHJlc3NDb25maXJtYXRpb25cIiwgdGhlbWUpKTtcbiAgICBjb25zdCB7IENvbnRlbnRGZWF0dXJlLCBDb250ZW50Tm9GZWF0dXJlIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcyKTtcbiAgICBDb250ZW50RmVhdHVyZS50aGVtZSA9IHRoZW1lO1xuICAgIENvbnRlbnROb0ZlYXR1cmUudGhlbWUgPSB0aGVtZTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYmluZGluZzIsIGJpbmRFbGVtZW50cyh0aGlzLCB7XG4gICAgICBNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uOiBcIi5NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uXCIsXG4gICAgICBDb250ZW50RmVhdHVyZTogXCIuQ29udGVudEZlYXR1cmVcIixcbiAgICAgIENvbnRlbnROb0ZlYXR1cmU6IFwiLkNvbnRlbnROb0ZlYXR1cmVcIlxuICAgIH0pKTtcbiAgICBjb25zdCB7IE1hcGJveEFkZHJlc3NDb25maXJtYXRpb246IE1hcGJveEFkZHJlc3NDb25maXJtYXRpb24yIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcyKTtcbiAgICBNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uMi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgY29uc3QgdGhlbWUgPSB0aGlzLnRoZW1lO1xuICAgIGlmICh0aGVtZSkge1xuICAgICAgY29uc3QgeyBDb250ZW50RmVhdHVyZSwgQ29udGVudE5vRmVhdHVyZSB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nMik7XG4gICAgICBDb250ZW50RmVhdHVyZS50aGVtZSA9IHRoZW1lO1xuICAgICAgQ29udGVudE5vRmVhdHVyZS50aGVtZSA9IHRoZW1lO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2ZvY3VzVHJhcCwgbnVsbCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9zaG93LCBmYWxzZSk7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IE1hcGJveEFkZHJlc3NDb25maXJtYXRpb246IE1hcGJveEFkZHJlc3NDb25maXJtYXRpb24yIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcyKTtcbiAgICBNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uMi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgKF9hID0gX19wcml2YXRlR2V0KHRoaXMsIF9mb2N1c1RyYXApKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGVhY3RpdmF0ZSgpO1xuICAgIG5vU2Nyb2xsLm9mZigpO1xuICB9XG4gIHNob3coYXV0b2ZpbGxWYWx1ZXMsIG9wdGlvbnNBcmcsIGZlYXR1cmUpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmcyKSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImNhbmNlbFwiIH07XG4gICAgICB9XG4gICAgICBjb25zdCB7IE1hcGJveEFkZHJlc3NDb25maXJtYXRpb246IE1hcGJveEFkZHJlc3NDb25maXJtYXRpb24yLCBDb250ZW50RmVhdHVyZSwgQ29udGVudE5vRmVhdHVyZSB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nMik7XG4gICAgICBjb25zdCB7IGFjY2Vzc1Rva2VuLCBtaW5pbWFwID0gZmFsc2UsIHRoZW1lLCBmb290ZXIgfSA9IG9wdGlvbnNBcmc7XG4gICAgICB0aGlzLnRoZW1lID0gdGhlbWU7XG4gICAgICBpZiAoZmVhdHVyZSkge1xuICAgICAgICBDb250ZW50RmVhdHVyZS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICAgICAgQ29udGVudE5vRmVhdHVyZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIENvbnRlbnRGZWF0dXJlLm1pbmltYXAgPSBtaW5pbWFwO1xuICAgICAgICBDb250ZW50RmVhdHVyZS5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgICAgICBDb250ZW50RmVhdHVyZS5mb290ZXIgPSBmb290ZXI7XG4gICAgICAgIENvbnRlbnRGZWF0dXJlLnVwZGF0ZShmZWF0dXJlLCBhdXRvZmlsbFZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDb250ZW50RmVhdHVyZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIENvbnRlbnROb0ZlYXR1cmUucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG4gICAgICAgIENvbnRlbnROb0ZlYXR1cmUudXBkYXRlKGF1dG9maWxsVmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfc2hvdywgdHJ1ZSk7XG4gICAgICBNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uMi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICAgIG5vU2Nyb2xsLm9uKCk7XG4gICAgICBjb25zdCBhY3RpdmVDb250ZW50RWxlbWVudCA9IGZlYXR1cmUgPyBDb250ZW50RmVhdHVyZSA6IENvbnRlbnROb0ZlYXR1cmU7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2ZvY3VzVHJhcCwgY3JlYXRlRm9jdXNUcmFwKE1hcGJveEFkZHJlc3NDb25maXJtYXRpb24yLCB7XG4gICAgICAgIGZhbGxiYWNrRm9jdXM6IGFjdGl2ZUNvbnRlbnRFbGVtZW50LFxuICAgICAgICBlc2NhcGVEZWFjdGl2YXRlczogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICAoX2EgPSBfX3ByaXZhdGVHZXQodGhpcywgX2ZvY3VzVHJhcCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hY3RpdmF0ZSgpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50SG9zdCA9IGFjdGl2ZUNvbnRlbnRFbGVtZW50O1xuICAgICAgICBjb25zdCBmbiA9IChlKSA9PiB7XG4gICAgICAgICAgZXZlbnRIb3N0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXN1bHRcIiwgZm4pO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGUuZGV0YWlsO1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IFwiY2hhbmdlXCIpIHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImNoYW5nZVwiLFxuICAgICAgICAgICAgICBmZWF0dXJlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IHJlc3VsdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBldmVudEhvc3QuYWRkRXZlbnRMaXN0ZW5lcihcInJlc3VsdFwiLCBmbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICB0cnlTaG93KGF1dG9maWxsVmFsdWVzLCBvcHRpb25zQXJnKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nMikpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJjYW5jZWxcIiB9O1xuICAgICAgfVxuICAgICAgY29uc3QgeyBhY2Nlc3NUb2tlbiwgb3B0aW9ucyA9IHt9IH0gPSBvcHRpb25zQXJnO1xuICAgICAgY29uc3QgdmFsaWRhdGUgPSBuZXcgTWFwYm94VmFsaWRhdGUoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICBhY2Nlc3NUb2tlblxuICAgICAgfSwgb3B0aW9ucykpO1xuICAgICAgY29uc3Qgc2VhcmNoVGV4dCA9IGdldEF1dG9maWxsU2VhcmNoVGV4dChhdXRvZmlsbFZhbHVlcyk7XG4gICAgICBjb25zdCBmZWF0dXJlQ29sbGVjdGlvbiA9IHlpZWxkIHZhbGlkYXRlLnZhbGlkYXRlKHNlYXJjaFRleHQsIHtcbiAgICAgICAgc2Vzc2lvblRva2VuOiBjb25maWcuYXV0b2ZpbGxTZXNzaW9uVG9rZW5cbiAgICAgIH0pO1xuICAgICAgY29uc3QgZmVhdHVyZSA9IGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzWzBdO1xuICAgICAgaWYgKGZlYXR1cmUpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbGlkYXRpb24gPSAoZmVhdHVyZTIpID0+IGZlYXR1cmUyLnByb3BlcnRpZXMubWF0Y2hfY29kZS5jb25maWRlbmNlID09PSBNYXRjaENvZGVDb25maWRlbmNlLmV4YWN0O1xuICAgICAgICBjb25zdCB7IHNraXBDb25maXJtTW9kYWwgPSBkZWZhdWx0VmFsaWRhdGlvbiB9ID0gb3B0aW9uc0FyZztcbiAgICAgICAgaWYgKHNraXBDb25maXJtTW9kYWwoZmVhdHVyZSkpIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5vY2hhbmdlXCIgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuc2hvdyhhdXRvZmlsbFZhbHVlcywgb3B0aW9uc0FyZywgZmVhdHVyZSk7XG4gICAgfSk7XG4gIH1cbn07XG5fc2hvdyA9IG5ldyBXZWFrTWFwKCk7XG5fYmluZGluZzIgPSBuZXcgV2Vha01hcCgpO1xuX2ZvY3VzVHJhcCA9IG5ldyBXZWFrTWFwKCk7XG5fdGhlbWVJbnRlcm5hbDIgPSBuZXcgV2Vha01hcCgpO1xud2luZG93Lk1hcGJveEFkZHJlc3NDb25maXJtYXRpb24gPSBNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uO1xuaWYgKCF3aW5kb3cuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWFwYm94LWFkZHJlc3MtY29uZmlybWF0aW9uXCIpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcIm1hcGJveC1hZGRyZXNzLWNvbmZpcm1hdGlvblwiLCBNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uKTtcbn1cblxuLy8gc3JjL2NvbmZpcm1BZGRyZXNzLnRzXG52YXIgY29uZmlybWF0aW9uID0gbmV3IE1hcGJveEFkZHJlc3NDb25maXJtYXRpb24oKTtcbmZ1bmN0aW9uIGNvbmZpcm1BZGRyZXNzKF8wKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIChmb3JtLCBvcHRpb25zQXJnID0ge30pIHtcbiAgICBjb25zdCB7IHNlY3Rpb25zID0gW10gfSA9IG9wdGlvbnNBcmc7XG4gICAgaWYgKCFjb25maXJtYXRpb24ucGFyZW50Tm9kZSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb25maXJtYXRpb24pO1xuICAgIH1cbiAgICBsZXQgY29sbGVjdGVkUmVzdWx0ID0geyB0eXBlOiBcIm5vY2hhbmdlXCIgfTtcbiAgICBjb25zdCBpbnB1dHMgPSBmaW5kQWRkcmVzc0lucHV0cyhmb3JtKTtcbiAgICBjb25zdCBzdHJ1Y3R1cmUgPSBwYXJzZUZvcm1TdHJ1Y3R1cmUoZm9ybSk7XG4gICAgY29uc3QgbGlzdGJveENvbXBvbmVudHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJtYXBib3gtc2VhcmNoLWxpc3Rib3hcIikpO1xuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICBpZiAoc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHN0cnVjdHVyZVJlZiA9IHN0cnVjdHVyZS5maW5kKChzKSA9PiBzLmlucHV0ID09PSBpbnB1dCk7XG4gICAgICAgIGlmICghc3RydWN0dXJlUmVmKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWN0aW9ucy5pbmNsdWRlcyhzdHJ1Y3R1cmVSZWYuc2VjdGlvbikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYXV0b2ZpbGxWYWx1ZXMgPSBnZXRGb3JtQXV0b2ZpbGxWYWx1ZXMoZm9ybSwgaW5wdXQpO1xuICAgICAgY29uc3QgbGlzdGJveCA9IGxpc3Rib3hDb21wb25lbnRzLmZpbmQoKGxiKSA9PiBsYi5pbnB1dCA9PT0gaW5wdXQpO1xuICAgICAgaWYgKGxpc3Rib3gpIHtcbiAgICAgICAgY29uc3QgbGFzdFJldHJpZXZlZEZlYXR1cmUgPSBsaXN0Ym94LnJldHJpZXZlRmVhdHVyZTtcbiAgICAgICAgaWYgKGxhc3RSZXRyaWV2ZWRGZWF0dXJlKSB7XG4gICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBmZWF0dXJlVG9BdXRvZmlsbFZhbHVlTWFwKGxhc3RSZXRyaWV2ZWRGZWF0dXJlKTtcbiAgICAgICAgICBpZiAoIWNoZWNrQXV0b2ZpbGxWYWx1ZXNDaGFuZ2VkKGF1dG9maWxsVmFsdWVzLCBzbmFwc2hvdCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSBvcHRpb25zQXJnLmFjY2Vzc1Rva2VuIHx8IGNvbmZpZy5hY2Nlc3NUb2tlbjtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGNvbmZpcm1hdGlvbi50cnlTaG93KGF1dG9maWxsVmFsdWVzLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zQXJnKSwge1xuICAgICAgICBhY2Nlc3NUb2tlblxuICAgICAgfSkpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImNoYW5nZVwiKSB7XG4gICAgICAgIGlmIChsaXN0Ym94KSB7XG4gICAgICAgICAgbGlzdGJveC5zaW11bGF0ZVJldHJpZXZlKHJlc3VsdC5mZWF0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5kYXRhc2V0W1wibWFwYm94U3VjY2Vzc1wiXSA9IFwidHJ1ZVwiO1xuICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBmZWF0dXJlVG9TdWdnZXN0aW9uMihyZXN1bHQuZmVhdHVyZSk7XG4gICAgICAgICAgc2V0Rm9ybUF1dG9maWxsVmFsdWVzKGZvcm0sIGlucHV0LCBzdWdnZXN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImNoYW5nZVwiICYmIGNvbGxlY3RlZFJlc3VsdC50eXBlICE9PSBcImNhbmNlbFwiKSB7XG4gICAgICAgIGNvbGxlY3RlZFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJjYW5jZWxcIikge1xuICAgICAgICBjb2xsZWN0ZWRSZXN1bHQgPSByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0ZWRSZXN1bHQ7XG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbHMvY29uZmlybWF0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVBZGRyZXNzRWxlbWVudChhdXRvZmlsbFZhbHVlcywgYmFzZUFkZHJlc3MpIHtcbiAgaWYgKGJhc2VBZGRyZXNzKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRGcm9tU3RyaW5nKGBcbiAgICAgICAgPHNwYW4+XG4gICAgICAgICAgPHNwYW4+PC9zcGFuPlxuICAgICAgICAgIDxiciAvPlxuICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgYCk7XG4gICAgY29uc3QgW2ZpcnN0TGluZSwgbGFzdExpbmVdID0gQXJyYXkuZnJvbShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzcGFuID4gc3BhblwiKSk7XG4gICAgY29uc3QgcGFydHMgPSBiYXNlQWRkcmVzcy5zcGxpdChcIixcIik7XG4gICAgZmlyc3RMaW5lLnRleHRDb250ZW50ID0gcGFydHNbMF0udHJpbSgpO1xuICAgIGxhc3RMaW5lLnRleHRDb250ZW50ID0gcGFydHMuc2xpY2UoMSkuam9pbihcIixcIikudHJpbSgpO1xuICAgIGlmIChhdXRvZmlsbFZhbHVlc1tcImFkZHJlc3MtbGluZTJcIl0pIHtcbiAgICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBhdXRvZmlsbFZhbHVlc1tcImFkZHJlc3MtbGluZTJcIl07XG4gICAgICBlbGVtZW50Lmluc2VydEJlZm9yZShzcGFuLCBsYXN0TGluZSk7XG4gICAgICBlbGVtZW50Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIiksIGxhc3RMaW5lKTtcbiAgICB9XG4gICAgaWYgKGF1dG9maWxsVmFsdWVzW1wiYWRkcmVzcy1saW5lM1wiXSkge1xuICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IGF1dG9maWxsVmFsdWVzW1wiYWRkcmVzcy1saW5lM1wiXTtcbiAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKHNwYW4sIGxhc3RMaW5lKTtcbiAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSwgbGFzdExpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmaXJzdExpbmUgPSBhdXRvZmlsbFZhbHVlc1tcInN0cmVldC1hZGRyZXNzXCJdIHx8IGF1dG9maWxsVmFsdWVzW1wiYWRkcmVzcy1saW5lMVwiXSB8fCBcIlwiO1xuICAgIGNvbnN0IGxpbmUyID0gYXV0b2ZpbGxWYWx1ZXNbXCJhZGRyZXNzLWxpbmUyXCJdO1xuICAgIGNvbnN0IGxpbmUzID0gYXV0b2ZpbGxWYWx1ZXNbXCJhZGRyZXNzLWxpbmUzXCJdO1xuICAgIGNvbnN0IGxhc3RMaW5lID0gW1xuICAgICAgYXV0b2ZpbGxWYWx1ZXNbXCJhZGRyZXNzLWxldmVsNFwiXSB8fCBcIlwiLFxuICAgICAgYXV0b2ZpbGxWYWx1ZXNbXCJhZGRyZXNzLWxldmVsM1wiXSB8fCBcIlwiLFxuICAgICAgYXV0b2ZpbGxWYWx1ZXNbXCJhZGRyZXNzLWxldmVsMlwiXSB8fCBcIlwiLFxuICAgICAgYCR7YXV0b2ZpbGxWYWx1ZXNbXCJhZGRyZXNzLWxldmVsMVwiXSB8fCBcIlwifSAke2F1dG9maWxsVmFsdWVzW1wicG9zdGFsLWNvZGVcIl0gfHwgXCJcIn1gLFxuICAgICAgYXV0b2ZpbGxWYWx1ZXMuY291bnRyeSB8fCBhdXRvZmlsbFZhbHVlc1tcImNvdW50cnktbmFtZVwiXSB8fCBcIlwiXG4gICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IGFkZHJlc3NMaW5lcyA9IFtmaXJzdExpbmUsIGxpbmUyLCBsaW5lMywgbGFzdExpbmVdLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBhZGRyZXNzTGluZXNIdG1sID0gYWRkcmVzc0xpbmVzLm1hcCgodmFsKSA9PiBgPHNwYW4+JHt2YWx9PC9zcGFuPmApLmpvaW4oXCI8YnIgLz5cIik7XG4gICAgY29uc3QgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRGcm9tU3RyaW5nKGBcbiAgICAgICAgPHNwYW4+JHthZGRyZXNzTGluZXNIdG1sfTwvc3Bhbj5cbiAgICAgIGApO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5mdW5jdGlvbiB0cnlDb25maXJtQnJvd3NlckF1dG9maWxsKGlucHV0LCBldmVudCwgY29uZmlybU9uQnJvd3NlckF1dG9maWxsLCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGlmICghY29uZmlybU9uQnJvd3NlckF1dG9maWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBhcmVudEZvcm0gPSBmaW5kUGFyZW50Rm9ybShpbnB1dCk7XG4gICAgY29uc3QgZm9ybUVsZW1lbnRzID0gT2JqZWN0LnZhbHVlcyhmaW5kQWRkcmVzc0F1dG9maWxsSW5wdXRzKHBhcmVudEZvcm0sIGlucHV0KSk7XG4gICAgaWYgKCFldmVudC5kZXRhaWwuZWxlbWVudHMuc29tZSgoZWwpID0+IGZvcm1FbGVtZW50cy5pbmNsdWRlcyhlbCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0cnVjdHVyZSA9IHBhcnNlRm9ybVN0cnVjdHVyZShwYXJlbnRGb3JtKTtcbiAgICBjb25zdCBzdHJ1Y3R1cmVSZWYgPSBzdHJ1Y3R1cmUuZmluZCgocykgPT4gcy5pbnB1dCA9PT0gaW5wdXQpO1xuICAgIGNvbnN0IGF1dG9maWxsSW5zdGFuY2VTZWN0aW9uID0gc3RydWN0dXJlUmVmLnNlY3Rpb247XG4gICAgY29uc3QgYnJvd3NlckF1dG9maWxsZWRTZWN0aW9ucyA9IEFycmF5LmZyb20obmV3IFNldChzdHJ1Y3R1cmUuZmlsdGVyKChzKSA9PiBldmVudC5kZXRhaWwuZWxlbWVudHMuaW5jbHVkZXMocy5pbnB1dCkpLm1hcCgocykgPT4gcy5zZWN0aW9uKSkpO1xuICAgIGlmICghYnJvd3NlckF1dG9maWxsZWRTZWN0aW9ucy5pbmNsdWRlcyhhdXRvZmlsbEluc3RhbmNlU2VjdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9uc1NlY3Rpb25zID0gdHlwZW9mIGNvbmZpcm1PbkJyb3dzZXJBdXRvZmlsbCA9PT0gXCJvYmplY3RcIiAmJiBjb25maXJtT25Ccm93c2VyQXV0b2ZpbGwuc2VjdGlvbnMgfHwgW107XG4gICAgaWYgKG9wdGlvbnNTZWN0aW9ucy5sZW5ndGggJiYgIW9wdGlvbnNTZWN0aW9ucy5zb21lKChzZWN0aW9uKSA9PiBicm93c2VyQXV0b2ZpbGxlZFNlY3Rpb25zLmluY2x1ZGVzKHNlY3Rpb24pKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgb3B0aW9uc0FyZyA9IHR5cGVvZiBjb25maXJtT25Ccm93c2VyQXV0b2ZpbGwgPT09IFwib2JqZWN0XCIgPyBjb25maXJtT25Ccm93c2VyQXV0b2ZpbGwgOiB7fTtcbiAgICBvcHRpb25zQXJnID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9uc0FyZyksIHtcbiAgICAgIGFjY2Vzc1Rva2VuLFxuICAgICAgc2VjdGlvbnM6IFthdXRvZmlsbEluc3RhbmNlU2VjdGlvbl1cbiAgICB9KTtcbiAgICB5aWVsZCBjb25maXJtQWRkcmVzcyhwYXJlbnRGb3JtLCBvcHRpb25zQXJnKTtcbiAgfSk7XG59XG5cbi8vIHNyYy91dGlscy9jb250cmlidXRlLnRzXG52YXIgQ09OVFJJQlVURV9BUElfQkFTRV9VUkwgPSBcImh0dHBzOi8vY29udHJpYnV0ZS1hcGkubWFwYm94LmNvbS92MVwiO1xudmFyIENPTlRSSUJVVEVfQVBJX1NUQUdJTkdfQkFTRV9VUkwgPSBcImh0dHBzOi8vY29udHJpYnV0ZS1hcGktc3RhZ2luZy50aWxlc3RyZWFtLm5ldC92MVwiO1xudmFyIEVESVRfU1VHR0VTVElPTl9FTkRQT0lOVCA9IFwiZWRpdC1zdWdnZXN0aW9uXCI7XG5mdW5jdGlvbiBzZW5kRmVlZGJhY2soYWNjZXNzVG9rZW4sIGZlZWRiYWNrQXJncykge1xuICBpZiAoIWNvbmZpZy5mZWVkYmFja0VuYWJsZWQpXG4gICAgcmV0dXJuO1xuICBjb25zdCBob3N0bmFtZSA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgY29uc3QgQkFTRV9VUkwgPSBpc0xvY2FsU2VydmVyKGhvc3RuYW1lKSB8fCBpc01hcGJveERvbWFpbihob3N0bmFtZSkgPyBDT05UUklCVVRFX0FQSV9TVEFHSU5HX0JBU0VfVVJMIDogQ09OVFJJQlVURV9BUElfQkFTRV9VUkw7XG4gIGNvbnN0IHVybCA9IGAke0JBU0VfVVJMfS8ke0VESVRfU1VHR0VTVElPTl9FTkRQT0lOVH0vYWRkcmVzcz9hY2Nlc3NfdG9rZW49JHthY2Nlc3NUb2tlbn1gO1xuICBjb25zdCB7IG9yaWdpbmFsQ29vcmRpbmF0ZSwgb3JpZ2luYWxBZGRyZXNzLCBjaGFuZ2VzIH0gPSBmZWVkYmFja0FyZ3M7XG4gIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgYWN0aW9uOiBcInVwZGF0ZVwiLFxuICAgIHJlYXNvbjogXCJpbmNvcnJlY3RfYWRkcmVzc1wiLFxuICAgIGxvY2F0aW9uOiB7XG4gICAgICBsb25naXR1ZGU6IG9yaWdpbmFsQ29vcmRpbmF0ZVswXSxcbiAgICAgIGxhdGl0dWRlOiBvcmlnaW5hbENvb3JkaW5hdGVbMV1cbiAgICB9LFxuICAgIHVzZXJFbWFpbDogXCJuby1yZXBseS1hdXRvZmlsbEBtYXBib3guY29tXCIsXG4gICAgY2hhbmdlcyxcbiAgICBwbGFjZU5hbWU6IG9yaWdpbmFsQWRkcmVzc1xuICB9O1xuICBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHtcbiAgICAgIFwiVXNlci1BZ2VudFwiOiBgbWFwYm94LXNlYXJjaC1qcy4ke3ZlcnNpb259LiR7bmF2aWdhdG9yLnVzZXJBZ2VudH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9KSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKVxuICB9KTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbkZlYXR1cmUudHNcbnZhciBURU1QTEFURTMgPSBjcmVhdGVFbGVtZW50RnJvbVN0cmluZyhgXG48dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uRmVhdHVyZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJNb2RhbFwiIGFyaWEtbW9kYWw9XCJ0cnVlXCIgcm9sZT1cImRpYWxvZ1wiPlxuICAgICAgPGRpdiBjbGFzcz1cIk1vZGFsSGVhZGVyXCI+XG4gICAgICAgIDxzdmcgdmlld0JveD1cIjAgMCAxOCAxOFwiIGNsYXNzPVwiSWNvbiBJY29uUXVlc3Rpb25cIj48L3N2Zz5cbiAgICAgICAgPGRpdiBjbGFzcz1cIk1vZGFsSGVhZGVyVGl0bGVcIj5EaWQgeW91IG1lYW4/PC9kaXY+XG4gICAgICAgIDxzdmdcbiAgICAgICAgICB2aWV3Qm94PVwiMCAwIDE4IDE4XCJcbiAgICAgICAgICBjbGFzcz1cIkljb24gSWNvbkNsb3NlXCJcbiAgICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgIHRpdGxlPVwiQ2xvc2VcIlxuICAgICAgICAgIGFyaWEtbGFiZWw9XCJDbG9zZVwiXG4gICAgICAgICAgYXJpYS1leHBhbmRlZD1cInRydWVcIlxuICAgICAgICA+PC9zdmc+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzcz1cIk1vZGFsQWRkcmVzcyBNb2RhbEFkZHJlc3NBcHByb3ZlXCI+PC9kaXY+XG4gICAgICAgICAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJNb2RhbE1hcFwiPlxuICAgICAgICA8bWFwYm94LWFkZHJlc3MtbWluaW1hcCBjbGFzcz1cIk1pbmltYXBcIj48L21hcGJveC1hZGRyZXNzLW1pbmltYXA+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdlxuICAgICAgICBjbGFzcz1cIkJ1dHRvbiBCdXR0b25QcmltYXJ5IEJ1dHRvbkFwcHJvdmVcIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgYXJpYS1sYWJlbD1cIlllc1wiXG4gICAgICA+XG4gICAgICAgIFllc1xuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJCdXR0b24gQnV0dG9uU2Vjb25kYXJ5IEJ1dHRvblJlamVjdFwiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICBhcmlhLWxhYmVsPVwiTm8sIHVzZSB0aGUgYWRkcmVzcyBJIHByb3ZpZGVkXCJcbiAgICAgID5cbiAgICAgICAgTm8sIHVzZSB0aGUgYWRkcmVzcyBJIHByb3ZpZGVkXG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzcz1cIk1vZGFsRm9vdGVyXCI+XG4gICAgICAgICAgWW91ciBjb25maXJtYXRpb24gaGVscHMgaW1wcm92ZSBhZGRyZXNzIGRhdGEgYWNjdXJhY3kuXG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuYCk7XG52YXIgX2JpbmRpbmczLCBfdGhlbWVJbnRlcm5hbDMsIF9mZWF0dXJlLCBfZm9ybVZhbHVlcywgX2hhbmRsZUNsb3NlLCBfbW9kYWxJRCwgX21vZGFsSGVhZGVyVGl0bGVJRCwgX21vZGFsQWRkcmVzc0FwcHJvdmVJRDtcbnZhciBNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uRmVhdHVyZSA9IGNsYXNzIGV4dGVuZHMgSFRNTFNjb3BlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYmluZGluZzMsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90aGVtZUludGVybmFsMywge30pO1xuICAgIHRoaXMubWluaW1hcCA9IGZhbHNlO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZmVhdHVyZSwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2Zvcm1WYWx1ZXMsIHZvaWQgMCk7XG4gICAgdGhpcy51cGRhdGUgPSAoZmVhdHVyZSwgYXV0b2ZpbGxWYWx1ZXMpID0+IHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZmVhdHVyZSwgZmVhdHVyZSk7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2Zvcm1WYWx1ZXMsIGF1dG9maWxsVmFsdWVzKTtcbiAgICAgIGNvbnN0IHsgTW9kYWxNYXAsIE1pbmltYXAsIE1vZGFsQWRkcmVzc0FwcHJvdmUgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzMpO1xuICAgICAgaWYgKHRoaXMubWluaW1hcCkge1xuICAgICAgICBNb2RhbE1hcC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICAgICAgTWluaW1hcC5hY2Nlc3NUb2tlbiA9IHRoaXMuYWNjZXNzVG9rZW47XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5taW5pbWFwID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgY29uc3QgeyBkZWZhdWx0TWFwU3R5bGUsIHRoZW1lLCBtYXBTdHlsZU1vZGUsIHNhdGVsbGl0ZVRvZ2dsZSB9ID0gdGhpcy5taW5pbWFwO1xuICAgICAgICAgIGRlZmF1bHRNYXBTdHlsZSAmJiAoTWluaW1hcC5kZWZhdWx0TWFwU3R5bGUgPSB0aGlzLm1pbmltYXAuZGVmYXVsdE1hcFN0eWxlKTtcbiAgICAgICAgICB0aGVtZSAmJiAoTWluaW1hcC50aGVtZSA9IHRoaXMubWluaW1hcC50aGVtZSk7XG4gICAgICAgICAgbWFwU3R5bGVNb2RlICYmIChNaW5pbWFwLm1hcFN0eWxlTW9kZSA9IG1hcFN0eWxlTW9kZSk7XG4gICAgICAgICAgc2F0ZWxsaXRlVG9nZ2xlICE9PSB2b2lkIDAgJiYgKE1pbmltYXAuc2F0ZWxsaXRlVG9nZ2xlID0gc2F0ZWxsaXRlVG9nZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICBNaW5pbWFwLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTW9kYWxNYXAuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXBwcm92ZUFkZHJlc3MgPSBmZWF0dXJlLnByb3BlcnRpZXMucGxhY2VfbmFtZSB8fCBmZWF0dXJlLnByb3BlcnRpZXMuZnVsbF9hZGRyZXNzIHx8IGZlYXR1cmUucHJvcGVydGllcy5hZGRyZXNzO1xuICAgICAgTW9kYWxBZGRyZXNzQXBwcm92ZS5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgTW9kYWxBZGRyZXNzQXBwcm92ZS5hcHBlbmRDaGlsZChjcmVhdGVBZGRyZXNzRWxlbWVudChhdXRvZmlsbFZhbHVlcywgYXBwcm92ZUFkZHJlc3MpKTtcbiAgICB9O1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlQ2xvc2UsICgpID0+IHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwicmVzdWx0XCIsIFwiY2FuY2VsXCIpKTtcbiAgICB9KTtcbiAgICB0aGlzLmFwcHJvdmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcGJveEhUTUxFdmVudChcInJlc3VsdFwiLCBcImNoYW5nZVwiKSk7XG4gICAgfTtcbiAgICB0aGlzLnJlamVjdCA9ICgpID0+IHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KFwicmVzdWx0XCIsIFwibm9jaGFuZ2VcIikpO1xuICAgICAgc2VuZEZlZWRiYWNrKHRoaXMuYWNjZXNzVG9rZW4sIHtcbiAgICAgICAgb3JpZ2luYWxDb29yZGluYXRlOiBfX3ByaXZhdGVHZXQodGhpcywgX2ZlYXR1cmUpLmdlb21ldHJ5LmNvb3JkaW5hdGVzLFxuICAgICAgICBvcmlnaW5hbEFkZHJlc3M6IF9fcHJpdmF0ZUdldCh0aGlzLCBfZmVhdHVyZSkucHJvcGVydGllcy5mdWxsX2FkZHJlc3MsXG4gICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICBhZGRyZXNzOiBnZXRBdXRvZmlsbFNlYXJjaFRleHQoX19wcml2YXRlR2V0KHRoaXMsIF9mb3JtVmFsdWVzKSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21vZGFsSUQsIHJhbmRvbVZhbGlkSUQoKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tb2RhbEhlYWRlclRpdGxlSUQsIHJhbmRvbVZhbGlkSUQoKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tb2RhbEFkZHJlc3NBcHByb3ZlSUQsIHJhbmRvbVZhbGlkSUQoKSk7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBURU1QTEFURTM7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlU3R5bGUoKSB7XG4gICAgcmV0dXJuIHN0eWxlX2RlZmF1bHQ7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlVXNlclN0eWxlKCkge1xuICAgIHJldHVybiBnZXRUaGVtZUNTUyhcIi5NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uRmVhdHVyZVwiLCB0aGlzLnRoZW1lKTtcbiAgfVxuICBnZXQgdGhlbWUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfdGhlbWVJbnRlcm5hbDMpO1xuICB9XG4gIHNldCB0aGVtZSh0aGVtZSkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdGhlbWVJbnRlcm5hbDMsIHRoZW1lKTtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzMpIHx8ICF0aGVtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlVXNlclN0eWxlKGdldFRoZW1lQ1NTKFwiLk1hcGJveEFkZHJlc3NDb25maXJtYXRpb25GZWF0dXJlXCIsIHRoZW1lKSk7XG4gICAgY29uc3QgeyBJY29uUXVlc3Rpb24sIEljb25DbG9zZSB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nMyk7XG4gICAgSWNvblF1ZXN0aW9uLmlubmVySFRNTCA9IGdldEljb24oXCJxdWVzdGlvblwiLCB0aGVtZSk7XG4gICAgSWNvbkNsb3NlLmlubmVySFRNTCA9IGdldEljb24oXCJjbG9zZVwiLCB0aGVtZSk7XG4gIH1cbiAgc2V0IGZvb3Rlcih2YWwpIHtcbiAgICBpZiAodmFsID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZm9vdGVyRWwgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoXCIuTW9kYWxGb290ZXJcIik7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZvb3RlckVsLnRleHRDb250ZW50ID0gdmFsO1xuICAgICAgZm9vdGVyRWwucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG4gICAgfSBlbHNlIGlmICghdmFsKSB7XG4gICAgICBmb290ZXJFbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvb3RlckVsLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYmluZGluZzMsIGJpbmRFbGVtZW50cyh0aGlzLCB7XG4gICAgICBNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uRmVhdHVyZTogXCIuTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbkZlYXR1cmVcIixcbiAgICAgIE1vZGFsOiBcIi5Nb2RhbFwiLFxuICAgICAgTW9kYWxIZWFkZXJUaXRsZTogXCIuTW9kYWxIZWFkZXJUaXRsZVwiLFxuICAgICAgTW9kYWxNYXA6IFwiLk1vZGFsTWFwXCIsXG4gICAgICBNaW5pbWFwOiBcIi5NaW5pbWFwXCIsXG4gICAgICBJY29uUXVlc3Rpb246IFwiLkljb25RdWVzdGlvblwiLFxuICAgICAgSWNvbkNsb3NlOiBcIi5JY29uQ2xvc2VcIixcbiAgICAgIEJ1dHRvbkFwcHJvdmU6IFwiLkJ1dHRvbkFwcHJvdmVcIixcbiAgICAgIEJ1dHRvblJlamVjdDogXCIuQnV0dG9uUmVqZWN0XCIsXG4gICAgICBNb2RhbEFkZHJlc3NBcHByb3ZlOiBcIi5Nb2RhbEFkZHJlc3NBcHByb3ZlXCJcbiAgICB9KSk7XG4gICAgY29uc3Qge1xuICAgICAgTW9kYWwsXG4gICAgICBNb2RhbEhlYWRlclRpdGxlLFxuICAgICAgSWNvbkNsb3NlLFxuICAgICAgQnV0dG9uQXBwcm92ZSxcbiAgICAgIEJ1dHRvblJlamVjdCxcbiAgICAgIE1vZGFsQWRkcmVzc0FwcHJvdmVcbiAgICB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nMyk7XG4gICAgTW9kYWwuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbGxlZGJ5XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfbW9kYWxIZWFkZXJUaXRsZUlEKSk7XG4gICAgTW9kYWwuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX21vZGFsQWRkcmVzc0FwcHJvdmVJRCkpO1xuICAgIEljb25DbG9zZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfbW9kYWxJRCkpO1xuICAgIE1vZGFsLmlkID0gX19wcml2YXRlR2V0KHRoaXMsIF9tb2RhbElEKTtcbiAgICBNb2RhbEhlYWRlclRpdGxlLmlkID0gX19wcml2YXRlR2V0KHRoaXMsIF9tb2RhbEhlYWRlclRpdGxlSUQpO1xuICAgIE1vZGFsQWRkcmVzc0FwcHJvdmUuaWQgPSBfX3ByaXZhdGVHZXQodGhpcywgX21vZGFsQWRkcmVzc0FwcHJvdmVJRCk7XG4gICAgY29uc3QgYnV0dG9ucyA9IEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cImJ1dHRvblwiXScpKTtcbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiBidXR0b25zKSB7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgYXJpYUJ1dHRvbktleURvd24pO1xuICAgIH1cbiAgICBJY29uQ2xvc2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlQ2xvc2UpKTtcbiAgICBCdXR0b25BcHByb3ZlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmFwcHJvdmUpO1xuICAgIEJ1dHRvblJlamVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5yZWplY3QpO1xuICAgIGNvbnN0IHRoZW1lID0gdGhpcy50aGVtZTtcbiAgICBpZiAodGhlbWUpIHtcbiAgICAgIGNvbnN0IHsgSWNvblF1ZXN0aW9uLCBJY29uQ2xvc2U6IEljb25DbG9zZTIgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzMpO1xuICAgICAgSWNvblF1ZXN0aW9uLmlubmVySFRNTCA9IGdldEljb24oXCJxdWVzdGlvblwiLCB0aGVtZSk7XG4gICAgICBJY29uQ2xvc2UyLmlubmVySFRNTCA9IGdldEljb24oXCJjbG9zZVwiLCB0aGVtZSk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IHsgSWNvbkNsb3NlLCBCdXR0b25BcHByb3ZlIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmczKTtcbiAgICBJY29uQ2xvc2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlQ2xvc2UpKTtcbiAgICBCdXR0b25BcHByb3ZlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmFwcHJvdmUpO1xuICB9XG59O1xuX2JpbmRpbmczID0gbmV3IFdlYWtNYXAoKTtcbl90aGVtZUludGVybmFsMyA9IG5ldyBXZWFrTWFwKCk7XG5fZmVhdHVyZSA9IG5ldyBXZWFrTWFwKCk7XG5fZm9ybVZhbHVlcyA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlQ2xvc2UgPSBuZXcgV2Vha01hcCgpO1xuX21vZGFsSUQgPSBuZXcgV2Vha01hcCgpO1xuX21vZGFsSGVhZGVyVGl0bGVJRCA9IG5ldyBXZWFrTWFwKCk7XG5fbW9kYWxBZGRyZXNzQXBwcm92ZUlEID0gbmV3IFdlYWtNYXAoKTtcbndpbmRvdy5NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uRmVhdHVyZSA9IE1hcGJveEFkZHJlc3NDb25maXJtYXRpb25GZWF0dXJlO1xuaWYgKCF3aW5kb3cuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWFwYm94LWFkZHJlc3MtY29uZmlybWF0aW9uLWZlYXR1cmVcIikpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWFwYm94LWFkZHJlc3MtY29uZmlybWF0aW9uLWZlYXR1cmVcIiwgTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbkZlYXR1cmUpO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uTm9GZWF0dXJlLnRzXG52YXIgVEVNUExBVEU0ID0gY3JlYXRlRWxlbWVudEZyb21TdHJpbmcoYFxuPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbk5vRmVhdHVyZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJNb2RhbFwiIGFyaWEtbW9kYWw9XCJ0cnVlXCIgcm9sZT1cImRpYWxvZ1wiPlxuICAgICAgPGRpdiBjbGFzcz1cIk1vZGFsSGVhZGVyXCI+XG4gICAgICAgIDxzdmcgdmlld0JveD1cIjAgMCAxOCAxOFwiIGNsYXNzPVwiSWNvbiBJY29uUXVlc3Rpb25cIj48L3N2Zz5cbiAgICAgICAgPGRpdiBjbGFzcz1cIk1vZGFsSGVhZGVyVGl0bGVcIj5Db25maXJtIGFkZHJlc3M8L2Rpdj5cbiAgICAgICAgPHN2Z1xuICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMTggMThcIlxuICAgICAgICAgIGNsYXNzPVwiSWNvbiBJY29uQ2xvc2VcIlxuICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgdGl0bGU9XCJDbG9zZVwiXG4gICAgICAgICAgYXJpYS1sYWJlbD1cIkNsb3NlXCJcbiAgICAgICAgICBhcmlhLWV4cGFuZGVkPVwidHJ1ZVwiXG4gICAgICAgID48L3N2Zz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cIk1vZGFsRGVzY3JpcHRpb25cIj5cbiAgICAgICAgV2UgY291bGRuJ3QgdmVyaWZ5IHRoaXMgYWRkcmVzcy4gUGxlYXNlIGNoZWNrIHRoYXQgeW91ciBpbmZvcm1hdGlvbiBpcyBjb3JyZWN0IGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgPC9kaXY+XG4gICAgICA8YnIgLz5cbiAgICAgIDxkaXYgY2xhc3M9XCJNb2RhbFN1YmhlYWRlclwiPlxuICAgICAgICBZb3UgZW50ZXJlZFxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiTW9kYWxBZGRyZXNzXCI+PC9kaXY+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwiQnV0dG9uIEJ1dHRvblByaW1hcnlcIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgYXJpYS1sYWJlbD1cIlVzZSB0aGUgYWRkcmVzcyBJIHByb3ZpZGVkXCJcbiAgICAgID5cbiAgICAgICAgVXNlIHRoZSBhZGRyZXNzIEkgcHJvdmlkZWRcbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5gKTtcbnZhciBfYmluZGluZzQsIF90aGVtZUludGVybmFsNCwgX2hhbmRsZUNsb3NlMiwgX21vZGFsSUQyLCBfbW9kYWxIZWFkZXJUaXRsZUlEMiwgX21vZGFsQWRkcmVzc0lEO1xudmFyIE1hcGJveEFkZHJlc3NDb25maXJtYXRpb25Ob0ZlYXR1cmUgPSBjbGFzcyBleHRlbmRzIEhUTUxTY29wZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2JpbmRpbmc0LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdGhlbWVJbnRlcm5hbDQsIHt9KTtcbiAgICB0aGlzLnVwZGF0ZSA9IChhdXRvZmlsbFZhbHVlcykgPT4ge1xuICAgICAgY29uc3QgeyBNb2RhbEFkZHJlc3MgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzQpO1xuICAgICAgTW9kYWxBZGRyZXNzLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICBNb2RhbEFkZHJlc3MuYXBwZW5kQ2hpbGQoY3JlYXRlQWRkcmVzc0VsZW1lbnQoYXV0b2ZpbGxWYWx1ZXMpKTtcbiAgICB9O1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlQ2xvc2UyLCAoKSA9PiB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcGJveEhUTUxFdmVudChcInJlc3VsdFwiLCBcImNhbmNlbFwiKSk7XG4gICAgfSk7XG4gICAgdGhpcy5yZWplY3QgPSAoKSA9PiB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcGJveEhUTUxFdmVudChcInJlc3VsdFwiLCBcIm5vY2hhbmdlXCIpKTtcbiAgICB9O1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbW9kYWxJRDIsIHJhbmRvbVZhbGlkSUQoKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tb2RhbEhlYWRlclRpdGxlSUQyLCByYW5kb21WYWxpZElEKCkpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbW9kYWxBZGRyZXNzSUQsIHJhbmRvbVZhbGlkSUQoKSk7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBURU1QTEFURTQ7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlU3R5bGUoKSB7XG4gICAgcmV0dXJuIHN0eWxlX2RlZmF1bHQ7XG4gIH1cbiAgZ2V0IHRlbXBsYXRlVXNlclN0eWxlKCkge1xuICAgIHJldHVybiBnZXRUaGVtZUNTUyhcIi5NYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uTm9GZWF0dXJlXCIsIHRoaXMudGhlbWUpO1xuICB9XG4gIGdldCB0aGVtZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF90aGVtZUludGVybmFsNCk7XG4gIH1cbiAgc2V0IHRoZW1lKHRoZW1lKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF90aGVtZUludGVybmFsNCwgdGhlbWUpO1xuICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNCkgfHwgIXRoZW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGVtcGxhdGVVc2VyU3R5bGUoZ2V0VGhlbWVDU1MoXCIuTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbk5vRmVhdHVyZVwiLCB0aGVtZSkpO1xuICAgIGNvbnN0IHsgSWNvblF1ZXN0aW9uLCBJY29uQ2xvc2UgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzQpO1xuICAgIEljb25RdWVzdGlvbi5pbm5lckhUTUwgPSBnZXRJY29uKFwicXVlc3Rpb25cIiwgdGhlbWUpO1xuICAgIEljb25DbG9zZS5pbm5lckhUTUwgPSBnZXRJY29uKFwiY2xvc2VcIiwgdGhlbWUpO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9iaW5kaW5nNCwgYmluZEVsZW1lbnRzKHRoaXMsIHtcbiAgICAgIE1vZGFsOiBcIi5Nb2RhbFwiLFxuICAgICAgTW9kYWxIZWFkZXJUaXRsZTogXCIuTW9kYWxIZWFkZXJUaXRsZVwiLFxuICAgICAgSWNvblF1ZXN0aW9uOiBcIi5JY29uUXVlc3Rpb25cIixcbiAgICAgIEljb25DbG9zZTogXCIuSWNvbkNsb3NlXCIsXG4gICAgICBNb2RhbEFkZHJlc3M6IFwiLk1vZGFsQWRkcmVzc1wiLFxuICAgICAgQnV0dG9uUmVqZWN0OiBcIi5CdXR0b25cIlxuICAgIH0pKTtcbiAgICBjb25zdCB7IE1vZGFsLCBNb2RhbEhlYWRlclRpdGxlLCBJY29uQ2xvc2UsIE1vZGFsQWRkcmVzcywgQnV0dG9uUmVqZWN0IH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc0KTtcbiAgICBNb2RhbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9tb2RhbEhlYWRlclRpdGxlSUQyKSk7XG4gICAgTW9kYWwuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX21vZGFsQWRkcmVzc0lEKSk7XG4gICAgSWNvbkNsb3NlLnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9tb2RhbElEMikpO1xuICAgIE1vZGFsLmlkID0gX19wcml2YXRlR2V0KHRoaXMsIF9tb2RhbElEMik7XG4gICAgTW9kYWxIZWFkZXJUaXRsZS5pZCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbW9kYWxIZWFkZXJUaXRsZUlEMik7XG4gICAgTW9kYWxBZGRyZXNzLmlkID0gX19wcml2YXRlR2V0KHRoaXMsIF9tb2RhbEFkZHJlc3NJRCk7XG4gICAgY29uc3QgYnV0dG9ucyA9IEFycmF5LmZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cImJ1dHRvblwiXScpKTtcbiAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiBidXR0b25zKSB7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgYXJpYUJ1dHRvbktleURvd24pO1xuICAgIH1cbiAgICBJY29uQ2xvc2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlQ2xvc2UyKSk7XG4gICAgQnV0dG9uUmVqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnJlamVjdCk7XG4gICAgY29uc3QgdGhlbWUgPSB0aGlzLnRoZW1lO1xuICAgIGlmICh0aGVtZSkge1xuICAgICAgY29uc3QgeyBJY29uUXVlc3Rpb24sIEljb25DbG9zZTogSWNvbkNsb3NlMiB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNCk7XG4gICAgICBJY29uUXVlc3Rpb24uaW5uZXJIVE1MID0gZ2V0SWNvbihcInF1ZXN0aW9uXCIsIHRoZW1lKTtcbiAgICAgIEljb25DbG9zZTIuaW5uZXJIVE1MID0gZ2V0SWNvbihcImNsb3NlXCIsIHRoZW1lKTtcbiAgICB9XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29uc3QgeyBJY29uQ2xvc2UsIEJ1dHRvblJlamVjdCB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNCk7XG4gICAgSWNvbkNsb3NlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUNsb3NlMikpO1xuICAgIEJ1dHRvblJlamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5yZWplY3QpO1xuICB9XG59O1xuX2JpbmRpbmc0ID0gbmV3IFdlYWtNYXAoKTtcbl90aGVtZUludGVybmFsNCA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlQ2xvc2UyID0gbmV3IFdlYWtNYXAoKTtcbl9tb2RhbElEMiA9IG5ldyBXZWFrTWFwKCk7XG5fbW9kYWxIZWFkZXJUaXRsZUlEMiA9IG5ldyBXZWFrTWFwKCk7XG5fbW9kYWxBZGRyZXNzSUQgPSBuZXcgV2Vha01hcCgpO1xud2luZG93Lk1hcGJveEFkZHJlc3NDb25maXJtYXRpb25Ob0ZlYXR1cmUgPSBNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uTm9GZWF0dXJlO1xuaWYgKCF3aW5kb3cuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWFwYm94LWFkZHJlc3MtY29uZmlybWF0aW9uLW5vLWZlYXR1cmVcIikpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWFwYm94LWFkZHJlc3MtY29uZmlybWF0aW9uLW5vLWZlYXR1cmVcIiwgTWFwYm94QWRkcmVzc0NvbmZpcm1hdGlvbk5vRmVhdHVyZSk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL01hcGJveEFkZHJlc3NBdXRvZmlsbC50c1xuaW1wb3J0IHtcbiAgTWFwYm94QXV0b2ZpbGwsXG4gIFNlYXJjaFNlc3Npb25cbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcblxuLy8gc3JjL3V0aWxzL2RldGVjdF9icm93c2VyX2F1dG9maWxsLnRzXG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gXCJAbWFwYm94L3NlYXJjaC1qcy1jb3JlXCI7XG5cbi8vIHNyYy91dGlscy9kZXRlY3RfYnJvd3Nlcl9hdXRvZmlsbC5jc3NcbnZhciBkZXRlY3RfYnJvd3Nlcl9hdXRvZmlsbF9kZWZhdWx0ID0gJ2lucHV0Oi13ZWJraXQtYXV0b2ZpbGwsc2VsZWN0Oi13ZWJraXQtYXV0b2ZpbGwsdGV4dGFyZWE6LXdlYmtpdC1hdXRvZmlsbHthbmltYXRpb24tbmFtZTpvbmJyb3dzZXJhdXRvZmlsbHN0YXJ0fWlucHV0Om5vdCg6LXdlYmtpdC1hdXRvZmlsbCksc2VsZWN0Om5vdCg6LXdlYmtpdC1hdXRvZmlsbCksdGV4dGFyZWE6bm90KDotd2Via2l0LWF1dG9maWxsKXthbmltYXRpb24tbmFtZTpvbmJyb3dzZXJhdXRvZmlsbGNhbmNlbH1Aa2V5ZnJhbWVzIG9uYnJvd3NlcmF1dG9maWxsc3RhcnR7MCV7YW5pbWF0aW9uLW5hbWU6XCJvbmJyb3dzZXJhdXRvZmlsbHN0YXJ0XCJ9dG97YW5pbWF0aW9uLW5hbWU6XCJvbmJyb3dzZXJhdXRvZmlsbHN0YXJ0XCJ9fUBrZXlmcmFtZXMgb25icm93c2VyYXV0b2ZpbGxjYW5jZWx7MCV7YW5pbWF0aW9uLW5hbWU6XCJvbmJyb3dzZXJhdXRvZmlsbGNhbmNlbFwifXRve2FuaW1hdGlvbi1uYW1lOlwib25icm93c2VyYXV0b2ZpbGxjYW5jZWxcIn19JztcblxuLy8gc3JjL3V0aWxzL2RldGVjdF9icm93c2VyX2F1dG9maWxsLnRzXG52YXIgQVRUUl9OQU1FID0gXCJicm93c2VyLWF1dG9maWxsZWRcIjtcbnZhciBBVVRPRklMTEVEX0VMRU1FTlRTID0gW107XG5mdW5jdGlvbiBkaXNwYXRjaEJyb3dzZXJBdXRvZmlsbEV2ZW50KCkge1xuICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwiYnJvd3NlcmF1dG9maWxsXCIsIHtcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgZGV0YWlsOiB7IGVsZW1lbnRzOiBBVVRPRklMTEVEX0VMRU1FTlRTIH1cbiAgfSkpO1xuICBBVVRPRklMTEVEX0VMRU1FTlRTID0gW107XG59XG52YXIgZGVib3VuY2VkQXV0b2ZpbGwgPSBkZWJvdW5jZShkaXNwYXRjaEJyb3dzZXJBdXRvZmlsbEV2ZW50LCA1KTtcbmZ1bmN0aW9uIGJyb3dzZXJBdXRvZmlsbChlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZShBVFRSX05BTUUpKVxuICAgIHJldHVybjtcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQVRUUl9OQU1FLCBcIlwiKTtcbiAgQVVUT0ZJTExFRF9FTEVNRU5UUy5wdXNoKGVsZW1lbnQpO1xuICBkZWJvdW5jZWRBdXRvZmlsbCgpO1xufVxuZnVuY3Rpb24gY2FuY2VsQnJvd3NlckF1dG9maWxsKGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZShBVFRSX05BTUUpKVxuICAgIHJldHVybjtcbiAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoQVRUUl9OQU1FKTtcbn1cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uU3RhcnQoZXZlbnQpIHtcbiAgZXZlbnQuYW5pbWF0aW9uTmFtZSA9PT0gXCJvbmJyb3dzZXJhdXRvZmlsbHN0YXJ0XCIgPyBicm93c2VyQXV0b2ZpbGwoZXZlbnQudGFyZ2V0KSA6IGNhbmNlbEJyb3dzZXJBdXRvZmlsbChldmVudC50YXJnZXQpO1xufVxuZnVuY3Rpb24gb25JbnB1dChldmVudCkge1xuICBjb25zdCB0YXJnZXRFbCA9IGV2ZW50LnRhcmdldDtcbiAgdGFyZ2V0RWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJzZWxlY3RcIiAmJiAhZXZlbnQuc2ltdWxhdGVkICYmIChldmVudC5pbnB1dFR5cGUgPT09IFwiaW5zZXJ0UmVwbGFjZW1lbnRUZXh0XCIgfHwgIShcImRhdGFcIiBpbiBldmVudCkpID8gYnJvd3NlckF1dG9maWxsKHRhcmdldEVsKSA6IGNhbmNlbEJyb3dzZXJBdXRvZmlsbCh0YXJnZXRFbCk7XG59XG5mdW5jdGlvbiBpbml0RGV0ZWN0QnJvd3NlckF1dG9maWxsKCkge1xuICBpZiAoY29uZmlnLmRldGVjdEJyb3dzZXJBdXRvZmlsbEVuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLmRldGVjdEJyb3dzZXJBdXRvZmlsbEVuYWJsZWQgPSB0cnVlO1xuICB9XG4gIGFkZERvY3VtZW50U3R5bGUoZGV0ZWN0X2Jyb3dzZXJfYXV0b2ZpbGxfZGVmYXVsdCk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25zdGFydFwiLCBvbkFuaW1hdGlvblN0YXJ0LCB0cnVlKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIG9uSW5wdXQsIHRydWUpO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9NYXBib3hBZGRyZXNzQXV0b2ZpbGwudHNcbnZhciBfYXV0b2ZpbGwsIF9zZXNzaW9uLCBfaW5wdXQsIF9saXN0Ym94LCBfaGFuZGxlU3VnZ2VzdDIsIF9oYW5kbGVTdWdnZXN0RXJyb3IyLCBfaGFuZGxlUmV0cmlldmUsIF9oYW5kbGVPYnNlcnZlLCBfb2JzZXJ2ZXIsIF9oYW5kbGVCcm93c2VyQXV0b2ZpbGw7XG52YXIgTWFwYm94QWRkcmVzc0F1dG9maWxsID0gY2xhc3MgZXh0ZW5kcyBIVE1MU2NvcGVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9hdXRvZmlsbCwgbmV3IE1hcGJveEF1dG9maWxsKCkpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2Vzc2lvbiwgbmV3IFNlYXJjaFNlc3Npb24oX19wcml2YXRlR2V0KHRoaXMsIF9hdXRvZmlsbCkpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2lucHV0LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbGlzdGJveCwgbmV3IE1hcGJveFNlYXJjaExpc3Rib3goKSk7XG4gICAgdGhpcy5jb25maXJtT25Ccm93c2VyQXV0b2ZpbGwgPSBmYWxzZTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZVN1Z2dlc3QyLCAoZSkgPT4ge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBib3hIVE1MRXZlbnQoZS50eXBlLCBlLmRldGFpbCkpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlU3VnZ2VzdEVycm9yMiwgKGUpID0+IHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KGUudHlwZSwgZS5kZXRhaWwpKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZVJldHJpZXZlLCAoZSkgPT4ge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBib3hIVE1MRXZlbnQoZS50eXBlLCBlLmRldGFpbCkpO1xuICAgICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmZWF0dXJlQ29sbGVjdGlvbiA9IGUuZGV0YWlsO1xuICAgICAgaWYgKCFmZWF0dXJlQ29sbGVjdGlvbiB8fCAhZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMgfHwgIWZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmaWxsRm9ybVdpdGhGZWF0dXJlKGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzWzBdLCBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0KSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVPYnNlcnZlLCAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IChfYSA9IHRoaXMucXVlcnlTZWxlY3RvcihcImlucHV0XCIpKSAhPSBudWxsID8gX2EgOiBudWxsO1xuICAgICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2lucHV0LCBpbnB1dCk7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkuaW5wdXQgPSBpbnB1dDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9pbnB1dCwgbnVsbCk7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkuaW5wdXQgPSBudWxsO1xuICAgICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSB8fCBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29ic2VydmVyLCBuZXcgTXV0YXRpb25PYnNlcnZlcihfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZU9ic2VydmUpKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVCcm93c2VyQXV0b2ZpbGwsIChlKSA9PiB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmJsdXIoKTtcbiAgICAgIHRyeUNvbmZpcm1Ccm93c2VyQXV0b2ZpbGwoX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dCksIGUsIHRoaXMuY29uZmlybU9uQnJvd3NlckF1dG9maWxsLCB0aGlzLmFjY2Vzc1Rva2VuKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgYWNjZXNzVG9rZW4oKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfYXV0b2ZpbGwpLmFjY2Vzc1Rva2VuO1xuICB9XG4gIHNldCBhY2Nlc3NUb2tlbihuZXdUb2tlbikge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYXV0b2ZpbGwpLmFjY2Vzc1Rva2VuID0gbmV3VG9rZW47XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkub3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyhuZXdPcHRpb25zKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgfVxuICBnZXQgdGhlbWUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkudGhlbWU7XG4gIH1cbiAgc2V0IHRoZW1lKHRoZW1lKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS50aGVtZSA9IHRoZW1lO1xuICB9XG4gIGdldCBwb3BvdmVyT3B0aW9ucygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5wb3BvdmVyT3B0aW9ucztcbiAgfVxuICBzZXQgcG9wb3Zlck9wdGlvbnMobmV3T3B0aW9ucykge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkucG9wb3Zlck9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgY29uZmlnLmF1dG9maWxsU2Vzc2lvbkVuYWJsZWQgPSB0cnVlO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkuc2Vzc2lvbiA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfc2Vzc2lvbik7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5zZXNzaW9uLnNlc3Npb25Ub2tlbiA9IGNvbmZpZy5hdXRvZmlsbFNlc3Npb25Ub2tlbjtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU3VnZ2VzdDIpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTdWdnZXN0RXJyb3IyKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5hZGRFdmVudExpc3RlbmVyKFwicmV0cmlldmVcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVSZXRyaWV2ZSkpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9vYnNlcnZlcikub2JzZXJ2ZSh0aGlzLCB7XG4gICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgfSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVPYnNlcnZlKS5jYWxsKHRoaXMpO1xuICAgIGluaXREZXRlY3RCcm93c2VyQXV0b2ZpbGwoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJyb3dzZXJhdXRvZmlsbFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUJyb3dzZXJBdXRvZmlsbCkpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkucmVtb3ZlKCk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN1Z2dlc3QyKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdGVycm9yXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU3VnZ2VzdEVycm9yMikpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJldHJpZXZlXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlUmV0cmlldmUpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX29ic2VydmVyKS5kaXNjb25uZWN0KCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJicm93c2VyYXV0b2ZpbGxcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVCcm93c2VyQXV0b2ZpbGwpKTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IFwiYWNjZXNzLXRva2VuXCIpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYXV0b2ZpbGwpLmFjY2Vzc1Rva2VuID0gbmV3VmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcInRoZW1lXCIpIHtcbiAgICAgIHRoaXMudGhlbWUgPSB0cnlQYXJzZUpTT04obmV3VmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJwb3BvdmVyLW9wdGlvbnNcIikge1xuICAgICAgdGhpcy5wb3BvdmVyT3B0aW9ucyA9IHRyeVBhcnNlSlNPTihuZXdWYWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbk5hbWUgPSBuYW1lLnNwbGl0KFwiLVwiKS5qb2luKFwiX1wiKTtcbiAgICBpZiAoIW5ld1ZhbHVlKSB7XG4gICAgICBkZWxldGUgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94KS5vcHRpb25zW29wdGlvbk5hbWVdO1xuICAgIH1cbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLm9wdGlvbnNbb3B0aW9uTmFtZV0gPSBuZXdWYWx1ZTtcbiAgfVxuICBmb2N1cygpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gpLmZvY3VzKCk7XG4gIH1cbn07XG5fYXV0b2ZpbGwgPSBuZXcgV2Vha01hcCgpO1xuX3Nlc3Npb24gPSBuZXcgV2Vha01hcCgpO1xuX2lucHV0ID0gbmV3IFdlYWtNYXAoKTtcbl9saXN0Ym94ID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVTdWdnZXN0MiA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlU3VnZ2VzdEVycm9yMiA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlUmV0cmlldmUgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZU9ic2VydmUgPSBuZXcgV2Vha01hcCgpO1xuX29ic2VydmVyID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVCcm93c2VyQXV0b2ZpbGwgPSBuZXcgV2Vha01hcCgpO1xuTWFwYm94QWRkcmVzc0F1dG9maWxsLm9ic2VydmVkQXR0cmlidXRlcyA9IFtcbiAgXCJhY2Nlc3MtdG9rZW5cIixcbiAgXCJ0aGVtZVwiLFxuICBcInBvcG92ZXItb3B0aW9uc1wiLFxuICBcImNzcy10ZXh0XCIsXG4gIFwibGFuZ3VhZ2VcIixcbiAgXCJjb3VudHJ5XCIsXG4gIFwiYmJveFwiLFxuICBcImxpbWl0XCIsXG4gIFwicHJveGltaXR5XCJcbl07XG53aW5kb3cuTWFwYm94QWRkcmVzc0F1dG9maWxsID0gTWFwYm94QWRkcmVzc0F1dG9maWxsO1xuaWYgKCF3aW5kb3cuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWFwYm94LWFkZHJlc3MtYXV0b2ZpbGxcIikpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwibWFwYm94LWFkZHJlc3MtYXV0b2ZpbGxcIiwgTWFwYm94QWRkcmVzc0F1dG9maWxsKTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvTWFwYm94U2VhcmNoQm94LnRzXG5pbXBvcnQge1xuICBmZWF0dXJlVG9TdWdnZXN0aW9uIGFzIGZlYXR1cmVUb1N1Z2dlc3Rpb24zLFxuICBMbmdMYXRCb3VuZHMsXG4gIE1hcGJveFNlYXJjaCxcbiAgU2VhcmNoU2Vzc2lvbiBhcyBTZWFyY2hTZXNzaW9uMlxufSBmcm9tIFwiQG1hcGJveC9zZWFyY2gtanMtY29yZVwiO1xudmFyIE1BWF9aT09NID0gOTtcbnZhciBURU1QTEFURTUgPSBjcmVhdGVFbGVtZW50RnJvbVN0cmluZyhgXG48dGVtcGxhdGU+XG4gIDxpbnB1dCBjbGFzcz1cIklucHV0XCIgdHlwZT1cInRleHRcIiAvPlxuPC90ZW1wbGF0ZT5cbmApO1xudmFyIF9zZWFyY2gsIF9zZXNzaW9uMiwgX21hcCwgX2lucHV0MiwgX2xpc3Rib3gyLCBfaGFuZGxlU3VnZ2VzdDMsIF9oYW5kbGVTdWdnZXN0RXJyb3IzLCBfaGFuZGxlUmV0cmlldmUyLCBfaGFuZGxlSW5wdXQyLCBfaGFuZGxlTW92ZUVuZDtcbnZhciBNYXBib3hTZWFyY2hCb3ggPSBjbGFzcyBleHRlbmRzIEhUTUxTY29wZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3NlYXJjaCwgbmV3IE1hcGJveFNlYXJjaCh7fSkpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2Vzc2lvbjIsIG5ldyBTZWFyY2hTZXNzaW9uMihfX3ByaXZhdGVHZXQodGhpcywgX3NlYXJjaCkpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21hcCwgbnVsbCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9pbnB1dDIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9saXN0Ym94MiwgbmV3IE1hcGJveFNlYXJjaExpc3Rib3goKSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVTdWdnZXN0MywgKGUpID0+IHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwYm94SFRNTEV2ZW50KGUudHlwZSwgZS5kZXRhaWwpKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZVN1Z2dlc3RFcnJvcjMsIChlKSA9PiB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcGJveEhUTUxFdmVudChlLnR5cGUsIGUuZGV0YWlsKSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVSZXRyaWV2ZTIsIChlKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcGJveEhUTUxFdmVudChlLnR5cGUsIGUuZGV0YWlsKSk7XG4gICAgICBjb25zdCBmZWF0dXJlQ29sbGVjdGlvbiA9IGUuZGV0YWlsO1xuICAgICAgaWYgKCFmZWF0dXJlQ29sbGVjdGlvbiB8fCAhZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBmZWF0dXJlVG9TdWdnZXN0aW9uMyhmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlc1swXSk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0MikudmFsdWUgPSBzdWdnZXN0aW9uLmZlYXR1cmVfbmFtZTtcbiAgICAgIGNvbnN0IG1hcCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwKTtcbiAgICAgIGlmICghbWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlc1swXTtcbiAgICAgIGlmICghZmVhdHVyZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZVR5cGUgPSAoX2EgPSBmZWF0dXJlLnByb3BlcnRpZXMucGxhY2VfdHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hWzBdO1xuICAgICAgY29uc3QgYm91bmRzID0gZmVhdHVyZS5iYm94O1xuICAgICAgaWYgKGJvdW5kcykge1xuICAgICAgICBtYXAuZmx5VG8oYmJveFZpZXdwb3J0KG1hcCwgTG5nTGF0Qm91bmRzLmNvbnZlcnQoYm91bmRzKS50b0ZsYXRBcnJheSgpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICBjb25zdCB6b29tID0gZ2V0TWF4Wm9vbShwbGFjZVR5cGUpO1xuICAgICAgICBtYXAuZmx5VG8oe1xuICAgICAgICAgIGNlbnRlcixcbiAgICAgICAgICB6b29tLFxuICAgICAgICAgIHNwZWVkOiBGTFlfVE9fU1BFRURcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlSW5wdXQyLCAoZSkgPT4ge1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWFwYm94SFRNTEV2ZW50KFwiaW5wdXRcIik7XG4gICAgICBPYmplY3QuYXNzaWduKGV2ZW50LCBfX3NwcmVhZFZhbHVlcyh7fSwgZSkpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZU1vdmVFbmQsICgpID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94Mikub3B0aW9ucyk7XG4gICAgICBpZiAobWFwLmdldFpvb20oKSA8PSBNQVhfWk9PTSkge1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5wcm94aW1pdHk7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS5vcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgcHJveGltaXR5OiBjZW50ZXJcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGdldCBhY2Nlc3NUb2tlbigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zZWFyY2gpLmFjY2Vzc1Rva2VuO1xuICB9XG4gIHNldCBhY2Nlc3NUb2tlbihuZXdUb2tlbikge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2VhcmNoKS5hY2Nlc3NUb2tlbiA9IG5ld1Rva2VuO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dDIpLnZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQyKS52YWx1ZSA9IG5ld1ZhbHVlO1xuICB9XG4gIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gVEVNUExBVEU1O1xuICB9XG4gIGdldCB0ZW1wbGF0ZVN0eWxlKCkge1xuICAgIHJldHVybiBzdHlsZV9kZWZhdWx0O1xuICB9XG4gIGdldCB0ZW1wbGF0ZVVzZXJTdHlsZSgpIHtcbiAgICByZXR1cm4gZ2V0VGhlbWVDU1MoXCIuSW5wdXRcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikudGhlbWUpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS5vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgfVxuICBnZXQgdGhlbWUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLnRoZW1lO1xuICB9XG4gIHNldCB0aGVtZSh0aGVtZSkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLnRoZW1lID0gdGhlbWU7XG4gICAgY29uc3QgaW5wdXQgPSBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0Mik7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlVXNlclN0eWxlKGdldFRoZW1lQ1NTKFwiLklucHV0XCIsIHRoZW1lKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikudXBkYXRlUG9wb3ZlcigpO1xuICB9XG4gIGdldCBwb3BvdmVyT3B0aW9ucygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikucG9wb3Zlck9wdGlvbnM7XG4gIH1cbiAgc2V0IHBvcG92ZXJPcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS5wb3BvdmVyT3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gIH1cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMucXVlcnlTZWxlY3RvcihcIi5JbnB1dFwiKTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVJbnB1dDIpKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2lucHV0MiwgaW5wdXQpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLnNlc3Npb24gPSBfX3ByaXZhdGVHZXQodGhpcywgX3Nlc3Npb24yKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS5pbnB1dCA9IGlucHV0O1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0XCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU3VnZ2VzdDMpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS5hZGRFdmVudExpc3RlbmVyKFwic3VnZ2VzdGVycm9yXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU3VnZ2VzdEVycm9yMykpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXRyaWV2ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVJldHJpZXZlMikpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikpO1xuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLnJlbW92ZSgpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLmlucHV0ID0gbnVsbDtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN1Z2dlc3QzKSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9saXN0Ym94MikucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN1Z2dlc3RlcnJvclwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN1Z2dlc3RFcnJvcjMpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS5yZW1vdmVFdmVudExpc3RlbmVyKFwicmV0cmlldmVcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVSZXRyaWV2ZTIpKTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IFwiYWNjZXNzLXRva2VuXCIpIHtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2VhcmNoKS5hY2Nlc3NUb2tlbiA9IG5ld1ZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJ0aGVtZVwiKSB7XG4gICAgICB0aGlzLnRoZW1lID0gdHJ5UGFyc2VKU09OKG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwicG9wb3Zlci1vcHRpb25zXCIpIHtcbiAgICAgIHRoaXMucG9wb3Zlck9wdGlvbnMgPSB0cnlQYXJzZUpTT04obmV3VmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25OYW1lID0gbmFtZS5zcGxpdChcIi1cIikuam9pbihcIl9cIik7XG4gICAgaWYgKCFuZXdWYWx1ZSkge1xuICAgICAgZGVsZXRlIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLm9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgfVxuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbGlzdGJveDIpLm9wdGlvbnNbb3B0aW9uTmFtZV0gPSBuZXdWYWx1ZTtcbiAgfVxuICBmb2N1cygpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2xpc3Rib3gyKS5mb2N1cygpO1xuICB9XG4gIGJpbmRNYXAobWFwKSB7XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwKSkge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9tYXApLm9mZihcIm1vdmVlbmRcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVNb3ZlRW5kKSk7XG4gICAgfVxuICAgIGlmIChtYXApIHtcbiAgICAgIG1hcC5vbihcIm1vdmVlbmRcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVNb3ZlRW5kKSk7XG4gICAgfVxuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWFwLCBtYXApO1xuICB9XG4gIHVuYmluZE1hcCgpIHtcbiAgICB0aGlzLmJpbmRNYXAobnVsbCk7XG4gIH1cbiAgb25BZGQobWFwKSB7XG4gICAgdGhpcy5iaW5kTWFwKG1hcCk7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcIm1hcGJveGdsLWN0cmxcIjtcbiAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBcIjMwMHB4XCI7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgb25SZW1vdmUoKSB7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICB0aGlzLnVuYmluZE1hcCgpO1xuICB9XG4gIGdldERlZmF1bHRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gXCJ0b3AtcmlnaHRcIjtcbiAgfVxufTtcbl9zZWFyY2ggPSBuZXcgV2Vha01hcCgpO1xuX3Nlc3Npb24yID0gbmV3IFdlYWtNYXAoKTtcbl9tYXAgPSBuZXcgV2Vha01hcCgpO1xuX2lucHV0MiA9IG5ldyBXZWFrTWFwKCk7XG5fbGlzdGJveDIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVN1Z2dlc3QzID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVTdWdnZXN0RXJyb3IzID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVSZXRyaWV2ZTIgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZUlucHV0MiA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlTW92ZUVuZCA9IG5ldyBXZWFrTWFwKCk7XG5NYXBib3hTZWFyY2hCb3gub2JzZXJ2ZWRBdHRyaWJ1dGVzID0gW1xuICBcImFjY2Vzcy10b2tlblwiLFxuICBcInRoZW1lXCIsXG4gIFwicG9wb3Zlci1vcHRpb25zXCIsXG4gIFwibGFuZ3VhZ2VcIixcbiAgXCJjb3VudHJ5XCIsXG4gIFwiYmJveFwiLFxuICBcImxpbWl0XCIsXG4gIFwibmF2aWdhdGlvbi1wcm9maWxlXCIsXG4gIFwib3JpZ2luXCIsXG4gIFwicHJveGltaXR5XCIsXG4gIFwiZXRhLXR5cGVcIixcbiAgXCJ0eXBlc1wiXG5dO1xud2luZG93Lk1hcGJveFNlYXJjaEJveCA9IE1hcGJveFNlYXJjaEJveDtcbmlmICghd2luZG93LmN1c3RvbUVsZW1lbnRzLmdldChcIm1hcGJveC1zZWFyY2gtYm94XCIpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcIm1hcGJveC1zZWFyY2gtYm94XCIsIE1hcGJveFNlYXJjaEJveCk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL01hcGJveEFkZHJlc3NNaW5pbWFwLnRzXG5pbXBvcnQgeyBMbmdMYXQgfSBmcm9tIFwiQG1hcGJveC9zZWFyY2gtanMtY29yZVwiO1xuXG4vLyBzcmMvdXRpbHMvbWluaW1hcC50c1xuaW1wb3J0IFNwaGVyaWNhbE1lcmNhdG9yIGZyb20gXCJAbWFwYm94L3NwaGVyaWNhbG1lcmNhdG9yXCI7XG52YXIgbWVyYyA9IG5ldyBTcGhlcmljYWxNZXJjYXRvcih7IHNpemU6IDUxMiwgYW50aW1lcmlkaWFuOiB0cnVlIH0pO1xudmFyIE1BWF9JTUFHRV9ESU0gPSAxMjgwO1xuZnVuY3Rpb24gZ2V0QW5jaG9yT2Zmc2V0KG1hcmtlciwgYW5jaG9yKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0RWxlbWVudFNpemUobWFya2VyLCB0cnVlKTtcbiAgc3dpdGNoIChhbmNob3IpIHtcbiAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICByZXR1cm4gWzAsIDBdO1xuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgIHJldHVybiBbMCwgaGVpZ2h0IC8gMl07XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgcmV0dXJuIFswLCAtMSAqIGhlaWdodCAvIDJdO1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICByZXR1cm4gW3dpZHRoIC8gMiwgMF07XG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICByZXR1cm4gWy0xICogd2lkdGggLyAyLCAwXTtcbiAgICBjYXNlIFwidG9wLWxlZnRcIjpcbiAgICAgIHJldHVybiBbd2lkdGggLyAyLCBoZWlnaHQgLyAyXTtcbiAgICBjYXNlIFwidG9wLXJpZ2h0XCI6XG4gICAgICByZXR1cm4gWy0xICogd2lkdGggLyAyLCBoZWlnaHQgLyAyXTtcbiAgICBjYXNlIFwiYm90dG9tLWxlZnRcIjpcbiAgICAgIHJldHVybiBbd2lkdGggLyAyLCAtMSAqIGhlaWdodCAvIDJdO1xuICAgIGNhc2UgXCJib3R0b20tcmlnaHRcIjpcbiAgICAgIHJldHVybiBbLTEgKiB3aWR0aCAvIDIsIC0xICogaGVpZ2h0IC8gMl07XG4gIH1cbn1cbnZhciBfYW5jaG9yLCBfaGFuZGxlQW5jaG9yUmVzaXplLCBfbWFya2VyVHJhbnNmb3JtLCBfaXNBY3RpdmUsIF9vcmlnaW5hbENvb3JkaW5hdGUsIF9vblBvaW50ZXJEb3duTWFya2VyLCBfb25Qb2ludGVyVXBNYXJrZXIsIF9vblBvaW50ZXJNb3ZlTWFya2VyLCBfb25Qb2ludGVyRG93bkltYWdlLCBfb25Qb2ludGVyVXBJbWFnZSwgX29uUG9pbnRlck1vdmVJbWFnZSwgX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbiwgX3VwZGF0ZU1hcmtlclRyYW5zZm9ybSwgX3VwZGF0ZU1hcmtlckNvcnJlY3Rpb247XG52YXIgTWFya2VyQ29udHJvbGxlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaW1hZ2VDb250YWluZXIsIGltYWdlRWxlbWVudCwgbWFya2VyLCBrZWVwTWFya2VyQ2VudGVyZWQsIHpvb20sIGFuY2hvcikge1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYW5jaG9yLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlQW5jaG9yUmVzaXplLCAoKSA9PiB7XG4gICAgICBbdGhpcy5hbmNob3JPZmZzZXRYLCB0aGlzLmFuY2hvck9mZnNldFldID0gZ2V0QW5jaG9yT2Zmc2V0KHRoaXMubWFya2VyRWxlbWVudCwgdGhpcy5hbmNob3IpO1xuICAgICAgdGhpcy5tYXJrZXJUcmFuc2Zvcm0gPSB7XG4gICAgICAgIGFuY2hvclg6IHRoaXMuYW5jaG9yT2Zmc2V0WCxcbiAgICAgICAgYW5jaG9yWTogdGhpcy5hbmNob3JPZmZzZXRZXG4gICAgICB9O1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbWFya2VyVHJhbnNmb3JtLCB7XG4gICAgICBhbmNob3JYOiAwLFxuICAgICAgYW5jaG9yWTogMCxcbiAgICAgIGdsb2JhbFg6IDAsXG4gICAgICBnbG9iYWxZOiAwLFxuICAgICAgY29ycmVjdGlvblg6IDAsXG4gICAgICBjb3JyZWN0aW9uWTogMFxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaXNBY3RpdmUsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29yaWdpbmFsQ29vcmRpbmF0ZSwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uUG9pbnRlckRvd25NYXJrZXIsIChtKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaXNBY3RpdmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIG0ucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG0uc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbikuY2FsbCh0aGlzLCBtKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vblBvaW50ZXJNb3ZlTWFya2VyKSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uUG9pbnRlclVwTWFya2VyKSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9vblBvaW50ZXJVcE1hcmtlciwgKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uUG9pbnRlck1vdmVNYXJrZXIpKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25Qb2ludGVyVXBNYXJrZXIpKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uUG9pbnRlck1vdmVNYXJrZXIsIChtKSA9PiB7XG4gICAgICBtLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBtLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgY29uc3QgZGlmZlggPSB0aGlzLmN1clBvaW50ZXJYUG9zIC0gbS5wYWdlWDtcbiAgICAgIGNvbnN0IGRpZmZZID0gdGhpcy5jdXJQb2ludGVyWVBvcyAtIG0ucGFnZVk7XG4gICAgICB0aGlzLm1hcmtlckRlbHRhWCArPSBkaWZmWDtcbiAgICAgIHRoaXMubWFya2VyRGVsdGFZIC09IGRpZmZZO1xuICAgICAgdGhpcy5tYXJrZXJEZWx0YVggPSBNYXRoLm1heChNYXRoLm1pbih0aGlzLmltZ0VsZW1lbnQud2lkdGggLyAyLCB0aGlzLm1hcmtlckRlbHRhWCksIHRoaXMuaW1nRWxlbWVudC53aWR0aCAvIDIgKiAtMSk7XG4gICAgICB0aGlzLm1hcmtlckRlbHRhWSA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuaW1nRWxlbWVudC5oZWlnaHQgLyAyLCB0aGlzLm1hcmtlckRlbHRhWSksIHRoaXMuaW1nRWxlbWVudC5oZWlnaHQgLyAyICogLTEpO1xuICAgICAgY29uc3QgaW1hZ2VPZmZzZXRYID0gdGhpcy5pbWdDZW50ZXJQeFswXSAtIHRoaXMuaW1nQ2VudGVyQWRqdXN0ZWRQeFswXTtcbiAgICAgIGNvbnN0IGltYWdlT2Zmc2V0WSA9IHRoaXMuaW1nQ2VudGVyUHhbMV0gLSB0aGlzLmltZ0NlbnRlckFkanVzdGVkUHhbMV07XG4gICAgICBjb25zdCBkZWx0YVggPSB0aGlzLm1hcmtlckRlbHRhWCAtIGltYWdlT2Zmc2V0WDtcbiAgICAgIGNvbnN0IGRlbHRhWSA9IHRoaXMubWFya2VyRGVsdGFZICsgaW1hZ2VPZmZzZXRZO1xuICAgICAgdGhpcy5tYXJrZXJUcmFuc2Zvcm0gPSB7IGdsb2JhbFg6IGRlbHRhWCwgZ2xvYmFsWTogZGVsdGFZIH07XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbikuY2FsbCh0aGlzLCBtKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uUG9pbnRlckRvd25JbWFnZSwgKG0pID0+IHtcbiAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfdXBkYXRlUG9pbnRlclBvc2l0aW9uKS5jYWxsKHRoaXMsIG0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uUG9pbnRlck1vdmVJbWFnZSkpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vblBvaW50ZXJVcEltYWdlKSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9vblBvaW50ZXJVcEltYWdlLCAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25Qb2ludGVyTW92ZUltYWdlKSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX29uUG9pbnRlclVwSW1hZ2UpKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29uUG9pbnRlck1vdmVJbWFnZSwgKG0pID0+IHtcbiAgICAgIG0ucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGxldCB0b3AgPSBNYXRoLnJvdW5kKHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5zY3JvbGxUb3AgKyAodGhpcy5jdXJQb2ludGVyWVBvcyAtIG0ucGFnZVkpKTtcbiAgICAgIHRvcCA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuaW1nRWxlbWVudC5oZWlnaHQgLSB0aGlzLmltZ0NvbnRhaW5lckVsZW1lbnQuY2xpZW50SGVpZ2h0LCB0b3ApLCAwKTtcbiAgICAgIGxldCBsZWZ0ID0gTWF0aC5yb3VuZCh0aGlzLmltZ0NvbnRhaW5lckVsZW1lbnQuc2Nyb2xsTGVmdCArICh0aGlzLmN1clBvaW50ZXJYUG9zIC0gbS5wYWdlWCkpO1xuICAgICAgbGVmdCA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuaW1nRWxlbWVudC53aWR0aCAtIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5jbGllbnRXaWR0aCwgbGVmdCksIDApO1xuICAgICAgdGhpcy5pbWdDb250YWluZXJFbGVtZW50LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgIGNvbnN0IGRpZmZYID0gTWF0aC5yb3VuZChsZWZ0IC0gKHRoaXMuaW1nRWxlbWVudC53aWR0aCAtIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5jbGllbnRXaWR0aCkgLyAyKTtcbiAgICAgIGNvbnN0IGRpZmZZID0gTWF0aC5yb3VuZCgodGhpcy5pbWdFbGVtZW50LmhlaWdodCAtIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5jbGllbnRIZWlnaHQpIC8gMiAtIHRvcCk7XG4gICAgICB0aGlzLmltZ0NlbnRlckFkanVzdGVkUHggPSBbXG4gICAgICAgIHRoaXMuaW1nQ2VudGVyUHhbMF0gKyBkaWZmWCxcbiAgICAgICAgdGhpcy5pbWdDZW50ZXJQeFsxXSAtIGRpZmZZXG4gICAgICBdO1xuICAgICAgaWYgKCF0aGlzLmtlZXBNYXJrZXJDZW50ZXJlZCkge1xuICAgICAgICBjb25zdCBkZWx0YVggPSB0aGlzLm1hcmtlckRlbHRhWCArIGRpZmZYO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSB0aGlzLm1hcmtlckRlbHRhWSArIGRpZmZZO1xuICAgICAgICB0aGlzLm1hcmtlclRyYW5zZm9ybSA9IHsgZ2xvYmFsWDogZGVsdGFYLCBnbG9iYWxZOiBkZWx0YVkgfTtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfdXBkYXRlTWFya2VyQ29ycmVjdGlvbikuY2FsbCh0aGlzLCBsZWZ0LCB0b3ApO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF91cGRhdGVQb2ludGVyUG9zaXRpb24pLmNhbGwodGhpcywgbSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF91cGRhdGVQb2ludGVyUG9zaXRpb24sIChtKSA9PiB7XG4gICAgICB0aGlzLmN1clBvaW50ZXJYUG9zID0gbS5wYWdlWDtcbiAgICAgIHRoaXMuY3VyUG9pbnRlcllQb3MgPSBtLnBhZ2VZO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdXBkYXRlTWFya2VyVHJhbnNmb3JtLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IGFuY2hvclgsIGFuY2hvclksIGdsb2JhbFgsIGdsb2JhbFksIGNvcnJlY3Rpb25YLCBjb3JyZWN0aW9uWSB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgdHJhbnNmb3JtWCA9IGFuY2hvclggLSBnbG9iYWxYICsgY29ycmVjdGlvblg7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1ZID0gYW5jaG9yWSArIGdsb2JhbFkgKyBjb3JyZWN0aW9uWTtcbiAgICAgIHRoaXMubWFya2VyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKGNhbGMoLTUwJSArICR7dHJhbnNmb3JtWH1weCksIGNhbGMoLTUwJSArICR7dHJhbnNmb3JtWX1weCkpYDtcbiAgICB9KTtcbiAgICB0aGlzLnJlQ2VudGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgdG9wID0gKHRoaXMuaW1nRWxlbWVudC5oZWlnaHQgLSB0aGlzLmltZ0NvbnRhaW5lckVsZW1lbnQuY2xpZW50SGVpZ2h0KSAvIDI7XG4gICAgICBjb25zdCBsZWZ0ID0gKHRoaXMuaW1nRWxlbWVudC53aWR0aCAtIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5jbGllbnRXaWR0aCkgLyAyO1xuICAgICAgdGhpcy5pbWdDb250YWluZXJFbGVtZW50LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgIHRoaXMuaW1nQ2VudGVyQWRqdXN0ZWRQeCA9IHRoaXMuaW1nQ2VudGVyUHg7XG4gICAgICB0aGlzLm1hcmtlckRlbHRhWCA9IHRoaXMubWFya2VyRGVsdGFZID0gMDtcbiAgICAgIHRoaXMubWFya2VyVHJhbnNmb3JtID0ge1xuICAgICAgICBnbG9iYWxYOiAwLFxuICAgICAgICBnbG9iYWxZOiAwLFxuICAgICAgICBjb3JyZWN0aW9uWDogMCxcbiAgICAgICAgY29ycmVjdGlvblk6IDBcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZU1pbmltYXBSZXNpemUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaW1nRWxlbWVudC5oZWlnaHQgfHwgIXRoaXMuaW1nRWxlbWVudC53aWR0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgY2VudGVyT2Zmc2V0WCA9IHRoaXMuaW1nQ2VudGVyT2Zmc2V0Lng7XG4gICAgICBjb25zdCBjZW50ZXJPZmZzZXRZID0gdGhpcy5pbWdDZW50ZXJPZmZzZXQueTtcbiAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmltZ0VsZW1lbnQud2lkdGggLyAyIC0gY2VudGVyT2Zmc2V0WCAtIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5jbGllbnRXaWR0aCAvIDI7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLmltZ0VsZW1lbnQuaGVpZ2h0IC8gMiAtIGNlbnRlck9mZnNldFkgLSB0aGlzLmltZ0NvbnRhaW5lckVsZW1lbnQuY2xpZW50SGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3VwZGF0ZU1hcmtlckNvcnJlY3Rpb24pLmNhbGwodGhpcywgbGVmdCwgdG9wKTtcbiAgICB9O1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdXBkYXRlTWFya2VyQ29ycmVjdGlvbiwgKHNjcm9sbExlZnQsIHNjcm9sbFRvcCkgPT4ge1xuICAgICAgY29uc3QgY2VudGVyT2Zmc2V0WCA9IHRoaXMuaW1nQ2VudGVyT2Zmc2V0Lng7XG4gICAgICBjb25zdCBjZW50ZXJPZmZzZXRZID0gdGhpcy5pbWdDZW50ZXJPZmZzZXQueTtcbiAgICAgIGNvbnN0IHsgY29ycmVjdGlvblgsIGNvcnJlY3Rpb25ZIH0gPSB0aGlzLm1hcmtlclRyYW5zZm9ybTtcbiAgICAgIGNvbnN0IGNvcnJlY3Rpb25zID0ge307XG4gICAgICBpZiAoc2Nyb2xsTGVmdCAvIDIgPCBjZW50ZXJPZmZzZXRYICogLTEpIHtcbiAgICAgICAgY29uc3QgbWFya2VyVHJhbnNsYXRlWCA9IGNlbnRlck9mZnNldFggKiAtMSAtIHNjcm9sbExlZnQgLyAyO1xuICAgICAgICBjb3JyZWN0aW9ucy5jb3JyZWN0aW9uWCA9IG1hcmtlclRyYW5zbGF0ZVggKiAyO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxMZWZ0IDwgMCkge1xuICAgICAgICBjb3JyZWN0aW9ucy5jb3JyZWN0aW9uWCA9IHNjcm9sbExlZnQ7XG4gICAgICB9IGVsc2UgaWYgKGNvcnJlY3Rpb25YICE9PSAwKSB7XG4gICAgICAgIGNvcnJlY3Rpb25zLmNvcnJlY3Rpb25YID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChzY3JvbGxUb3AgLyAyIDwgY2VudGVyT2Zmc2V0WSAqIC0xKSB7XG4gICAgICAgIGNvbnN0IG1hcmtlclRyYW5zbGF0ZVkgPSBjZW50ZXJPZmZzZXRZICogLTEgLSBzY3JvbGxUb3AgLyAyO1xuICAgICAgICBjb3JyZWN0aW9ucy5jb3JyZWN0aW9uWSA9IG1hcmtlclRyYW5zbGF0ZVkgKiAyO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxUb3AgPCAwKSB7XG4gICAgICAgIGNvcnJlY3Rpb25zLmNvcnJlY3Rpb25ZID0gc2Nyb2xsVG9wO1xuICAgICAgfSBlbHNlIGlmIChjb3JyZWN0aW9uWSAhPT0gMCkge1xuICAgICAgICBjb3JyZWN0aW9ucy5jb3JyZWN0aW9uWSA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLm1hcmtlclRyYW5zZm9ybSA9IGNvcnJlY3Rpb25zO1xuICAgIH0pO1xuICAgIHRoaXMubWFya2VyRWxlbWVudCA9IG1hcmtlcjtcbiAgICB0aGlzLmltZ0NvbnRhaW5lckVsZW1lbnQgPSBpbWFnZUNvbnRhaW5lcjtcbiAgICB0aGlzLmltZ0VsZW1lbnQgPSBpbWFnZUVsZW1lbnQ7XG4gICAgdGhpcy5rZWVwTWFya2VyQ2VudGVyZWQgPSBrZWVwTWFya2VyQ2VudGVyZWQ7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB0aGlzLmN1clBvaW50ZXJYUG9zID0gMDtcbiAgICB0aGlzLmN1clBvaW50ZXJZUG9zID0gMDtcbiAgICB0aGlzLm1hcmtlckRlbHRhWCA9IDA7XG4gICAgdGhpcy5tYXJrZXJEZWx0YVkgPSAwO1xuICAgIHRoaXMuaW1nQ29udGFpbmVyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgX19wcml2YXRlR2V0KHRoaXMsIF9vblBvaW50ZXJEb3duSW1hZ2UpKTtcbiAgICBpZiAoIXRoaXMua2VlcE1hcmtlckNlbnRlcmVkKSB7XG4gICAgICB0aGlzLm1hcmtlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfb25Qb2ludGVyRG93bk1hcmtlcikpO1xuICAgIH1cbiAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUFuY2hvclJlc2l6ZSkpO1xuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5tYXJrZXJFbGVtZW50KTtcbiAgfVxuICBnZXQgYW5jaG9yKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2FuY2hvcik7XG4gIH1cbiAgc2V0IGFuY2hvcihuZXdBbmNob3IpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2FuY2hvciwgbmV3QW5jaG9yKTtcbiAgICBbdGhpcy5hbmNob3JPZmZzZXRYLCB0aGlzLmFuY2hvck9mZnNldFldID0gZ2V0QW5jaG9yT2Zmc2V0KHRoaXMubWFya2VyRWxlbWVudCwgbmV3QW5jaG9yKTtcbiAgICB0aGlzLm1hcmtlclRyYW5zZm9ybSA9IHtcbiAgICAgIGFuY2hvclg6IHRoaXMuYW5jaG9yT2Zmc2V0WCxcbiAgICAgIGFuY2hvclk6IHRoaXMuYW5jaG9yT2Zmc2V0WVxuICAgIH07XG4gIH1cbiAgZ2V0IG1hcmtlclRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJUcmFuc2Zvcm0pO1xuICB9XG4gIHNldCBtYXJrZXJUcmFuc2Zvcm0odmFsKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9tYXJrZXJUcmFuc2Zvcm0sIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBfX3ByaXZhdGVHZXQodGhpcywgX21hcmtlclRyYW5zZm9ybSkpLCB2YWwpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3VwZGF0ZU1hcmtlclRyYW5zZm9ybSkuY2FsbCh0aGlzKTtcbiAgfVxuICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfaXNBY3RpdmUpO1xuICB9XG4gIHNldCBpc0FjdGl2ZSh2YWwpIHtcbiAgICB0aGlzLmltZ0NvbnRhaW5lckVsZW1lbnQuc3R5bGUudG91Y2hBY3Rpb24gPSB2YWwgPyBcIm5vbmVcIiA6IFwiXCI7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9pc0FjdGl2ZSwgdmFsKTtcbiAgfVxuICBnZXQgY29vcmRpbmF0ZSgpIHtcbiAgICBjb25zdCBhZGp1c3RlZFB4ID0gdGhpcy5rZWVwTWFya2VyQ2VudGVyZWQgPyB0aGlzLmltZ0NlbnRlckFkanVzdGVkUHggOiBbXG4gICAgICB0aGlzLmltZ0NlbnRlclB4WzBdIC0gdGhpcy5tYXJrZXJEZWx0YVgsXG4gICAgICB0aGlzLmltZ0NlbnRlclB4WzFdICsgdGhpcy5tYXJrZXJEZWx0YVlcbiAgICBdO1xuICAgIGlmIChkZWVwRXF1YWxzKGFkanVzdGVkUHgsIHRoaXMuaW1nQ2VudGVyUHgpKSB7XG4gICAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9vcmlnaW5hbENvb3JkaW5hdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsbmdMYXQgPSBtZXJjLmxsKGFkanVzdGVkUHgsIHRoaXMuem9vbSk7XG4gICAgICByZXR1cm4gW3JvdW5kKGxuZ0xhdFswXSwgNiksIHJvdW5kKGxuZ0xhdFsxXSwgNildO1xuICAgIH1cbiAgfVxuICBzZXQgY29vcmRpbmF0ZShsbmdMYXQpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29yaWdpbmFsQ29vcmRpbmF0ZSwgbG5nTGF0KTtcbiAgICB0aGlzLmltZ0NlbnRlclB4ID0gdGhpcy5pbWdDZW50ZXJBZGp1c3RlZFB4ID0gbWVyYy5weChsbmdMYXQsIHRoaXMuem9vbSk7XG4gIH1cbiAgZ2V0IGltZ0NlbnRlck9mZnNldCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy5pbWdDZW50ZXJQeFswXSAtIHRoaXMuaW1nQ2VudGVyQWRqdXN0ZWRQeFswXSxcbiAgICAgIHk6IHRoaXMuaW1nQ2VudGVyUHhbMV0gLSB0aGlzLmltZ0NlbnRlckFkanVzdGVkUHhbMV1cbiAgICB9O1xuICB9XG59O1xuX2FuY2hvciA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlQW5jaG9yUmVzaXplID0gbmV3IFdlYWtNYXAoKTtcbl9tYXJrZXJUcmFuc2Zvcm0gPSBuZXcgV2Vha01hcCgpO1xuX2lzQWN0aXZlID0gbmV3IFdlYWtNYXAoKTtcbl9vcmlnaW5hbENvb3JkaW5hdGUgPSBuZXcgV2Vha01hcCgpO1xuX29uUG9pbnRlckRvd25NYXJrZXIgPSBuZXcgV2Vha01hcCgpO1xuX29uUG9pbnRlclVwTWFya2VyID0gbmV3IFdlYWtNYXAoKTtcbl9vblBvaW50ZXJNb3ZlTWFya2VyID0gbmV3IFdlYWtNYXAoKTtcbl9vblBvaW50ZXJEb3duSW1hZ2UgPSBuZXcgV2Vha01hcCgpO1xuX29uUG9pbnRlclVwSW1hZ2UgPSBuZXcgV2Vha01hcCgpO1xuX29uUG9pbnRlck1vdmVJbWFnZSA9IG5ldyBXZWFrTWFwKCk7XG5fdXBkYXRlUG9pbnRlclBvc2l0aW9uID0gbmV3IFdlYWtNYXAoKTtcbl91cGRhdGVNYXJrZXJUcmFuc2Zvcm0gPSBuZXcgV2Vha01hcCgpO1xuX3VwZGF0ZU1hcmtlckNvcnJlY3Rpb24gPSBuZXcgV2Vha01hcCgpO1xuXG4vLyBzcmMvaWNvbnMvbWFwYm94Z2wtY3RybC1sb2dvLnN2Z1xudmFyIG1hcGJveGdsX2N0cmxfbG9nb19kZWZhdWx0ID0gJzxzdmcgd2lkdGg9XCI4OFwiIGhlaWdodD1cIjIzXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj48ZGVmcz48cGF0aCBpZD1cImdcIiBkPVwiTTExLjUgMi4yNWE5LjI1IDkuMjUgMCAxIDEgMCAxOC41IDkuMjUgOS4yNSAwIDAgMSAwLTE4LjV6TTcgMTUuOThjLS4wNS0uMzMtLjgzLTUuOCAyLjIzLTguODdhNC40IDQuNCAwIDAgMSAzLjEzLTEuMjhjMS4yNyAwIDIuNDkuNTEgMy4zOSAxLjQyLjkxLjkgMS40MiAyLjEyIDEuNDIgMy4zOWE0LjQgNC40IDAgMCAxLTEuMjggMy4xM0MxMi43MiAxNi45MyA3IDE2IDcgMTZ2LS4wMnptOC4zLTUuNDgtMiAuOC0uOCAyLS44LTItMi0uOCAyLS44LjgtMiAuOCAyIDIgLjh6XCIvPjxwYXRoIGlkPVwiYlwiIGQ9XCJNNTAuNjMgOGMuMTMgMCAuMjMuMS4yMy4yM1Y5Yy43LS43NiAxLjctMS4xOCAyLjczLTEuMTggMi4xNyAwIDMuOTUgMS44NSAzLjk1IDQuMTdzLTEuNzcgNC4xOS0zLjk0IDQuMTlBMy43NyAzLjc3IDAgMCAxIDUwLjg2IDE1djMuNzdjMCAuMTMtLjEuMjMtLjIzLjIzaC0xLjRhLjIzLjIzIDAgMCAxLS4yMy0uMjNWOC4yM2MwLS4xMi4xLS4yMy4yMy0uMjNoMS40em0tMy44Ni4wMS4wMS0uMDFjLjEzIDAgLjIyLjEuMjIuMjJ2Ny41NWMwIC4xMi0uMS4yMy0uMjMuMjNoLTEuNGEuMjMuMjMgMCAwIDEtLjIzLS4yM1YxNWEzLjcgMy43IDAgMCAxLTIuNzMgMS4xOWMtMi4xNyAwLTMuOTQtMS44Ny0zLjk0LTQuMTkgMC0yLjMyIDEuNzctNC4xOSAzLjk0LTQuMTkgMS4wMyAwIDIuMDIuNDMgMi43MyAxLjE4di0uNzVjMC0uMTIuMS0uMjMuMjMtLjIzaDEuNHptMjYuMzgtLjE5YTQuMjQgNC4yNCAwIDAgMC00LjE2IDMuMjkgNC4wNyA0LjA3IDAgMCAwIDAgMS43NyA0LjIzIDQuMjMgMCAwIDAgNC4xNyAzLjMgNC4yMiA0LjIyIDAgMCAwIDQuMjYtNC4xOSA0LjIgNC4yIDAgMCAwLTQuMjctNC4xN3pNNjAuNjMgNWMuMTMgMCAuMjMuMS4yMy4yM3YzLjc2Yy43LS43NiAxLjctMS4xOCAyLjczLTEuMThhNCA0IDAgMCAxIDMuODQgMy4yOGMuMTMuNTkuMTMgMS4yIDAgMS44YTQgNCAwIDAgMS0zLjg0IDMuMjlBMy43NyAzLjc3IDAgMCAxIDYwLjg2IDE1di43N2MwIC4xMi0uMS4yMy0uMjMuMjNoLTEuNGEuMjMuMjMgMCAwIDEtLjIzLS4yM1Y1LjIzYzAtLjEyLjEtLjIzLjIzLS4yM2gxLjR6bS0zNCAxMWgtMS40YS4yMy4yMyAwIDAgMS0uMjMtLjIzVjguMjJjLjAxLS4xMy4xLS4yMi4yMy0uMjJoMS40Yy4xMyAwIC4yMi4xMS4yMy4yMnYuNjhjLjUtLjY4IDEuMy0xLjA5IDIuMTYtMS4xaC4wM2MxLjA5IDAgMi4wOS42IDIuNiAxLjU1YTIuNzMgMi43MyAwIDAgMSAyLjQ0LTEuNTZjMS42MiAwIDIuOTMgMS4yNSAyLjkgMi43OGwuMDMgNS4yYzAgLjEzLS4xLjIzLS4yMy4yM2gtMS40MWEuMjMuMjMgMCAwIDEtLjIzLS4yM3YtNC41OWMwLS45OC0uNzQtMS43MS0xLjYyLTEuNzEtLjggMC0xLjQ2LjctMS41OSAxLjYybC4wMSA0LjY4YzAgLjEzLS4xMS4yMy0uMjMuMjNoLTEuNDFhLjIzLjIzIDAgMCAxLS4yMy0uMjN2LTQuNTljMC0uOTgtLjc0LTEuNzEtMS42Mi0xLjcxLS44NSAwLTEuNTQuNzktMS42IDEuOHY0LjVjMCAuMTMtLjEuMjMtLjIzLjIzem01My42MiAwaC0xLjYxYS4yNy4yNyAwIDAgMS0uMTItLjAzYy0uMS0uMDYtLjEzLS4xOS0uMDYtLjI4bDIuNDMtMy43MS0yLjQtMy42NWEuMjEuMjEgMCAwIDEtLjAyLS4xMi4yLjIgMCAwIDEgLjItLjIxaDEuNjFjLjEzIDAgLjI0LjA2LjMuMTdMODIgMTAuNTRsMS40LTIuMzdhLjM0LjM0IDAgMCAxIC4zLS4xN2gxLjZsLjEyLjAzYy4xLjA2LjEzLjE5LjA2LjI4bC0yLjM3IDMuNjUgMi40MyAzLjcuMDEuMTNhLjIuMiAwIDAgMS0uMi4yMWgtMS42MWEuMzMuMzMgMCAwIDEtLjMtLjE3bC0xLjQ0LTIuNDItMS40NCAyLjQyYS4zNC4zNCAwIDAgMS0uMy4xN3ptLTcuMTItMS40OUEyLjQ3IDIuNDcgMCAwIDEgNzAuNyAxMmEyLjQ3IDIuNDcgMCAwIDEgMi40Mi0yLjUyIDIuNDcgMi40NyAwIDAgMSAyLjQyIDIuNTEgMi40OCAyLjQ4IDAgMCAxLTIuNDIgMi41MnptLTE5Ljg3IDBhMi40OCAyLjQ4IDAgMCAxLTIuNDItMi40OHYtLjA3YTIuNDcgMi40NyAwIDAgMSAyLjQtMi40OSAyLjQ3IDIuNDcgMCAwIDEgMi40MSAyLjUxIDIuNDcgMi40NyAwIDAgMS0yLjM5IDIuNTN6bS04LjExLTIuNDhjLS4wMSAxLjM3LTEuMDkgMi40Ny0yLjQxIDIuNDdzLTIuNDItMS4xMi0yLjQyLTIuNTFhMi40NyAyLjQ3IDAgMCAxIDIuNC0yLjUyIDIuNDYgMi40NiAwIDAgMSAyLjQxIDIuNDhsLjAyLjA4em0xOC4xMiAyLjQ3YTIuNDcgMi40NyAwIDAgMS0yLjQxLTIuNDh2LS4wNmMuMDItMS4zOCAxLjA5LTIuNDggMi40MS0yLjQ4czIuNDIgMS4xMiAyLjQyIDIuNTFhMi40NyAyLjQ3IDAgMCAxLTIuNDIgMi41MXpcIi8+PC9kZWZzPjxtYXNrIGlkPVwiY1wiPjxyZWN0IHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiBmaWxsPVwiI2ZmZlwiLz48dXNlIHhsaW5rOmhyZWY9XCIjZ1wiLz48dXNlIHhsaW5rOmhyZWY9XCIjYlwiLz48L21hc2s+PGcgb3BhY2l0eT1cIi4zXCIgc3Ryb2tlPVwiIzAwMFwiIHN0cm9rZS13aWR0aD1cIjNcIj48Y2lyY2xlIG1hc2s9XCJ1cmwoI2MpXCIgY3g9XCIxMS41XCIgY3k9XCIxMS41XCIgcj1cIjkuMjVcIi8+PHVzZSB4bGluazpocmVmPVwiI2JcIiBtYXNrPVwidXJsKCNjKVwiLz48L2c+PGcgb3BhY2l0eT1cIi45XCIgZmlsbD1cIiNmZmZcIj48dXNlIHhsaW5rOmhyZWY9XCIjZ1wiLz48dXNlIHhsaW5rOmhyZWY9XCIjYlwiLz48L2c+PC9zdmc+JztcblxuLy8gc3JjL2NvbXBvbmVudHMvTWFwYm94QWRkcmVzc01pbmltYXAudHNcbnZhciBaT09NID0gMTY7XG52YXIgVEVNUExBVEU2ID0gY3JlYXRlRWxlbWVudEZyb21TdHJpbmcoYFxuPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiTWFwYm94QWRkcmVzc01pbmltYXBcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICA8ZGl2IGNsYXNzPVwiTWluaW1hcEltYWdlQ29udGFpbmVyXCI+XG4gICAgICA8aW1nIGNsYXNzPVwiTWluaW1hcEltYWdlXCIgZHJhZ2dhYmxlPVwiZmFsc2VcIj48L2ltZz5cbiAgICAgIDxkaXYgY2xhc3M9XCJNaW5pbWFwSW5uZXJGcmFtZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiTWluaW1hcE1hcmtlclwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiTWluaW1hcEF0dHJpYnV0aW9uXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIk1pbmltYXBBdHRyaWJ1dGlvbkxvZ29cIj5cbiAgICAgICAgICAgIDxhIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vZm9sbG93XCIgaHJlZj1cImh0dHBzOi8vd3d3Lm1hcGJveC5jb20vXCIgYXJpYS1sYWJlbD1cIk1hcGJveCBsb2dvXCI+XG4gICAgICAgICAgICAgICR7bWFwYm94Z2xfY3RybF9sb2dvX2RlZmF1bHR9XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIk1pbmltYXBBdHRyaWJ1dGlvblRleHRcIj5cbiAgICAgICAgICAgIDxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9J2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vYWJvdXQvbWFwcy8nPlxceEE5IE1hcGJveDwvYT48YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPSdodHRwOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodCc+XFx4QTkgT3BlblN0cmVldE1hcDwvYT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuYCk7XG52YXIgU1RZTEVfVE9HR0xFX1RFTVBMQVRFID0gY3JlYXRlRWxlbWVudEZyb21TdHJpbmcoYFxuPHRlbXBsYXRlPlxuICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIk1pbmltYXBTdHlsZVRvZ2dsZVwiPjwvYnV0dG9uPlxuPC90ZW1wbGF0ZT5cbmApO1xudmFyIEZPT1RFUl9URU1QTEFURSA9IGNyZWF0ZUVsZW1lbnRGcm9tU3RyaW5nKGBcbjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIk1pbmltYXBGb290ZXJcIj5BZGp1c3QgdGhlIG1hcmtlciBvbiB0aGUgbWFwIGlmIGl0IGRvZXNuJ3QgcHJlY2lzZWx5IG1hdGNoIHlvdXIgbG9jYXRpb24uIFRoaXMgaGVscHMgaW1wcm92ZSBhZGRyZXNzIGRhdGEgcXVhbGl0eS48L2Rpdj5cbjwvdGVtcGxhdGU+XG5gKTtcbnZhciBFRElUX0JVVFRPTlNfVEVNUExBVEUgPSBjcmVhdGVFbGVtZW50RnJvbVN0cmluZyhgXG48dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJNaW5pbWFwRWRpdEJ1dHRvbnNcIj5cbiAgICA8ZGl2IGNsYXNzPVwiQnV0dG9uIEJ1dHRvblByaW1hcnkgTWluaW1hcEJ1dHRvbkFkanVzdFwiPkFkanVzdCBwaW48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiQnV0dG9uIEJ1dHRvblByaW1hcnkgTWluaW1hcEJ1dHRvblNhdmVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5TYXZlPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIkJ1dHRvbiBNaW5pbWFwQnV0dG9uQ2FuY2VsXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+Q2FuY2VsPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbmApO1xudmFyIF9jYW5BZGp1c3RNYXJrZXJJbnRlcm5hbCwgX2lzQWRqdXN0TWFya2VyRWRpdGluZywgX2ltYWdlTG9hZGVkLCBfZmVhdHVyZTIsIF91cmwsIF93aWR0aCwgX2hlaWdodCwgX2JpbmRpbmc1LCBfbWFya2VyQ29udHJvbGxlciwgX2FjY2Vzc1Rva2VuLCBfdGhlbWVJbnRlcm5hbDUsIF9zYXRlbGxpdGVUb2dnbGVJbnRlcm5hbCwgX21hcFN0eWxlTW9kZSwgX2RlZmF1bHRNYXBTdHlsZSwgX2Zvb3RlciwgX2NvbnRhaW5lciwgX3RvZ2dsZU1hcmtlckVkaXRpbmcsIF9oYW5kbGVTdGFydE1hcmtlckVkaXRpbmcsIF9oYW5kbGVTYXZlTWFya2VyRWRpdGluZywgX2hhbmRsZUNhbmNlbE1hcmtlckVkaXRpbmcsIF9oYW5kbGVUb2dnbGVNYXBTdHlsZSwgX2hhbmRsZUltYWdlTG9hZCwgX2hhbmRsZUltYWdlRXJyb3IsIF9nZXRJbWFnZVVybCwgX3VwZGF0ZUltYWdlU3JjLCBfZ2V0VG9nZ2xlQmFja2dyb3VuZEltYWdlVXJsLCBfc2V0U2l6ZSwgX2FkZE1hcmtlckVkaXRDb250cm9scywgX3JlbW92ZU1hcmtlckVkaXRDb250cm9scywgX2FkZFNhdGVsbGl0ZVRvZ2dsZSwgX3JlbW92ZVNhdGVsbGl0ZVRvZ2dsZTtcbnZhciBNYXBib3hBZGRyZXNzTWluaW1hcCA9IGNsYXNzIGV4dGVuZHMgSFRNTFNjb3BlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY2FuQWRqdXN0TWFya2VySW50ZXJuYWwsIGZhbHNlKTtcbiAgICB0aGlzLmtlZXBNYXJrZXJDZW50ZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMubWFya2VyQW5jaG9yID0gXCJib3R0b21cIjtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2lzQWRqdXN0TWFya2VyRWRpdGluZywgZmFsc2UpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaW1hZ2VMb2FkZWQsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2ZlYXR1cmUyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdXJsLCBcIlwiKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3dpZHRoLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGVpZ2h0LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYmluZGluZzUsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tYXJrZXJDb250cm9sbGVyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYWNjZXNzVG9rZW4sIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90aGVtZUludGVybmFsNSwge30pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfc2F0ZWxsaXRlVG9nZ2xlSW50ZXJuYWwsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21hcFN0eWxlTW9kZSwgXCJkZWZhdWx0XCIpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZGVmYXVsdE1hcFN0eWxlLCBbXCJtYXBib3hcIiwgXCJzdHJlZXRzLXYxMVwiXSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9mb290ZXIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9jb250YWluZXIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF90b2dnbGVNYXJrZXJFZGl0aW5nLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IEltYWdlQ29udGFpbmVyLCBCdXR0b25BZGp1c3QsIEJ1dHRvblNhdmUsIEJ1dHRvbkNhbmNlbCB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNSk7XG4gICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9pc0FkanVzdE1hcmtlckVkaXRpbmcpKSB7XG4gICAgICAgIEltYWdlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoYCR7dGhpcy5kYXRhc2V0LnNlZWR9LS1kcmFnZ2FibGVgKTtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJDb250cm9sbGVyKS5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIEJ1dHRvbkFkanVzdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIEJ1dHRvblNhdmUucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG4gICAgICAgIEJ1dHRvbkNhbmNlbC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEltYWdlQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoYCR7dGhpcy5kYXRhc2V0LnNlZWR9LS1kcmFnZ2FibGVgKTtcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJDb250cm9sbGVyKS5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBCdXR0b25BZGp1c3QucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG4gICAgICAgIEJ1dHRvblNhdmUuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICBCdXR0b25DYW5jZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlU3RhcnRNYXJrZXJFZGl0aW5nLCAoKSA9PiB7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2lzQWRqdXN0TWFya2VyRWRpdGluZywgdHJ1ZSk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3RvZ2dsZU1hcmtlckVkaXRpbmcpLmNhbGwodGhpcyk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVTYXZlTWFya2VyRWRpdGluZywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZS5wcm9wZXJ0aWVzLmZ1bGxfYWRkcmVzcyAmJiAhZGVlcEVxdWFscyh0aGlzLmZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFya2VyQ29udHJvbGxlcikuY29vcmRpbmF0ZSkpIHtcbiAgICAgICAgY29uc3QgW2xuZywgbGF0XSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFya2VyQ29udHJvbGxlcikuY29vcmRpbmF0ZTtcbiAgICAgICAgc2VuZEZlZWRiYWNrKHRoaXMuYWNjZXNzVG9rZW4sIHtcbiAgICAgICAgICBvcmlnaW5hbENvb3JkaW5hdGU6IHRoaXMuZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyxcbiAgICAgICAgICBvcmlnaW5hbEFkZHJlc3M6IHRoaXMuZmVhdHVyZS5wcm9wZXJ0aWVzLmZ1bGxfYWRkcmVzcyxcbiAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICBsb2NhdGlvbjogeyBsb25naXR1ZGU6IGxuZywgbGF0aXR1ZGU6IGxhdCB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9uU2F2ZU1hcmtlckxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMub25TYXZlTWFya2VyTG9jYXRpb24oX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJDb250cm9sbGVyKS5jb29yZGluYXRlKTtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaXNBZGp1c3RNYXJrZXJFZGl0aW5nLCBmYWxzZSk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX3RvZ2dsZU1hcmtlckVkaXRpbmcpLmNhbGwodGhpcyk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVDYW5jZWxNYXJrZXJFZGl0aW5nLCAoKSA9PiB7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX21hcmtlckNvbnRyb2xsZXIpLnJlQ2VudGVyKCk7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2lzQWRqdXN0TWFya2VyRWRpdGluZywgZmFsc2UpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF90b2dnbGVNYXJrZXJFZGl0aW5nKS5jYWxsKHRoaXMpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlVG9nZ2xlTWFwU3R5bGUsICgpID0+IHtcbiAgICAgIHRoaXMubWFwU3R5bGVNb2RlID0gdGhpcy5tYXBTdHlsZU1vZGUgPT09IFwiZGVmYXVsdFwiID8gXCJzYXRlbGxpdGVcIiA6IFwiZGVmYXVsdFwiO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaGFuZGxlSW1hZ2VMb2FkLCAoKSA9PiB7XG4gICAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfaW1hZ2VMb2FkZWQpKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFya2VyQ29udHJvbGxlcikucmVDZW50ZXIoKTtcbiAgICAgIH1cbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaW1hZ2VMb2FkZWQsIHRydWUpO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9tYXJrZXJDb250cm9sbGVyKSAmJiBfX3ByaXZhdGVHZXQodGhpcywgX21hcmtlckNvbnRyb2xsZXIpLmhhbmRsZU1pbmltYXBSZXNpemUoKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUltYWdlRXJyb3IsICgpID0+IHtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaW1hZ2VMb2FkZWQsIGZhbHNlKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2dldEltYWdlVXJsLCAobG5nTGF0TGlrZSkgPT4ge1xuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfd2lkdGgpID09PSAwIHx8IF9fcHJpdmF0ZUdldCh0aGlzLCBfaGVpZ2h0KSA9PT0gMClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBjb25zdCBbdXNlcm5hbWUsIHN0eWxlSWRdID0gdGhpcy5kZWZhdWx0TWFwU3R5bGU7XG4gICAgICBjb25zdCBkZWZhdWx0QmFzZVVybCA9IGdldFN0YXRpY0Jhc2VVcmwodXNlcm5hbWUsIHN0eWxlSWQpO1xuICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMubWFwU3R5bGVNb2RlID09PSBcImRlZmF1bHRcIiA/IGRlZmF1bHRCYXNlVXJsIDogU1RBVElDX0JBU0VfVVJMX1NBVEVMTElURTtcbiAgICAgIGNvbnN0IHNrdVRva2VuID0gQVVUT0ZJTExfU0tVX1RPS0VOX1BSRUZJWCArIGNvbmZpZy5hdXRvZmlsbFNlc3Npb25Ub2tlbi50b1N0cmluZygpO1xuICAgICAgbGV0IGltZ1VybCA9IGJhc2VVcmwgKyBMbmdMYXQuY29udmVydChsbmdMYXRMaWtlKS50b0FycmF5KCkuam9pbihcIixcIikgKyBcIixcIiArIFpPT00gKyBcIiwwL1wiICsgTWF0aC5taW4oX19wcml2YXRlR2V0KHRoaXMsIF93aWR0aCkgKiAyLCBNQVhfSU1BR0VfRElNKSArIFwieFwiICsgTWF0aC5taW4oX19wcml2YXRlR2V0KHRoaXMsIF9oZWlnaHQpICogMiwgTUFYX0lNQUdFX0RJTSkgKyBcIj9hY2Nlc3NfdG9rZW49XCIgKyB0aGlzLmFjY2Vzc1Rva2VuICsgXCImYXR0cmlidXRpb249ZmFsc2UmbG9nbz1mYWxzZVwiO1xuICAgICAgaWYgKGNvbmZpZy5hdXRvZmlsbFNlc3Npb25FbmFibGVkKSB7XG4gICAgICAgIGltZ1VybCArPSBgJnNrdT0ke3NrdVRva2VufWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1nVXJsO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdXBkYXRlSW1hZ2VTcmMsICgpID0+IHtcbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2ZlYXR1cmUyKSkge1xuICAgICAgICBjb25zdCBsbmdMYXQgPSBfX3ByaXZhdGVHZXQodGhpcywgX2ZlYXR1cmUyKS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF91cmwsIF9fcHJpdmF0ZUdldCh0aGlzLCBfZ2V0SW1hZ2VVcmwpLmNhbGwodGhpcywgbG5nTGF0KSk7XG4gICAgICAgIGNvbnN0IHsgSW1hZ2UgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzUpO1xuICAgICAgICBJbWFnZS5zcmMgPSBfX3ByaXZhdGVHZXQodGhpcywgX3VybCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9nZXRUb2dnbGVCYWNrZ3JvdW5kSW1hZ2VVcmwsIChzdHlsZU1vZGUpID0+IHtcbiAgICAgIHJldHVybiBgdXJsKFwiJHtnZXRJbWFnZShzdHlsZU1vZGUgPT09IFwiZGVmYXVsdFwiID8gXCJzdHlsZVRvZ2dsZURlZmF1bHRcIiA6IFwic3R5bGVUb2dnbGVTYXRlbGxpdGVcIiwgdGhpcy50aGVtZSl9XCIpYDtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3NldFNpemUsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgTWFwYm94QWRkcmVzc01pbmltYXA6IE1hcGJveEFkZHJlc3NNaW5pbWFwMiwgSW1hZ2VDb250YWluZXIsIEltYWdlIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc1KTtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0RWxlbWVudFNpemUodGhpcy5jb250YWluZXIpO1xuICAgICAgY29uc3QgW29sZFdpZHRoLCBvbGRIZWlnaHRdID0gW19fcHJpdmF0ZUdldCh0aGlzLCBfd2lkdGgpLCBfX3ByaXZhdGVHZXQodGhpcywgX2hlaWdodCldO1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF93aWR0aCwgTWF0aC5taW4od2lkdGgsIE1BWF9JTUFHRV9ESU0pKTtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaGVpZ2h0LCBNYXRoLm1pbihoZWlnaHQsIE1BWF9JTUFHRV9ESU0pKTtcbiAgICAgIE1hcGJveEFkZHJlc3NNaW5pbWFwMi5zdHlsZS5zZXRQcm9wZXJ0eShcIndpZHRoXCIsIGAke19fcHJpdmF0ZUdldCh0aGlzLCBfd2lkdGgpfXB4YCk7XG4gICAgICBNYXBib3hBZGRyZXNzTWluaW1hcDIuc3R5bGUuc2V0UHJvcGVydHkoXCJoZWlnaHRcIiwgYCR7X19wcml2YXRlR2V0KHRoaXMsIF9oZWlnaHQpfXB4YCk7XG4gICAgICBJbWFnZUNvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eShcImhlaWdodFwiLCBgJHtfX3ByaXZhdGVHZXQodGhpcywgX2hlaWdodCl9cHhgKTtcbiAgICAgIEltYWdlQ29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwid2lkdGhcIiwgYCR7X19wcml2YXRlR2V0KHRoaXMsIF93aWR0aCl9cHhgKTtcbiAgICAgIGNvbnN0IFtpbWdXaWR0aCwgaW1nSGVpZ2h0XSA9IFtJbWFnZS53aWR0aCwgSW1hZ2UuaGVpZ2h0XTtcbiAgICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX3dpZHRoKSA+IG9sZFdpZHRoICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfd2lkdGgpID4gaW1nV2lkdGggLyAyICYmIGltZ1dpZHRoIDwgTUFYX0lNQUdFX0RJTSB8fCBfX3ByaXZhdGVHZXQodGhpcywgX2hlaWdodCkgPiBvbGRIZWlnaHQgJiYgX19wcml2YXRlR2V0KHRoaXMsIF9oZWlnaHQpID4gaW1nSGVpZ2h0IC8gMiAmJiBpbWdIZWlnaHQgPCBNQVhfSU1BR0VfRElNKSB7XG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfdXBkYXRlSW1hZ2VTcmMpLmNhbGwodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfX3ByaXZhdGVHZXQodGhpcywgX21hcmtlckNvbnRyb2xsZXIpICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFya2VyQ29udHJvbGxlcikuaGFuZGxlTWluaW1hcFJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYWRkTWFya2VyRWRpdENvbnRyb2xzLCAoKSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZ0Zvb3RlciA9IHRoaXMucXVlcnlTZWxlY3RvcihcIi5NaW5pbWFwRm9vdGVyXCIpO1xuICAgICAgaWYgKGV4aXN0aW5nRm9vdGVyKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBmb290ZXJFbGVtZW50ID0gdGhpcy5wcmVwYXJlVGVtcGxhdGUoRk9PVEVSX1RFTVBMQVRFKTtcbiAgICAgIGNvbnN0IG1pbmltYXBFbGVtZW50ID0gdGhpcy5xdWVyeVNlbGVjdG9yKFwiLk1hcGJveEFkZHJlc3NNaW5pbWFwXCIpO1xuICAgICAgaWYgKCFtaW5pbWFwRWxlbWVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbWluaW1hcEVsZW1lbnQuYXBwZW5kQ2hpbGQoZm9vdGVyRWxlbWVudCk7XG4gICAgICBjb25zdCBleGlzdGluZ0VkaXRCdG5zID0gdGhpcy5xdWVyeVNlbGVjdG9yKFwiLk1pbmltYXBFZGl0QnV0dG9uc1wiKTtcbiAgICAgIGlmIChleGlzdGluZ0VkaXRCdG5zKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBlZGl0QnV0dG9uc0VsZW1lbnQgPSB0aGlzLnByZXBhcmVUZW1wbGF0ZShFRElUX0JVVFRPTlNfVEVNUExBVEUpO1xuICAgICAgY29uc3QgaW5uZXJGcmFtZSA9IHRoaXMucXVlcnlTZWxlY3RvcihcIi5NaW5pbWFwSW5uZXJGcmFtZVwiKTtcbiAgICAgIGlubmVyRnJhbWUuYXBwZW5kQ2hpbGQoZWRpdEJ1dHRvbnNFbGVtZW50KTtcbiAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfYmluZGluZzUsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzUpKSwge1xuICAgICAgICBFZGl0QnV0dG9uczogdGhpcy5xdWVyeVNlbGVjdG9yKFwiLk1pbmltYXBFZGl0QnV0dG9uc1wiKSxcbiAgICAgICAgQnV0dG9uQWRqdXN0OiB0aGlzLnF1ZXJ5U2VsZWN0b3IoXCIuTWluaW1hcEJ1dHRvbkFkanVzdFwiKSxcbiAgICAgICAgQnV0dG9uU2F2ZTogdGhpcy5xdWVyeVNlbGVjdG9yKFwiLk1pbmltYXBCdXR0b25TYXZlXCIpLFxuICAgICAgICBCdXR0b25DYW5jZWw6IHRoaXMucXVlcnlTZWxlY3RvcihcIi5NaW5pbWFwQnV0dG9uQ2FuY2VsXCIpXG4gICAgICB9KSk7XG4gICAgICBjb25zdCB7IEJ1dHRvbkFkanVzdCwgQnV0dG9uU2F2ZSwgQnV0dG9uQ2FuY2VsIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc1KTtcbiAgICAgIEJ1dHRvbkFkanVzdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTdGFydE1hcmtlckVkaXRpbmcpKTtcbiAgICAgIEJ1dHRvblNhdmUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlU2F2ZU1hcmtlckVkaXRpbmcpKTtcbiAgICAgIEJ1dHRvbkNhbmNlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDYW5jZWxNYXJrZXJFZGl0aW5nKSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9yZW1vdmVNYXJrZXJFZGl0Q29udHJvbHMsICgpID0+IHtcbiAgICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHsgRWRpdEJ1dHRvbnMsIEJ1dHRvbkFkanVzdCwgQnV0dG9uU2F2ZSwgQnV0dG9uQ2FuY2VsIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc1KTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nRm9vdGVyID0gdGhpcy5xdWVyeVNlbGVjdG9yKFwiLk1pbmltYXBGb290ZXJcIik7XG4gICAgICBleGlzdGluZ0Zvb3RlciA9PSBudWxsID8gdm9pZCAwIDogZXhpc3RpbmdGb290ZXIucmVtb3ZlKCk7XG4gICAgICBFZGl0QnV0dG9ucyA9PSBudWxsID8gdm9pZCAwIDogRWRpdEJ1dHRvbnMucmVtb3ZlKCk7XG4gICAgICBpZiAoQnV0dG9uQWRqdXN0KSB7XG4gICAgICAgIEJ1dHRvbkFkanVzdC5yZW1vdmUoKTtcbiAgICAgICAgQnV0dG9uQWRqdXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN0YXJ0TWFya2VyRWRpdGluZykpO1xuICAgICAgfVxuICAgICAgaWYgKEJ1dHRvblNhdmUpIHtcbiAgICAgICAgQnV0dG9uU2F2ZS5yZW1vdmUoKTtcbiAgICAgICAgQnV0dG9uU2F2ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTYXZlTWFya2VyRWRpdGluZykpO1xuICAgICAgfVxuICAgICAgaWYgKEJ1dHRvbkNhbmNlbCkge1xuICAgICAgICBCdXR0b25DYW5jZWwucmVtb3ZlKCk7XG4gICAgICAgIEJ1dHRvbkNhbmNlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVDYW5jZWxNYXJrZXJFZGl0aW5nKSk7XG4gICAgICB9XG4gICAgICBkZWxldGUgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNSkuRWRpdEJ1dHRvbnM7XG4gICAgICBkZWxldGUgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNSkuQnV0dG9uQWRqdXN0O1xuICAgICAgZGVsZXRlIF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzUpLkJ1dHRvblNhdmU7XG4gICAgICBkZWxldGUgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNSkuQnV0dG9uQ2FuY2VsO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYWRkU2F0ZWxsaXRlVG9nZ2xlLCAoKSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZ1RvZ2dsZSA9IHRoaXMucXVlcnlTZWxlY3RvcihcIi5NaW5pbWFwU3R5bGVUb2dnbGVcIik7XG4gICAgICBpZiAoZXhpc3RpbmdUb2dnbGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHRvZ2dsZUVsZW1lbnQgPSB0aGlzLnByZXBhcmVUZW1wbGF0ZShTVFlMRV9UT0dHTEVfVEVNUExBVEUpO1xuICAgICAgY29uc3QgaW5uZXJGcmFtZSA9IHRoaXMucXVlcnlTZWxlY3RvcihcIi5NaW5pbWFwSW5uZXJGcmFtZVwiKTtcbiAgICAgIGlmICghaW5uZXJGcmFtZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaW5uZXJGcmFtZS5hcHBlbmRDaGlsZCh0b2dnbGVFbGVtZW50KTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzUpLk1hcFN0eWxlVG9nZ2xlID0gdG9nZ2xlRWxlbWVudDtcbiAgICAgIHRvZ2dsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlVG9nZ2xlTWFwU3R5bGUpKTtcbiAgICAgIHRvZ2dsZUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gX19wcml2YXRlR2V0KHRoaXMsIF9nZXRUb2dnbGVCYWNrZ3JvdW5kSW1hZ2VVcmwpLmNhbGwodGhpcywgdGhpcy5tYXBTdHlsZU1vZGUgPT09IFwiZGVmYXVsdFwiID8gXCJzYXRlbGxpdGVcIiA6IFwiZGVmYXVsdFwiKTtcbiAgICAgIHRvZ2dsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgYFN3aXRjaCB0byAke3RoaXMubWFwU3R5bGVNb2RlID09PSBcImRlZmF1bHRcIiA/IFwiU2F0ZWxsaXRlXCIgOiBcIkRlZmF1bHRcIn1gKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3JlbW92ZVNhdGVsbGl0ZVRvZ2dsZSwgKCkgPT4ge1xuICAgICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc1KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgeyBNYXBTdHlsZVRvZ2dsZSB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNSk7XG4gICAgICBpZiAoIU1hcFN0eWxlVG9nZ2xlKVxuICAgICAgICByZXR1cm47XG4gICAgICBNYXBTdHlsZVRvZ2dsZS5yZW1vdmUoKTtcbiAgICAgIE1hcFN0eWxlVG9nZ2xlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVRvZ2dsZU1hcFN0eWxlKSk7XG4gICAgICBkZWxldGUgX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNSkuTWFwU3R5bGVUb2dnbGU7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGNhbkFkanVzdE1hcmtlcigpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9jYW5BZGp1c3RNYXJrZXJJbnRlcm5hbCk7XG4gIH1cbiAgc2V0IGNhbkFkanVzdE1hcmtlcih2YWwpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2NhbkFkanVzdE1hcmtlckludGVybmFsLCB2YWwpO1xuICAgIHZhbCA/IF9fcHJpdmF0ZUdldCh0aGlzLCBfYWRkTWFya2VyRWRpdENvbnRyb2xzKS5jYWxsKHRoaXMpIDogX19wcml2YXRlR2V0KHRoaXMsIF9yZW1vdmVNYXJrZXJFZGl0Q29udHJvbHMpLmNhbGwodGhpcyk7XG4gIH1cbiAgZ2V0IGFjY2Vzc1Rva2VuKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2FjY2Vzc1Rva2VuKSB8fCBjb25maWcuYWNjZXNzVG9rZW47XG4gIH1cbiAgc2V0IGFjY2Vzc1Rva2VuKG5ld1Rva2VuKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9hY2Nlc3NUb2tlbiwgbmV3VG9rZW4pO1xuICB9XG4gIGdldCBmZWF0dXJlKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2ZlYXR1cmUyKTtcbiAgfVxuICBzZXQgZmVhdHVyZShmZWF0dXJlKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9mZWF0dXJlMiwgZmVhdHVyZSk7XG4gICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9XG4gIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gVEVNUExBVEU2O1xuICB9XG4gIGdldCB0ZW1wbGF0ZVN0eWxlKCkge1xuICAgIHJldHVybiBzdHlsZV9kZWZhdWx0O1xuICB9XG4gIGdldCB0ZW1wbGF0ZVVzZXJTdHlsZSgpIHtcbiAgICByZXR1cm4gZ2V0VGhlbWVDU1MoXCIuTWFwYm94QWRkcmVzc01pbmltYXBcIiwgdGhpcy50aGVtZSk7XG4gIH1cbiAgZ2V0IHNhdGVsbGl0ZVRvZ2dsZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9zYXRlbGxpdGVUb2dnbGVJbnRlcm5hbCk7XG4gIH1cbiAgc2V0IHNhdGVsbGl0ZVRvZ2dsZSh2YWwpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3NhdGVsbGl0ZVRvZ2dsZUludGVybmFsLCB2YWwpO1xuICAgIHZhbCA/IF9fcHJpdmF0ZUdldCh0aGlzLCBfYWRkU2F0ZWxsaXRlVG9nZ2xlKS5jYWxsKHRoaXMpIDogX19wcml2YXRlR2V0KHRoaXMsIF9yZW1vdmVTYXRlbGxpdGVUb2dnbGUpLmNhbGwodGhpcyk7XG4gIH1cbiAgZ2V0IHRoZW1lKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX3RoZW1lSW50ZXJuYWw1KTtcbiAgfVxuICBzZXQgdGhlbWUodGhlbWUpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3RoZW1lSW50ZXJuYWw1LCB0aGVtZSk7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc1KSB8fCAhdGhlbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVUZW1wbGF0ZVVzZXJTdHlsZShnZXRUaGVtZUNTUyhcIi5NYXBib3hBZGRyZXNzTWluaW1hcFwiLCB0aGVtZSkpO1xuICAgIGNvbnN0IHsgTWFya2VyLCBNYXBTdHlsZVRvZ2dsZSB9ID0gX19wcml2YXRlR2V0KHRoaXMsIF9iaW5kaW5nNSk7XG4gICAgTWFya2VyLmlubmVySFRNTCA9IGdldEljb24oXCJtYXJrZXJcIiwgdGhlbWUpO1xuICAgIGlmIChNYXBTdHlsZVRvZ2dsZSkge1xuICAgICAgTWFwU3R5bGVUb2dnbGUuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gX19wcml2YXRlR2V0KHRoaXMsIF9nZXRUb2dnbGVCYWNrZ3JvdW5kSW1hZ2VVcmwpLmNhbGwodGhpcywgdGhpcy5tYXBTdHlsZU1vZGUgPT09IFwiZGVmYXVsdFwiID8gXCJzYXRlbGxpdGVcIiA6IFwiZGVmYXVsdFwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1hcFN0eWxlTW9kZSgpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9tYXBTdHlsZU1vZGUpO1xuICB9XG4gIHNldCBtYXBTdHlsZU1vZGUoc3R5bGVNb2RlKSB7XG4gICAgY29uc3QgcHJldlN0eWxlTW9kZSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwU3R5bGVNb2RlKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX21hcFN0eWxlTW9kZSwgc3R5bGVNb2RlKTtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgTWFwU3R5bGVUb2dnbGUgfSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfYmluZGluZzUpO1xuICAgIGlmICghTWFwU3R5bGVUb2dnbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgTWFwU3R5bGVUb2dnbGUuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gX19wcml2YXRlR2V0KHRoaXMsIF9nZXRUb2dnbGVCYWNrZ3JvdW5kSW1hZ2VVcmwpLmNhbGwodGhpcywgcHJldlN0eWxlTW9kZSk7XG4gICAgTWFwU3R5bGVUb2dnbGUuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgYFN3aXRjaCB0byAke3ByZXZTdHlsZU1vZGUgPT09IFwic2F0ZWxsaXRlXCIgPyBcIlNhdGVsbGl0ZVwiIDogXCJEZWZhdWx0XCJ9YCk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF91cGRhdGVJbWFnZVNyYykuY2FsbCh0aGlzKTtcbiAgfVxuICBnZXQgZGVmYXVsdE1hcFN0eWxlKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2RlZmF1bHRNYXBTdHlsZSk7XG4gIH1cbiAgc2V0IGRlZmF1bHRNYXBTdHlsZShzdHlsZSkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfZGVmYXVsdE1hcFN0eWxlLCBzdHlsZSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF91cGRhdGVJbWFnZVNyYykuY2FsbCh0aGlzKTtcbiAgfVxuICBnZXQgZm9vdGVyKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2Zvb3Rlcik7XG4gIH1cbiAgc2V0IGZvb3Rlcih2YWwpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2Zvb3RlciwgdmFsKTtcbiAgICBjb25zdCBmb290ZXJFbCA9IHRoaXMucXVlcnlTZWxlY3RvcihcIi5NaW5pbWFwRm9vdGVyXCIpO1xuICAgIGlmIChmb290ZXJFbCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZm9vdGVyRWwudGV4dENvbnRlbnQgPSB2YWw7XG4gICAgICAgIGZvb3RlckVsLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgICAgfSBlbHNlIGlmICghdmFsKSB7XG4gICAgICAgIGZvb3RlckVsLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvb3RlckVsLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2NvbnRhaW5lcik7XG4gIH1cbiAgc2V0IGNvbnRhaW5lcihuZXdDb250YWluZXIpIHtcbiAgICBpZiAobmV3Q29udGFpbmVyKSB7XG4gICAgICBuZXdDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX2NvbnRhaW5lciwgbmV3Q29udGFpbmVyKTtcbiAgICB9XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfZmVhdHVyZTIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxuZ0xhdCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZmVhdHVyZTIpLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFya2VyQ29udHJvbGxlcikuY29vcmRpbmF0ZSA9IGxuZ0xhdDtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3VybCwgX19wcml2YXRlR2V0KHRoaXMsIF9nZXRJbWFnZVVybCkuY2FsbCh0aGlzLCBsbmdMYXQpKTtcbiAgICBjb25zdCB7IE1hcGJveEFkZHJlc3NNaW5pbWFwOiBNYXBib3hBZGRyZXNzTWluaW1hcDIsIEltYWdlIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc1KTtcbiAgICBJbWFnZS5zcmMgPSBfX3ByaXZhdGVHZXQodGhpcywgX3VybCk7XG4gICAgTWFwYm94QWRkcmVzc01pbmltYXAyLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgY29uc3QgeyBNYXBib3hBZGRyZXNzTWluaW1hcDogTWFwYm94QWRkcmVzc01pbmltYXAyIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc1KTtcbiAgICBNYXBib3hBZGRyZXNzTWluaW1hcDIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9iaW5kaW5nNSwgYmluZEVsZW1lbnRzKHRoaXMsIHtcbiAgICAgIE1hcGJveEFkZHJlc3NNaW5pbWFwOiBcIi5NYXBib3hBZGRyZXNzTWluaW1hcFwiLFxuICAgICAgSW1hZ2VDb250YWluZXI6IFwiLk1pbmltYXBJbWFnZUNvbnRhaW5lclwiLFxuICAgICAgSW1hZ2U6IFwiLk1pbmltYXBJbWFnZVwiLFxuICAgICAgTWFya2VyOiBcIi5NaW5pbWFwTWFya2VyXCIsXG4gICAgICBNYXBTdHlsZVRvZ2dsZTogXCIuTWluaW1hcFN0eWxlVG9nZ2xlXCIsXG4gICAgICBFZGl0QnV0dG9uczogXCIuTWluaW1hcEVkaXRCdXR0b25zXCIsXG4gICAgICBCdXR0b25BZGp1c3Q6IFwiLk1pbmltYXBCdXR0b25BZGp1c3RcIixcbiAgICAgIEJ1dHRvblNhdmU6IFwiLk1pbmltYXBCdXR0b25TYXZlXCIsXG4gICAgICBCdXR0b25DYW5jZWw6IFwiLk1pbmltYXBCdXR0b25DYW5jZWxcIlxuICAgIH0pKTtcbiAgICB0aGlzLm1hcFN0eWxlTW9kZSA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwU3R5bGVNb2RlKTtcbiAgICB0aGlzLnRoZW1lID0gX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMudGhlbWUpO1xuICAgIGlmICh0aGlzLmNhbkFkanVzdE1hcmtlcikge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9hZGRNYXJrZXJFZGl0Q29udHJvbHMpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNhdGVsbGl0ZVRvZ2dsZSkge1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9hZGRTYXRlbGxpdGVUb2dnbGUpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5wYXJlbnRFbGVtZW50O1xuICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKF9fcHJpdmF0ZUdldCh0aGlzLCBfc2V0U2l6ZSkpO1xuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5jb250YWluZXIpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2V0U2l6ZSkuY2FsbCh0aGlzKTtcbiAgICBjb25zdCB7IE1hcGJveEFkZHJlc3NNaW5pbWFwOiBNYXBib3hBZGRyZXNzTWluaW1hcDIsIEltYWdlQ29udGFpbmVyLCBJbWFnZSwgTWFya2VyIH0gPSBfX3ByaXZhdGVHZXQodGhpcywgX2JpbmRpbmc1KTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX21hcmtlckNvbnRyb2xsZXIsIG5ldyBNYXJrZXJDb250cm9sbGVyKEltYWdlQ29udGFpbmVyLCBJbWFnZSwgTWFya2VyLCB0aGlzLmtlZXBNYXJrZXJDZW50ZXJlZCwgWk9PTSwgdGhpcy5tYXJrZXJBbmNob3IpKTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX21hcmtlckNvbnRyb2xsZXIpLnJlQ2VudGVyKCk7XG4gICAgSW1hZ2Uub25sb2FkID0gX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVJbWFnZUxvYWQpO1xuICAgIEltYWdlLm9uZXJyb3IgPSBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZUltYWdlRXJyb3IpO1xuICAgIEltYWdlLnNyYyA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfdXJsKTtcbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9mZWF0dXJlMikpXG4gICAgICBNYXBib3hBZGRyZXNzTWluaW1hcDIucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG4gICAgZWxzZVxuICAgICAgTWFwYm94QWRkcmVzc01pbmltYXAyLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgfVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IFwiYWNjZXNzLXRva2VuXCIpIHtcbiAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBuZXdWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiY2FuLWFkanVzdC1tYXJrZXJcIikge1xuICAgICAgdGhpcy5jYW5BZGp1c3RNYXJrZXIgPSBuZXdWYWx1ZSA9PT0gXCJ0cnVlXCI7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcImtlZXAtbWFya2VyLWNlbnRlcmVkXCIpIHtcbiAgICAgIHRoaXMua2VlcE1hcmtlckNlbnRlcmVkID0gbmV3VmFsdWUgPT09IFwidHJ1ZVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJtYXJrZXItYW5jaG9yXCIpIHtcbiAgICAgIGNvbnN0IG5ld0FuY2hvciA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5tYXJrZXJBbmNob3IgPSBuZXdBbmNob3I7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX21hcmtlckNvbnRyb2xsZXIpICYmIChfX3ByaXZhdGVHZXQodGhpcywgX21hcmtlckNvbnRyb2xsZXIpLmFuY2hvciA9IG5ld0FuY2hvcik7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcInNhdGVsbGl0ZS10b2dnbGVcIikge1xuICAgICAgdGhpcy5zYXRlbGxpdGVUb2dnbGUgPSBuZXdWYWx1ZSA9PT0gXCJ0cnVlXCI7XG4gICAgfVxuICB9XG59O1xuX2NhbkFkanVzdE1hcmtlckludGVybmFsID0gbmV3IFdlYWtNYXAoKTtcbl9pc0FkanVzdE1hcmtlckVkaXRpbmcgPSBuZXcgV2Vha01hcCgpO1xuX2ltYWdlTG9hZGVkID0gbmV3IFdlYWtNYXAoKTtcbl9mZWF0dXJlMiA9IG5ldyBXZWFrTWFwKCk7XG5fdXJsID0gbmV3IFdlYWtNYXAoKTtcbl93aWR0aCA9IG5ldyBXZWFrTWFwKCk7XG5faGVpZ2h0ID0gbmV3IFdlYWtNYXAoKTtcbl9iaW5kaW5nNSA9IG5ldyBXZWFrTWFwKCk7XG5fbWFya2VyQ29udHJvbGxlciA9IG5ldyBXZWFrTWFwKCk7XG5fYWNjZXNzVG9rZW4gPSBuZXcgV2Vha01hcCgpO1xuX3RoZW1lSW50ZXJuYWw1ID0gbmV3IFdlYWtNYXAoKTtcbl9zYXRlbGxpdGVUb2dnbGVJbnRlcm5hbCA9IG5ldyBXZWFrTWFwKCk7XG5fbWFwU3R5bGVNb2RlID0gbmV3IFdlYWtNYXAoKTtcbl9kZWZhdWx0TWFwU3R5bGUgPSBuZXcgV2Vha01hcCgpO1xuX2Zvb3RlciA9IG5ldyBXZWFrTWFwKCk7XG5fY29udGFpbmVyID0gbmV3IFdlYWtNYXAoKTtcbl90b2dnbGVNYXJrZXJFZGl0aW5nID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVTdGFydE1hcmtlckVkaXRpbmcgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVNhdmVNYXJrZXJFZGl0aW5nID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVDYW5jZWxNYXJrZXJFZGl0aW5nID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVUb2dnbGVNYXBTdHlsZSA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlSW1hZ2VMb2FkID0gbmV3IFdlYWtNYXAoKTtcbl9oYW5kbGVJbWFnZUVycm9yID0gbmV3IFdlYWtNYXAoKTtcbl9nZXRJbWFnZVVybCA9IG5ldyBXZWFrTWFwKCk7XG5fdXBkYXRlSW1hZ2VTcmMgPSBuZXcgV2Vha01hcCgpO1xuX2dldFRvZ2dsZUJhY2tncm91bmRJbWFnZVVybCA9IG5ldyBXZWFrTWFwKCk7XG5fc2V0U2l6ZSA9IG5ldyBXZWFrTWFwKCk7XG5fYWRkTWFya2VyRWRpdENvbnRyb2xzID0gbmV3IFdlYWtNYXAoKTtcbl9yZW1vdmVNYXJrZXJFZGl0Q29udHJvbHMgPSBuZXcgV2Vha01hcCgpO1xuX2FkZFNhdGVsbGl0ZVRvZ2dsZSA9IG5ldyBXZWFrTWFwKCk7XG5fcmVtb3ZlU2F0ZWxsaXRlVG9nZ2xlID0gbmV3IFdlYWtNYXAoKTtcbk1hcGJveEFkZHJlc3NNaW5pbWFwLm9ic2VydmVkQXR0cmlidXRlcyA9IFtcbiAgXCJhY2Nlc3MtdG9rZW5cIixcbiAgXCJjYW4tYWRqdXN0LW1hcmtlclwiLFxuICBcImtlZXAtbWFya2VyLWNlbnRlcmVkXCIsXG4gIFwibWFya2VyLWFuY2hvclwiLFxuICBcInNhdGVsbGl0ZS10b2dnbGVcIlxuXTtcbndpbmRvdy5NYXBib3hBZGRyZXNzTWluaW1hcCA9IE1hcGJveEFkZHJlc3NNaW5pbWFwO1xuaWYgKCF3aW5kb3cuY3VzdG9tRWxlbWVudHMuZ2V0KFwibWFwYm94LWFkZHJlc3MtbWluaW1hcFwiKSkge1xuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoXCJtYXBib3gtYWRkcmVzcy1taW5pbWFwXCIsIE1hcGJveEFkZHJlc3NNaW5pbWFwKTtcbn1cblxuLy8gc3JjL2F1dG9maWxsLnRzXG5pbXBvcnQge1xuICBFdmVudGVkLFxuICBNYXBib3hBdXRvZmlsbCBhcyBNYXBib3hBdXRvZmlsbDIsXG4gIFNlYXJjaFNlc3Npb24gYXMgU2VhcmNoU2Vzc2lvbjNcbn0gZnJvbSBcIkBtYXBib3gvc2VhcmNoLWpzLWNvcmVcIjtcbnZhciBfaW5wdXQzLCBfY29sbGVjdGlvbiwgX2hhbmRsZVN1Z2dlc3Q0LCBfaGFuZGxlU3VnZ2VzdEVycm9yNCwgX2hhbmRsZVJldHJpZXZlMztcbnZhciBBdXRvZmlsbEluc3RhbmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uLCBpbnB1dCwgYXV0b2ZpbGxSZWYpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2lucHV0Mywgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NvbGxlY3Rpb24sIHZvaWQgMCk7XG4gICAgdGhpcy5saXN0Ym94ID0gbmV3IE1hcGJveFNlYXJjaExpc3Rib3goKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZVN1Z2dlc3Q0LCAoZSkgPT4ge1xuICAgICAgY29uc3QgZXZlbnRDbG9uZSA9IG5ldyBNYXBib3hIVE1MRXZlbnQoZS50eXBlLCBlLmRldGFpbCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnRDbG9uZSwgXCJ0YXJnZXRcIiwgeyB2YWx1ZTogX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dDMpIH0pO1xuICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9jb2xsZWN0aW9uKS5maXJlKFwic3VnZ2VzdFwiLCBldmVudENsb25lKTtcbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZVN1Z2dlc3RFcnJvcjQsIChlKSA9PiB7XG4gICAgICBjb25zdCBldmVudENsb25lID0gbmV3IE1hcGJveEhUTUxFdmVudChlLnR5cGUsIGUuZGV0YWlsKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudENsb25lLCBcInRhcmdldFwiLCB7IHZhbHVlOiBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0MykgfSk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2NvbGxlY3Rpb24pLmZpcmUoXCJzdWdnZXN0ZXJyb3JcIiwgZXZlbnRDbG9uZSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVSZXRyaWV2ZTMsIChlKSA9PiB7XG4gICAgICBjb25zdCBldmVudENsb25lID0gbmV3IE1hcGJveEhUTUxFdmVudChlLnR5cGUsIGUuZGV0YWlsKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudENsb25lLCBcInRhcmdldFwiLCB7IHZhbHVlOiBfX3ByaXZhdGVHZXQodGhpcywgX2lucHV0MykgfSk7XG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2NvbGxlY3Rpb24pLmZpcmUoXCJyZXRyaWV2ZVwiLCBldmVudENsb25lKTtcbiAgICAgIGlmICghX19wcml2YXRlR2V0KHRoaXMsIF9pbnB1dDMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZlYXR1cmVDb2xsZWN0aW9uID0gZS5kZXRhaWw7XG4gICAgICBpZiAoIWZlYXR1cmVDb2xsZWN0aW9uIHx8ICFmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcyB8fCAhZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZpbGxGb3JtV2l0aEZlYXR1cmUoZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXNbMF0sIF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQzKSk7XG4gICAgfSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9pbnB1dDMsIGlucHV0KTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX2NvbGxlY3Rpb24sIGNvbGxlY3Rpb24pO1xuICAgIHRoaXMubGlzdGJveC5pbnB1dCA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfaW5wdXQzKTtcbiAgICB0aGlzLmxpc3Rib3guc2Vzc2lvbiA9IG5ldyBTZWFyY2hTZXNzaW9uMyhhdXRvZmlsbFJlZik7XG4gICAgdGhpcy5saXN0Ym94LnNlc3Npb24uc2Vzc2lvblRva2VuID0gY29uZmlnLmF1dG9maWxsU2Vzc2lvblRva2VuO1xuICAgIHRoaXMubGlzdGJveC5hZGRFdmVudExpc3RlbmVyKFwic3VnZ2VzdFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN1Z2dlc3Q0KSk7XG4gICAgdGhpcy5saXN0Ym94LmFkZEV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTdWdnZXN0RXJyb3I0KSk7XG4gICAgdGhpcy5saXN0Ym94LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXRyaWV2ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVJldHJpZXZlMykpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5saXN0Ym94KTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5saXN0Ym94LnJlbW92ZSgpO1xuICAgIHRoaXMubGlzdGJveC5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VnZ2VzdFwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVN1Z2dlc3Q0KSk7XG4gICAgdGhpcy5saXN0Ym94LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdWdnZXN0ZXJyb3JcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVTdWdnZXN0RXJyb3I0KSk7XG4gICAgdGhpcy5saXN0Ym94LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXRyaWV2ZVwiLCBfX3ByaXZhdGVHZXQodGhpcywgX2hhbmRsZVJldHJpZXZlMykpO1xuICB9XG59O1xuX2lucHV0MyA9IG5ldyBXZWFrTWFwKCk7XG5fY29sbGVjdGlvbiA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlU3VnZ2VzdDQgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVN1Z2dlc3RFcnJvcjQgPSBuZXcgV2Vha01hcCgpO1xuX2hhbmRsZVJldHJpZXZlMyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgX2N1cnJlbnRJbnB1dHMsIF9hdXRvZmlsbDIsIF9vcHRpb25zMiwgX3RoZW1lLCBfcG9wb3Zlck9wdGlvbnMyLCBfaGFuZGxlT2JzZXJ2ZTIsIF9vYnNlcnZlcjIsIF9oYW5kbGVCcm93c2VyQXV0b2ZpbGwyO1xudmFyIEF1dG9maWxsQ29sbGVjdGlvbiA9IGNsYXNzIGV4dGVuZHMgRXZlbnRlZCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBhY2Nlc3NUb2tlbixcbiAgICBvcHRpb25zLFxuICAgIHRoZW1lLFxuICAgIHBvcG92ZXJPcHRpb25zLFxuICAgIGNvbmZpcm1PbkJyb3dzZXJBdXRvZmlsbFxuICB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmluc3RhbmNlcyA9IFtdO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY3VycmVudElucHV0cywgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2F1dG9maWxsMiwgbmV3IE1hcGJveEF1dG9maWxsMigpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29wdGlvbnMyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfdGhlbWUsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wb3BvdmVyT3B0aW9uczIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb25maXJtT25Ccm93c2VyQXV0b2ZpbGwgPSBmYWxzZTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZU9ic2VydmUyLCAoKSA9PiB7XG4gICAgICBpZiAoIWRlZXBFcXVhbHMoZmluZEFkZHJlc3NJbnB1dHMoKSwgX19wcml2YXRlR2V0KHRoaXMsIF9jdXJyZW50SW5wdXRzKSkpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX29ic2VydmVyMiwgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVPYnNlcnZlMikpKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2hhbmRsZUJyb3dzZXJBdXRvZmlsbDIsIChlKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmluc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4gaW5zdGFuY2UubGlzdGJveC5ibHVyKCkpO1xuICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiB0aGlzLmluc3RhbmNlcykge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGluc3RhbmNlLmxpc3Rib3guaW5wdXQ7XG4gICAgICAgIHlpZWxkIHRyeUNvbmZpcm1Ccm93c2VyQXV0b2ZpbGwoaW5wdXQsIGUsIHRoaXMuY29uZmlybU9uQnJvd3NlckF1dG9maWxsLCB0aGlzLmFjY2Vzc1Rva2VuKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgaW5pdERldGVjdEJyb3dzZXJBdXRvZmlsbCgpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYnJvd3NlcmF1dG9maWxsXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaGFuZGxlQnJvd3NlckF1dG9maWxsMikpO1xuICAgIGNvbmZpZy5hdXRvZmlsbFNlc3Npb25FbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgY29uZmlnLmFjY2Vzc1Rva2VuO1xuICAgIG9wdGlvbnMgJiYgKHRoaXMub3B0aW9ucyA9IG9wdGlvbnMpO1xuICAgIHRoZW1lICYmICh0aGlzLnRoZW1lID0gdGhlbWUpO1xuICAgIHBvcG92ZXJPcHRpb25zICYmICh0aGlzLnBvcG92ZXJPcHRpb25zID0gcG9wb3Zlck9wdGlvbnMpO1xuICAgIGNvbmZpcm1PbkJyb3dzZXJBdXRvZmlsbCAmJiAodGhpcy5jb25maXJtT25Ccm93c2VyQXV0b2ZpbGwgPSBjb25maXJtT25Ccm93c2VyQXV0b2ZpbGwpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgZ2V0IGFjY2Vzc1Rva2VuKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2F1dG9maWxsMikuYWNjZXNzVG9rZW47XG4gIH1cbiAgc2V0IGFjY2Vzc1Rva2VuKG5ld1Rva2VuKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9hdXRvZmlsbDIpLmFjY2Vzc1Rva2VuID0gbmV3VG9rZW47XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfb3B0aW9uczIpO1xuICB9XG4gIHNldCBvcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX29wdGlvbnMyLCBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgX19wcml2YXRlR2V0KHRoaXMsIF9vcHRpb25zMikpLCBuZXdPcHRpb25zKSk7XG4gICAgdGhpcy5pbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICAgIGluc3RhbmNlLmxpc3Rib3gub3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBpbnN0YW5jZS5saXN0Ym94Lm9wdGlvbnMpLCBuZXdPcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBnZXQgdGhlbWUoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfdGhlbWUpO1xuICB9XG4gIHNldCB0aGVtZShuZXdUaGVtZSkge1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfdGhlbWUsIG5ld1RoZW1lKTtcbiAgICB0aGlzLmluc3RhbmNlcy5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgICAgaW5zdGFuY2UubGlzdGJveC50aGVtZSA9IG5ld1RoZW1lO1xuICAgIH0pO1xuICB9XG4gIGdldCBwb3BvdmVyT3B0aW9ucygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9wb3BvdmVyT3B0aW9uczIpO1xuICB9XG4gIHNldCBwb3BvdmVyT3B0aW9ucyhuZXdPcHRpb25zKSB7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9wb3BvdmVyT3B0aW9uczIsIG5ld09wdGlvbnMpO1xuICAgIHRoaXMuaW5zdGFuY2VzLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgICBpbnN0YW5jZS5saXN0Ym94LnBvcG92ZXJPcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICB9KTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5pbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICAgIGluc3RhbmNlLnJlbW92ZSgpO1xuICAgIH0pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY3VycmVudElucHV0cywgZmluZEFkZHJlc3NJbnB1dHMoKSk7XG4gICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2N1cnJlbnRJbnB1dHMpLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBjb25zdCBhdXRvZmlsbEluc3RhbmNlID0gbmV3IEF1dG9maWxsSW5zdGFuY2UodGhpcywgaW5wdXQsIF9fcHJpdmF0ZUdldCh0aGlzLCBfYXV0b2ZpbGwyKSk7XG4gICAgICBhdXRvZmlsbEluc3RhbmNlLmxpc3Rib3gub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGF1dG9maWxsSW5zdGFuY2UubGlzdGJveC50aGVtZSA9IHRoaXMudGhlbWU7XG4gICAgICBhdXRvZmlsbEluc3RhbmNlLmxpc3Rib3gucG9wb3Zlck9wdGlvbnMgPSB0aGlzLnBvcG92ZXJPcHRpb25zO1xuICAgICAgdGhpcy5pbnN0YW5jZXMucHVzaChhdXRvZmlsbEluc3RhbmNlKTtcbiAgICB9KTtcbiAgfVxuICBvYnNlcnZlKCkge1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfb2JzZXJ2ZXIyKS5vYnNlcnZlKGRvY3VtZW50LCB7XG4gICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgfSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVPYnNlcnZlMikuY2FsbCh0aGlzKTtcbiAgfVxuICB1bm9ic2VydmUoKSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9vYnNlcnZlcjIpLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5pbnN0YW5jZXMuZm9yRWFjaCgoaW5zdGFuY2UpID0+IHtcbiAgICAgIGluc3RhbmNlLnJlbW92ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMudW5vYnNlcnZlKCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJicm93c2VyYXV0b2ZpbGxcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9oYW5kbGVCcm93c2VyQXV0b2ZpbGwyKSk7XG4gIH1cbn07XG5fY3VycmVudElucHV0cyA9IG5ldyBXZWFrTWFwKCk7XG5fYXV0b2ZpbGwyID0gbmV3IFdlYWtNYXAoKTtcbl9vcHRpb25zMiA9IG5ldyBXZWFrTWFwKCk7XG5fdGhlbWUgPSBuZXcgV2Vha01hcCgpO1xuX3BvcG92ZXJPcHRpb25zMiA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlT2JzZXJ2ZTIgPSBuZXcgV2Vha01hcCgpO1xuX29ic2VydmVyMiA9IG5ldyBXZWFrTWFwKCk7XG5faGFuZGxlQnJvd3NlckF1dG9maWxsMiA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBhdXRvZmlsbChvcHRpb25zQXJnKSB7XG4gIHJldHVybiBuZXcgQXV0b2ZpbGxDb2xsZWN0aW9uKG9wdGlvbnNBcmcpO1xufVxuZXhwb3J0IHtcbiAgTWFwYm94QWRkcmVzc0F1dG9maWxsLFxuICBNYXBib3hBZGRyZXNzQ29uZmlybWF0aW9uLFxuICBNYXBib3hBZGRyZXNzTWluaW1hcCxcbiAgTWFwYm94SFRNTEV2ZW50LFxuICBNYXBib3hTZWFyY2hCb3gsXG4gIGF1dG9maWxsLFxuICBjb25maWcsXG4gIGNvbmZpcm1BZGRyZXNzLFxuICBnZXRBdXRvZmlsbFNlYXJjaFRleHQsXG4gIGdldEZvcm1BdXRvZmlsbFZhbHVlc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LWVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@mapbox/search-js-web/dist/index-esm.js\n"));

/***/ }),

/***/ "./node_modules/@mapbox/sphericalmercator/sphericalmercator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@mapbox/sphericalmercator/sphericalmercator.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var SphericalMercator = (function(){\n\n// Closures including constants and other precalculated values.\nvar cache = {},\n    EPSLN = 1.0e-10,\n    D2R = Math.PI / 180,\n    R2D = 180 / Math.PI,\n    // 900913 properties.\n    A = 6378137.0,\n    MAXEXTENT = 20037508.342789244;\n\nfunction isFloat(n){\n    return Number(n) === n && n % 1 !== 0;\n}\n\n// SphericalMercator constructor: precaches calculations\n// for fast tile lookups.\nfunction SphericalMercator(options) {\n    options = options || {};\n    this.size = options.size || 256;\n    this.expansion = (options.antimeridian === true) ? 2 : 1;\n    if (!cache[this.size]) {\n        var size = this.size;\n        var c = cache[this.size] = {};\n        c.Bc = [];\n        c.Cc = [];\n        c.zc = [];\n        c.Ac = [];\n        for (var d = 0; d < 30; d++) {\n            c.Bc.push(size / 360);\n            c.Cc.push(size / (2 * Math.PI));\n            c.zc.push(size / 2);\n            c.Ac.push(size);\n            size *= 2;\n        }\n    }\n    this.Bc = cache[this.size].Bc;\n    this.Cc = cache[this.size].Cc;\n    this.zc = cache[this.size].zc;\n    this.Ac = cache[this.size].Ac;\n};\n\n// Convert lon lat to screen pixel value\n//\n// - `ll` {Array} `[lon, lat]` array of geographic coordinates.\n// - `zoom` {Number} zoom level.\nSphericalMercator.prototype.px = function(ll, zoom) {\n  if (isFloat(zoom)) {\n    var size = this.size * Math.pow(2, zoom);\n    var d = size / 2;\n    var bc = (size / 360);\n    var cc = (size / (2 * Math.PI));\n    var ac = size;\n    var f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);\n    var x = d + ll[0] * bc;\n    var y = d + 0.5 * Math.log((1 + f) / (1 - f)) * -cc;\n    (x > ac * this.expansion) && (x = ac * this.expansion);\n    (y > ac) && (y = ac);\n    //(x < 0) && (x = 0);\n    //(y < 0) && (y = 0);\n    return [x, y];\n  } else {\n    var d = this.zc[zoom];\n    var f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);\n    var x = Math.round(d + ll[0] * this.Bc[zoom]);\n    var y = Math.round(d + 0.5 * Math.log((1 + f) / (1 - f)) * (-this.Cc[zoom]));\n    (x > this.Ac[zoom] * this.expansion) && (x = this.Ac[zoom] * this.expansion);\n    (y > this.Ac[zoom]) && (y = this.Ac[zoom]);\n    //(x < 0) && (x = 0);\n    //(y < 0) && (y = 0);\n    return [x, y];\n  }\n};\n\n// Convert screen pixel value to lon lat\n//\n// - `px` {Array} `[x, y]` array of geographic coordinates.\n// - `zoom` {Number} zoom level.\nSphericalMercator.prototype.ll = function(px, zoom) {\n  if (isFloat(zoom)) {\n    var size = this.size * Math.pow(2, zoom);\n    var bc = (size / 360);\n    var cc = (size / (2 * Math.PI));\n    var zc = size / 2;\n    var g = (px[1] - zc) / -cc;\n    var lon = (px[0] - zc) / bc;\n    var lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);\n    return [lon, lat];\n  } else {\n    var g = (px[1] - this.zc[zoom]) / (-this.Cc[zoom]);\n    var lon = (px[0] - this.zc[zoom]) / this.Bc[zoom];\n    var lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);\n    return [lon, lat];\n  }\n};\n\n// Convert tile xyz value to bbox of the form `[w, s, e, n]`\n//\n// - `x` {Number} x (longitude) number.\n// - `y` {Number} y (latitude) number.\n// - `zoom` {Number} zoom.\n// - `tms_style` {Boolean} whether to compute using tms-style.\n// - `srs` {String} projection for resulting bbox (WGS84|900913).\n// - `return` {Array} bbox array of values in form `[w, s, e, n]`.\nSphericalMercator.prototype.bbox = function(x, y, zoom, tms_style, srs) {\n    // Convert xyz into bbox with srs WGS84\n    if (tms_style) {\n        y = (Math.pow(2, zoom) - 1) - y;\n    }\n    // Use +y to make sure it's a number to avoid inadvertent concatenation.\n    var ll = [x * this.size, (+y + 1) * this.size]; // lower left\n    // Use +x to make sure it's a number to avoid inadvertent concatenation.\n    var ur = [(+x + 1) * this.size, y * this.size]; // upper right\n    var bbox = this.ll(ll, zoom).concat(this.ll(ur, zoom));\n\n    // If web mercator requested reproject to 900913.\n    if (srs === '900913') {\n        return this.convert(bbox, '900913');\n    } else {\n        return bbox;\n    }\n};\n\n// Convert bbox to xyx bounds\n//\n// - `bbox` {Number} bbox in the form `[w, s, e, n]`.\n// - `zoom` {Number} zoom.\n// - `tms_style` {Boolean} whether to compute using tms-style.\n// - `srs` {String} projection of input bbox (WGS84|900913).\n// - `@return` {Object} XYZ bounds containing minX, maxX, minY, maxY properties.\nSphericalMercator.prototype.xyz = function(bbox, zoom, tms_style, srs) {\n    // If web mercator provided reproject to WGS84.\n    if (srs === '900913') {\n        bbox = this.convert(bbox, 'WGS84');\n    }\n\n    var ll = [bbox[0], bbox[1]]; // lower left\n    var ur = [bbox[2], bbox[3]]; // upper right\n    var px_ll = this.px(ll, zoom);\n    var px_ur = this.px(ur, zoom);\n    // Y = 0 for XYZ is the top hence minY uses px_ur[1].\n    var x = [ Math.floor(px_ll[0] / this.size), Math.floor((px_ur[0] - 1) / this.size) ];\n    var y = [ Math.floor(px_ur[1] / this.size), Math.floor((px_ll[1] - 1) / this.size) ];\n    var bounds = {\n        minX: Math.min.apply(Math, x) < 0 ? 0 : Math.min.apply(Math, x),\n        minY: Math.min.apply(Math, y) < 0 ? 0 : Math.min.apply(Math, y),\n        maxX: Math.max.apply(Math, x),\n        maxY: Math.max.apply(Math, y)\n    };\n    if (tms_style) {\n        var tms = {\n            minY: (Math.pow(2, zoom) - 1) - bounds.maxY,\n            maxY: (Math.pow(2, zoom) - 1) - bounds.minY\n        };\n        bounds.minY = tms.minY;\n        bounds.maxY = tms.maxY;\n    }\n    return bounds;\n};\n\n// Convert projection of given bbox.\n//\n// - `bbox` {Number} bbox in the form `[w, s, e, n]`.\n// - `to` {String} projection of output bbox (WGS84|900913). Input bbox\n//   assumed to be the \"other\" projection.\n// - `@return` {Object} bbox with reprojected coordinates.\nSphericalMercator.prototype.convert = function(bbox, to) {\n    if (to === '900913') {\n        return this.forward(bbox.slice(0, 2)).concat(this.forward(bbox.slice(2,4)));\n    } else {\n        return this.inverse(bbox.slice(0, 2)).concat(this.inverse(bbox.slice(2,4)));\n    }\n};\n\n// Convert lon/lat values to 900913 x/y.\nSphericalMercator.prototype.forward = function(ll) {\n    var xy = [\n        A * ll[0] * D2R,\n        A * Math.log(Math.tan((Math.PI*0.25) + (0.5 * ll[1] * D2R)))\n    ];\n    // if xy value is beyond maxextent (e.g. poles), return maxextent.\n    (xy[0] > MAXEXTENT) && (xy[0] = MAXEXTENT);\n    (xy[0] < -MAXEXTENT) && (xy[0] = -MAXEXTENT);\n    (xy[1] > MAXEXTENT) && (xy[1] = MAXEXTENT);\n    (xy[1] < -MAXEXTENT) && (xy[1] = -MAXEXTENT);\n    return xy;\n};\n\n// Convert 900913 x/y values to lon/lat.\nSphericalMercator.prototype.inverse = function(xy) {\n    return [\n        (xy[0] * R2D / A),\n        ((Math.PI*0.5) - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D\n    ];\n};\n\nreturn SphericalMercator;\n\n})();\n\nif (true) {\n    module.exports = exports = SphericalMercator;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hcGJveC9zcGhlcmljYWxtZXJjYXRvci9zcGhlcmljYWxtZXJjYXRvci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsUUFBUTtBQUNsQixhQUFhLFFBQVE7QUFDckIsa0JBQWtCLFNBQVM7QUFDM0IsWUFBWSxRQUFRO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixrQkFBa0IsU0FBUztBQUMzQixZQUFZLFFBQVE7QUFDcEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRCxJQUFJLElBQStEO0FBQ25FO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BtYXBib3gvc3BoZXJpY2FsbWVyY2F0b3Ivc3BoZXJpY2FsbWVyY2F0b3IuanM/NDVmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSAoZnVuY3Rpb24oKXtcblxuLy8gQ2xvc3VyZXMgaW5jbHVkaW5nIGNvbnN0YW50cyBhbmQgb3RoZXIgcHJlY2FsY3VsYXRlZCB2YWx1ZXMuXG52YXIgY2FjaGUgPSB7fSxcbiAgICBFUFNMTiA9IDEuMGUtMTAsXG4gICAgRDJSID0gTWF0aC5QSSAvIDE4MCxcbiAgICBSMkQgPSAxODAgLyBNYXRoLlBJLFxuICAgIC8vIDkwMDkxMyBwcm9wZXJ0aWVzLlxuICAgIEEgPSA2Mzc4MTM3LjAsXG4gICAgTUFYRVhURU5UID0gMjAwMzc1MDguMzQyNzg5MjQ0O1xuXG5mdW5jdGlvbiBpc0Zsb2F0KG4pe1xuICAgIHJldHVybiBOdW1iZXIobikgPT09IG4gJiYgbiAlIDEgIT09IDA7XG59XG5cbi8vIFNwaGVyaWNhbE1lcmNhdG9yIGNvbnN0cnVjdG9yOiBwcmVjYWNoZXMgY2FsY3VsYXRpb25zXG4vLyBmb3IgZmFzdCB0aWxlIGxvb2t1cHMuXG5mdW5jdGlvbiBTcGhlcmljYWxNZXJjYXRvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5zaXplID0gb3B0aW9ucy5zaXplIHx8IDI1NjtcbiAgICB0aGlzLmV4cGFuc2lvbiA9IChvcHRpb25zLmFudGltZXJpZGlhbiA9PT0gdHJ1ZSkgPyAyIDogMTtcbiAgICBpZiAoIWNhY2hlW3RoaXMuc2l6ZV0pIHtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIHZhciBjID0gY2FjaGVbdGhpcy5zaXplXSA9IHt9O1xuICAgICAgICBjLkJjID0gW107XG4gICAgICAgIGMuQ2MgPSBbXTtcbiAgICAgICAgYy56YyA9IFtdO1xuICAgICAgICBjLkFjID0gW107XG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgMzA7IGQrKykge1xuICAgICAgICAgICAgYy5CYy5wdXNoKHNpemUgLyAzNjApO1xuICAgICAgICAgICAgYy5DYy5wdXNoKHNpemUgLyAoMiAqIE1hdGguUEkpKTtcbiAgICAgICAgICAgIGMuemMucHVzaChzaXplIC8gMik7XG4gICAgICAgICAgICBjLkFjLnB1c2goc2l6ZSk7XG4gICAgICAgICAgICBzaXplICo9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5CYyA9IGNhY2hlW3RoaXMuc2l6ZV0uQmM7XG4gICAgdGhpcy5DYyA9IGNhY2hlW3RoaXMuc2l6ZV0uQ2M7XG4gICAgdGhpcy56YyA9IGNhY2hlW3RoaXMuc2l6ZV0uemM7XG4gICAgdGhpcy5BYyA9IGNhY2hlW3RoaXMuc2l6ZV0uQWM7XG59O1xuXG4vLyBDb252ZXJ0IGxvbiBsYXQgdG8gc2NyZWVuIHBpeGVsIHZhbHVlXG4vL1xuLy8gLSBgbGxgIHtBcnJheX0gYFtsb24sIGxhdF1gIGFycmF5IG9mIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMuXG4vLyAtIGB6b29tYCB7TnVtYmVyfSB6b29tIGxldmVsLlxuU3BoZXJpY2FsTWVyY2F0b3IucHJvdG90eXBlLnB4ID0gZnVuY3Rpb24obGwsIHpvb20pIHtcbiAgaWYgKGlzRmxvYXQoem9vbSkpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSAqIE1hdGgucG93KDIsIHpvb20pO1xuICAgIHZhciBkID0gc2l6ZSAvIDI7XG4gICAgdmFyIGJjID0gKHNpemUgLyAzNjApO1xuICAgIHZhciBjYyA9IChzaXplIC8gKDIgKiBNYXRoLlBJKSk7XG4gICAgdmFyIGFjID0gc2l6ZTtcbiAgICB2YXIgZiA9IE1hdGgubWluKE1hdGgubWF4KE1hdGguc2luKEQyUiAqIGxsWzFdKSwgLTAuOTk5OSksIDAuOTk5OSk7XG4gICAgdmFyIHggPSBkICsgbGxbMF0gKiBiYztcbiAgICB2YXIgeSA9IGQgKyAwLjUgKiBNYXRoLmxvZygoMSArIGYpIC8gKDEgLSBmKSkgKiAtY2M7XG4gICAgKHggPiBhYyAqIHRoaXMuZXhwYW5zaW9uKSAmJiAoeCA9IGFjICogdGhpcy5leHBhbnNpb24pO1xuICAgICh5ID4gYWMpICYmICh5ID0gYWMpO1xuICAgIC8vKHggPCAwKSAmJiAoeCA9IDApO1xuICAgIC8vKHkgPCAwKSAmJiAoeSA9IDApO1xuICAgIHJldHVybiBbeCwgeV07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGQgPSB0aGlzLnpjW3pvb21dO1xuICAgIHZhciBmID0gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5zaW4oRDJSICogbGxbMV0pLCAtMC45OTk5KSwgMC45OTk5KTtcbiAgICB2YXIgeCA9IE1hdGgucm91bmQoZCArIGxsWzBdICogdGhpcy5CY1t6b29tXSk7XG4gICAgdmFyIHkgPSBNYXRoLnJvdW5kKGQgKyAwLjUgKiBNYXRoLmxvZygoMSArIGYpIC8gKDEgLSBmKSkgKiAoLXRoaXMuQ2Nbem9vbV0pKTtcbiAgICAoeCA+IHRoaXMuQWNbem9vbV0gKiB0aGlzLmV4cGFuc2lvbikgJiYgKHggPSB0aGlzLkFjW3pvb21dICogdGhpcy5leHBhbnNpb24pO1xuICAgICh5ID4gdGhpcy5BY1t6b29tXSkgJiYgKHkgPSB0aGlzLkFjW3pvb21dKTtcbiAgICAvLyh4IDwgMCkgJiYgKHggPSAwKTtcbiAgICAvLyh5IDwgMCkgJiYgKHkgPSAwKTtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG59O1xuXG4vLyBDb252ZXJ0IHNjcmVlbiBwaXhlbCB2YWx1ZSB0byBsb24gbGF0XG4vL1xuLy8gLSBgcHhgIHtBcnJheX0gYFt4LCB5XWAgYXJyYXkgb2YgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcy5cbi8vIC0gYHpvb21gIHtOdW1iZXJ9IHpvb20gbGV2ZWwuXG5TcGhlcmljYWxNZXJjYXRvci5wcm90b3R5cGUubGwgPSBmdW5jdGlvbihweCwgem9vbSkge1xuICBpZiAoaXNGbG9hdCh6b29tKSkge1xuICAgIHZhciBzaXplID0gdGhpcy5zaXplICogTWF0aC5wb3coMiwgem9vbSk7XG4gICAgdmFyIGJjID0gKHNpemUgLyAzNjApO1xuICAgIHZhciBjYyA9IChzaXplIC8gKDIgKiBNYXRoLlBJKSk7XG4gICAgdmFyIHpjID0gc2l6ZSAvIDI7XG4gICAgdmFyIGcgPSAocHhbMV0gLSB6YykgLyAtY2M7XG4gICAgdmFyIGxvbiA9IChweFswXSAtIHpjKSAvIGJjO1xuICAgIHZhciBsYXQgPSBSMkQgKiAoMiAqIE1hdGguYXRhbihNYXRoLmV4cChnKSkgLSAwLjUgKiBNYXRoLlBJKTtcbiAgICByZXR1cm4gW2xvbiwgbGF0XTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZyA9IChweFsxXSAtIHRoaXMuemNbem9vbV0pIC8gKC10aGlzLkNjW3pvb21dKTtcbiAgICB2YXIgbG9uID0gKHB4WzBdIC0gdGhpcy56Y1t6b29tXSkgLyB0aGlzLkJjW3pvb21dO1xuICAgIHZhciBsYXQgPSBSMkQgKiAoMiAqIE1hdGguYXRhbihNYXRoLmV4cChnKSkgLSAwLjUgKiBNYXRoLlBJKTtcbiAgICByZXR1cm4gW2xvbiwgbGF0XTtcbiAgfVxufTtcblxuLy8gQ29udmVydCB0aWxlIHh5eiB2YWx1ZSB0byBiYm94IG9mIHRoZSBmb3JtIGBbdywgcywgZSwgbl1gXG4vL1xuLy8gLSBgeGAge051bWJlcn0geCAobG9uZ2l0dWRlKSBudW1iZXIuXG4vLyAtIGB5YCB7TnVtYmVyfSB5IChsYXRpdHVkZSkgbnVtYmVyLlxuLy8gLSBgem9vbWAge051bWJlcn0gem9vbS5cbi8vIC0gYHRtc19zdHlsZWAge0Jvb2xlYW59IHdoZXRoZXIgdG8gY29tcHV0ZSB1c2luZyB0bXMtc3R5bGUuXG4vLyAtIGBzcnNgIHtTdHJpbmd9IHByb2plY3Rpb24gZm9yIHJlc3VsdGluZyBiYm94IChXR1M4NHw5MDA5MTMpLlxuLy8gLSBgcmV0dXJuYCB7QXJyYXl9IGJib3ggYXJyYXkgb2YgdmFsdWVzIGluIGZvcm0gYFt3LCBzLCBlLCBuXWAuXG5TcGhlcmljYWxNZXJjYXRvci5wcm90b3R5cGUuYmJveCA9IGZ1bmN0aW9uKHgsIHksIHpvb20sIHRtc19zdHlsZSwgc3JzKSB7XG4gICAgLy8gQ29udmVydCB4eXogaW50byBiYm94IHdpdGggc3JzIFdHUzg0XG4gICAgaWYgKHRtc19zdHlsZSkge1xuICAgICAgICB5ID0gKE1hdGgucG93KDIsIHpvb20pIC0gMSkgLSB5O1xuICAgIH1cbiAgICAvLyBVc2UgK3kgdG8gbWFrZSBzdXJlIGl0J3MgYSBudW1iZXIgdG8gYXZvaWQgaW5hZHZlcnRlbnQgY29uY2F0ZW5hdGlvbi5cbiAgICB2YXIgbGwgPSBbeCAqIHRoaXMuc2l6ZSwgKCt5ICsgMSkgKiB0aGlzLnNpemVdOyAvLyBsb3dlciBsZWZ0XG4gICAgLy8gVXNlICt4IHRvIG1ha2Ugc3VyZSBpdCdzIGEgbnVtYmVyIHRvIGF2b2lkIGluYWR2ZXJ0ZW50IGNvbmNhdGVuYXRpb24uXG4gICAgdmFyIHVyID0gWygreCArIDEpICogdGhpcy5zaXplLCB5ICogdGhpcy5zaXplXTsgLy8gdXBwZXIgcmlnaHRcbiAgICB2YXIgYmJveCA9IHRoaXMubGwobGwsIHpvb20pLmNvbmNhdCh0aGlzLmxsKHVyLCB6b29tKSk7XG5cbiAgICAvLyBJZiB3ZWIgbWVyY2F0b3IgcmVxdWVzdGVkIHJlcHJvamVjdCB0byA5MDA5MTMuXG4gICAgaWYgKHNycyA9PT0gJzkwMDkxMycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydChiYm94LCAnOTAwOTEzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfVxufTtcblxuLy8gQ29udmVydCBiYm94IHRvIHh5eCBib3VuZHNcbi8vXG4vLyAtIGBiYm94YCB7TnVtYmVyfSBiYm94IGluIHRoZSBmb3JtIGBbdywgcywgZSwgbl1gLlxuLy8gLSBgem9vbWAge051bWJlcn0gem9vbS5cbi8vIC0gYHRtc19zdHlsZWAge0Jvb2xlYW59IHdoZXRoZXIgdG8gY29tcHV0ZSB1c2luZyB0bXMtc3R5bGUuXG4vLyAtIGBzcnNgIHtTdHJpbmd9IHByb2plY3Rpb24gb2YgaW5wdXQgYmJveCAoV0dTODR8OTAwOTEzKS5cbi8vIC0gYEByZXR1cm5gIHtPYmplY3R9IFhZWiBib3VuZHMgY29udGFpbmluZyBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZIHByb3BlcnRpZXMuXG5TcGhlcmljYWxNZXJjYXRvci5wcm90b3R5cGUueHl6ID0gZnVuY3Rpb24oYmJveCwgem9vbSwgdG1zX3N0eWxlLCBzcnMpIHtcbiAgICAvLyBJZiB3ZWIgbWVyY2F0b3IgcHJvdmlkZWQgcmVwcm9qZWN0IHRvIFdHUzg0LlxuICAgIGlmIChzcnMgPT09ICc5MDA5MTMnKSB7XG4gICAgICAgIGJib3ggPSB0aGlzLmNvbnZlcnQoYmJveCwgJ1dHUzg0Jyk7XG4gICAgfVxuXG4gICAgdmFyIGxsID0gW2Jib3hbMF0sIGJib3hbMV1dOyAvLyBsb3dlciBsZWZ0XG4gICAgdmFyIHVyID0gW2Jib3hbMl0sIGJib3hbM11dOyAvLyB1cHBlciByaWdodFxuICAgIHZhciBweF9sbCA9IHRoaXMucHgobGwsIHpvb20pO1xuICAgIHZhciBweF91ciA9IHRoaXMucHgodXIsIHpvb20pO1xuICAgIC8vIFkgPSAwIGZvciBYWVogaXMgdGhlIHRvcCBoZW5jZSBtaW5ZIHVzZXMgcHhfdXJbMV0uXG4gICAgdmFyIHggPSBbIE1hdGguZmxvb3IocHhfbGxbMF0gLyB0aGlzLnNpemUpLCBNYXRoLmZsb29yKChweF91clswXSAtIDEpIC8gdGhpcy5zaXplKSBdO1xuICAgIHZhciB5ID0gWyBNYXRoLmZsb29yKHB4X3VyWzFdIC8gdGhpcy5zaXplKSwgTWF0aC5mbG9vcigocHhfbGxbMV0gLSAxKSAvIHRoaXMuc2l6ZSkgXTtcbiAgICB2YXIgYm91bmRzID0ge1xuICAgICAgICBtaW5YOiBNYXRoLm1pbi5hcHBseShNYXRoLCB4KSA8IDAgPyAwIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgeCksXG4gICAgICAgIG1pblk6IE1hdGgubWluLmFwcGx5KE1hdGgsIHkpIDwgMCA/IDAgOiBNYXRoLm1pbi5hcHBseShNYXRoLCB5KSxcbiAgICAgICAgbWF4WDogTWF0aC5tYXguYXBwbHkoTWF0aCwgeCksXG4gICAgICAgIG1heFk6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHkpXG4gICAgfTtcbiAgICBpZiAodG1zX3N0eWxlKSB7XG4gICAgICAgIHZhciB0bXMgPSB7XG4gICAgICAgICAgICBtaW5ZOiAoTWF0aC5wb3coMiwgem9vbSkgLSAxKSAtIGJvdW5kcy5tYXhZLFxuICAgICAgICAgICAgbWF4WTogKE1hdGgucG93KDIsIHpvb20pIC0gMSkgLSBib3VuZHMubWluWVxuICAgICAgICB9O1xuICAgICAgICBib3VuZHMubWluWSA9IHRtcy5taW5ZO1xuICAgICAgICBib3VuZHMubWF4WSA9IHRtcy5tYXhZO1xuICAgIH1cbiAgICByZXR1cm4gYm91bmRzO1xufTtcblxuLy8gQ29udmVydCBwcm9qZWN0aW9uIG9mIGdpdmVuIGJib3guXG4vL1xuLy8gLSBgYmJveGAge051bWJlcn0gYmJveCBpbiB0aGUgZm9ybSBgW3csIHMsIGUsIG5dYC5cbi8vIC0gYHRvYCB7U3RyaW5nfSBwcm9qZWN0aW9uIG9mIG91dHB1dCBiYm94IChXR1M4NHw5MDA5MTMpLiBJbnB1dCBiYm94XG4vLyAgIGFzc3VtZWQgdG8gYmUgdGhlIFwib3RoZXJcIiBwcm9qZWN0aW9uLlxuLy8gLSBgQHJldHVybmAge09iamVjdH0gYmJveCB3aXRoIHJlcHJvamVjdGVkIGNvb3JkaW5hdGVzLlxuU3BoZXJpY2FsTWVyY2F0b3IucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbihiYm94LCB0bykge1xuICAgIGlmICh0byA9PT0gJzkwMDkxMycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yd2FyZChiYm94LnNsaWNlKDAsIDIpKS5jb25jYXQodGhpcy5mb3J3YXJkKGJib3guc2xpY2UoMiw0KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludmVyc2UoYmJveC5zbGljZSgwLCAyKSkuY29uY2F0KHRoaXMuaW52ZXJzZShiYm94LnNsaWNlKDIsNCkpKTtcbiAgICB9XG59O1xuXG4vLyBDb252ZXJ0IGxvbi9sYXQgdmFsdWVzIHRvIDkwMDkxMyB4L3kuXG5TcGhlcmljYWxNZXJjYXRvci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uKGxsKSB7XG4gICAgdmFyIHh5ID0gW1xuICAgICAgICBBICogbGxbMF0gKiBEMlIsXG4gICAgICAgIEEgKiBNYXRoLmxvZyhNYXRoLnRhbigoTWF0aC5QSSowLjI1KSArICgwLjUgKiBsbFsxXSAqIEQyUikpKVxuICAgIF07XG4gICAgLy8gaWYgeHkgdmFsdWUgaXMgYmV5b25kIG1heGV4dGVudCAoZS5nLiBwb2xlcyksIHJldHVybiBtYXhleHRlbnQuXG4gICAgKHh5WzBdID4gTUFYRVhURU5UKSAmJiAoeHlbMF0gPSBNQVhFWFRFTlQpO1xuICAgICh4eVswXSA8IC1NQVhFWFRFTlQpICYmICh4eVswXSA9IC1NQVhFWFRFTlQpO1xuICAgICh4eVsxXSA+IE1BWEVYVEVOVCkgJiYgKHh5WzFdID0gTUFYRVhURU5UKTtcbiAgICAoeHlbMV0gPCAtTUFYRVhURU5UKSAmJiAoeHlbMV0gPSAtTUFYRVhURU5UKTtcbiAgICByZXR1cm4geHk7XG59O1xuXG4vLyBDb252ZXJ0IDkwMDkxMyB4L3kgdmFsdWVzIHRvIGxvbi9sYXQuXG5TcGhlcmljYWxNZXJjYXRvci5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uKHh5KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgKHh5WzBdICogUjJEIC8gQSksXG4gICAgICAgICgoTWF0aC5QSSowLjUpIC0gMi4wICogTWF0aC5hdGFuKE1hdGguZXhwKC14eVsxXSAvIEEpKSkgKiBSMkRcbiAgICBdO1xufTtcblxucmV0dXJuIFNwaGVyaWNhbE1lcmNhdG9yO1xuXG59KSgpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU3BoZXJpY2FsTWVyY2F0b3I7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@mapbox/sphericalmercator/sphericalmercator.js\n"));

/***/ }),

/***/ "./node_modules/focus-trap/dist/focus-trap.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/focus-trap/dist/focus-trap.esm.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createFocusTrap\": function() { return /* binding */ createFocusTrap; }\n/* harmony export */ });\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tabbable */ \"./node_modules/tabbable/dist/index.esm.js\");\n/*!\n* focus-trap 6.9.4\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar activeFocusTraps = function () {\n  var trapQueue = [];\n  return {\n    activateTrap: function activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n    deactivateTrap: function deactivateTrap(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n}();\n\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\n\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\nvar isTabEvent = function isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n}; // Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\n\n\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n  return idx;\n};\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\n\n\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\n\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true\n  }, userOptions);\n\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   firstTabbableNode: HTMLElement|null,\n    //   lastTabbableNode: HTMLElement|null,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n\n\n  var findContainerIndex = function findContainerIndex(element) {\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n          tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n\n\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n\n      optionValue = optionValue.apply(void 0, params);\n    }\n\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      } // else, empty string (invalid), null (invalid), 0 (invalid)\n\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n\n    return node;\n  };\n\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus'); // false explicitly indicates we want no initialFocus at all\n\n    if (node === false) {\n      return false;\n    }\n\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode; // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n\n    return node;\n  };\n\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.tabbable)(container, config.tabbableOptions); // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes\n\n      var focusableNodes = (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.focusable)(container, config.tabbableOptions);\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,\n        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,\n\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          // NOTE: If tabindex is positive (in order to manipulate the tab order separate\n          //  from the DOM order), this __will not work__ because the list of focusableNodes,\n          //  while it contains tabbable nodes, does not sort its nodes in any order other\n          //  than DOM order, because it can't: Where would you place focusable (but not\n          //  tabbable) nodes in that order? They have no order, because they aren't tabbale...\n          // Support for positive tabindex is already broken and hard to manage (possibly\n          //  not supportable, TBD), so this isn't going to make things worse than they\n          //  already are, and at least makes things better for the majority of cases where\n          //  tabindex is either 0/unset or negative.\n          // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375\n          var nodeIdx = focusableNodes.findIndex(function (n) {\n            return n === node;\n          });\n\n          if (nodeIdx < 0) {\n            return undefined;\n          }\n\n          if (forward) {\n            return focusableNodes.slice(nodeIdx + 1).find(function (n) {\n              return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(n, config.tabbableOptions);\n            });\n          }\n\n          return focusableNodes.slice(0, nodeIdx).reverse().find(function (n) {\n            return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(n, config.tabbableOptions);\n          });\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    }); // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n  };\n\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === doc.activeElement) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  }; // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n\n\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n\n    if (findContainerIndex(target) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions)\n      });\n      return;\n    } // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    } // otherwise, prevent the click\n\n\n    e.preventDefault();\n  }; // In case focus escapes the trap for some strange reason, pull it back in.\n\n\n  var checkFocusIn = function checkFocusIn(e) {\n    var target = getActualTarget(e);\n    var targetContained = findContainerIndex(target) >= 0; // In Firefox when you Tab out of an iframe the Document is briefly focused.\n\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  }; // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n\n\n  var checkTab = function checkTab(e) {\n    var target = getActualTarget(e);\n    updateTabbableNodes();\n    var destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back in to...\n        if (e.shiftKey) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (e.shiftKey) {\n        // REVERSE\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {\n          var firstTabbableNode = _ref2.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions) && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        }\n      } else {\n        // FORWARD\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var lastTabbableNode = _ref3.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions) && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = _destinationGroup.firstTabbableNode;\n        }\n      }\n    } else {\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    if (destinationNode) {\n      e.preventDefault();\n      tryFocus(destinationNode);\n    } // else, let the browser take care of [shift+]tab and move the focus\n\n  };\n\n  var checkKey = function checkKey(e) {\n    if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {\n      e.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  };\n\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n\n    if (findContainerIndex(target) >= 0) {\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }; //\n  // EVENT LISTENERS\n  //\n\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    } // There can be only one listening focus trap at a time\n\n\n    activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  }; //\n  // TRAP DEFINITION\n  //\n\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n\n    get paused() {\n      return state.paused;\n    },\n\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      if (onActivate) {\n        onActivate();\n      }\n\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n\n        addListeners();\n\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      activeFocusTraps.deactivateTrap(trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n\n      if (onDeactivate) {\n        onDeactivate();\n      }\n\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = true;\n      removeListeners();\n      return this;\n    },\n    unpause: function unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      return this;\n    }\n  }; // initialize container elements\n\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\n\n//# sourceMappingURL=focus-trap.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC9kaXN0L2ZvY3VzLXRyYXAuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDd0U7O0FBRXhFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxtREFBbUQ7QUFDdEQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUEsaUJBQWlCO0FBQ2pCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsR0FBRztBQUNoQjs7O0FBR0E7QUFDQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsUUFBUTtBQUN2Qiw4RUFBOEU7QUFDOUU7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLDhDQUE4QztBQUM3RCxrREFBa0Q7QUFDbEQsdURBQXVEO0FBQ3ZEO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxtR0FBbUcsZUFBZTtBQUNsSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw0RkFBNEY7O0FBRTVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFRLHFDQUFxQyxrRUFBa0U7QUFDekk7O0FBRUEsMkJBQTJCLG1EQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQyxtQkFBbUIsU0FBUyw4Q0FBOEM7QUFDMUU7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQVU7QUFDL0IsYUFBYTtBQUNiOztBQUVBO0FBQ0EsbUJBQW1CLG9EQUFVO0FBQzdCLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0Esd0RBQXdELHFEQUFXO0FBQ25FLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsNkVBQTZFLHFEQUFXLHFDQUFxQyxvREFBVTtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsNEVBQTRFLHFEQUFXLHFDQUFxQyxvREFBVTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZvY3VzLXRyYXAvZGlzdC9mb2N1cy10cmFwLmVzbS5qcz9jZjllIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuKiBmb2N1cy10cmFwIDYuOS40XG4qIEBsaWNlbnNlIE1JVCwgaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xuaW1wb3J0IHsgdGFiYmFibGUsIGZvY3VzYWJsZSwgaXNUYWJiYWJsZSwgaXNGb2N1c2FibGUgfSBmcm9tICd0YWJiYWJsZSc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbnZhciBhY3RpdmVGb2N1c1RyYXBzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhcFF1ZXVlID0gW107XG4gIHJldHVybiB7XG4gICAgYWN0aXZhdGVUcmFwOiBmdW5jdGlvbiBhY3RpdmF0ZVRyYXAodHJhcCkge1xuICAgICAgaWYgKHRyYXBRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBhY3RpdmVUcmFwID0gdHJhcFF1ZXVlW3RyYXBRdWV1ZS5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoYWN0aXZlVHJhcCAhPT0gdHJhcCkge1xuICAgICAgICAgIGFjdGl2ZVRyYXAucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdHJhcEluZGV4ID0gdHJhcFF1ZXVlLmluZGV4T2YodHJhcCk7XG5cbiAgICAgIGlmICh0cmFwSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRyYXBRdWV1ZS5wdXNoKHRyYXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbW92ZSB0aGlzIGV4aXN0aW5nIHRyYXAgdG8gdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuICAgICAgICB0cmFwUXVldWUuc3BsaWNlKHRyYXBJbmRleCwgMSk7XG4gICAgICAgIHRyYXBRdWV1ZS5wdXNoKHRyYXApO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVhY3RpdmF0ZVRyYXA6IGZ1bmN0aW9uIGRlYWN0aXZhdGVUcmFwKHRyYXApIHtcbiAgICAgIHZhciB0cmFwSW5kZXggPSB0cmFwUXVldWUuaW5kZXhPZih0cmFwKTtcblxuICAgICAgaWYgKHRyYXBJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdHJhcFF1ZXVlLnNwbGljZSh0cmFwSW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhcFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJhcFF1ZXVlW3RyYXBRdWV1ZS5sZW5ndGggLSAxXS51bnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSgpO1xuXG52YXIgaXNTZWxlY3RhYmxlSW5wdXQgPSBmdW5jdGlvbiBpc1NlbGVjdGFibGVJbnB1dChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgdHlwZW9mIG5vZGUuc2VsZWN0ID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGlzRXNjYXBlRXZlbnQgPSBmdW5jdGlvbiBpc0VzY2FwZUV2ZW50KGUpIHtcbiAgcmV0dXJuIGUua2V5ID09PSAnRXNjYXBlJyB8fCBlLmtleSA9PT0gJ0VzYycgfHwgZS5rZXlDb2RlID09PSAyNztcbn07XG5cbnZhciBpc1RhYkV2ZW50ID0gZnVuY3Rpb24gaXNUYWJFdmVudChlKSB7XG4gIHJldHVybiBlLmtleSA9PT0gJ1RhYicgfHwgZS5rZXlDb2RlID09PSA5O1xufTtcblxudmFyIGRlbGF5ID0gZnVuY3Rpb24gZGVsYXkoZm4pIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZm4sIDApO1xufTsgLy8gQXJyYXkuZmluZC9maW5kSW5kZXgoKSBhcmUgbm90IHN1cHBvcnRlZCBvbiBJRTsgdGhpcyByZXBsaWNhdGVzIGVub3VnaFxuLy8gIG9mIEFycmF5LmZpbmRJbmRleCgpIGZvciBvdXIgbmVlZHNcblxuXG52YXIgZmluZEluZGV4ID0gZnVuY3Rpb24gZmluZEluZGV4KGFyciwgZm4pIHtcbiAgdmFyIGlkeCA9IC0xO1xuICBhcnIuZXZlcnkoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgaWYgKGZuKHZhbHVlKSkge1xuICAgICAgaWR4ID0gaTtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gYnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTsgLy8gbmV4dFxuICB9KTtcbiAgcmV0dXJuIGlkeDtcbn07XG4vKipcbiAqIEdldCBhbiBvcHRpb24ncyB2YWx1ZSB3aGVuIGl0IGNvdWxkIGJlIGEgcGxhaW4gdmFsdWUsIG9yIGEgaGFuZGxlciB0aGF0IHByb3ZpZGVzXG4gKiAgdGhlIHZhbHVlLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBPcHRpb24ncyB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7Li4uKn0gW3BhcmFtc10gQW55IHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgaGFuZGxlciwgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICogQHJldHVybnMgeyp9IFRoZSBgdmFsdWVgLCBvciB0aGUgaGFuZGxlcidzIHJldHVybmVkIHZhbHVlLlxuICovXG5cblxudmFyIHZhbHVlT3JIYW5kbGVyID0gZnVuY3Rpb24gdmFsdWVPckhhbmRsZXIodmFsdWUpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS5hcHBseSh2b2lkIDAsIHBhcmFtcykgOiB2YWx1ZTtcbn07XG5cbnZhciBnZXRBY3R1YWxUYXJnZXQgPSBmdW5jdGlvbiBnZXRBY3R1YWxUYXJnZXQoZXZlbnQpIHtcbiAgLy8gTk9URTogSWYgdGhlIHRyYXAgaXMgX2luc2lkZV8gYSBzaGFkb3cgRE9NLCBldmVudC50YXJnZXQgd2lsbCBhbHdheXMgYmUgdGhlXG4gIC8vICBzaGFkb3cgaG9zdC4gSG93ZXZlciwgZXZlbnQudGFyZ2V0LmNvbXBvc2VkUGF0aCgpIHdpbGwgYmUgYW4gYXJyYXkgb2ZcbiAgLy8gIG5vZGVzIFwiY2xpY2tlZFwiIGZyb20gaW5uZXItbW9zdCAodGhlIGFjdHVhbCBlbGVtZW50IGluc2lkZSB0aGUgc2hhZG93KSB0b1xuICAvLyAgb3V0ZXItbW9zdCAodGhlIGhvc3QgSFRNTCBkb2N1bWVudCkuIElmIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2VkUGF0aCgpLFxuICAvLyAgdGhlbiB1c2UgaXRzIGZpcnN0IGVsZW1lbnQ7IG90aGVyd2lzZSwgZmFsbCBiYWNrIHRvIGV2ZW50LnRhcmdldCAoYW5kXG4gIC8vICB0aGlzIG9ubHkgd29ya3MgZm9yIGFuIF9vcGVuXyBzaGFkb3cgRE9NOyBvdGhlcndpc2UsXG4gIC8vICBjb21wb3NlZFBhdGgoKVswXSA9PT0gZXZlbnQudGFyZ2V0IGFsd2F5cykuXG4gIHJldHVybiBldmVudC50YXJnZXQuc2hhZG93Um9vdCAmJiB0eXBlb2YgZXZlbnQuY29tcG9zZWRQYXRoID09PSAnZnVuY3Rpb24nID8gZXZlbnQuY29tcG9zZWRQYXRoKClbMF0gOiBldmVudC50YXJnZXQ7XG59O1xuXG52YXIgY3JlYXRlRm9jdXNUcmFwID0gZnVuY3Rpb24gY3JlYXRlRm9jdXNUcmFwKGVsZW1lbnRzLCB1c2VyT3B0aW9ucykge1xuICAvLyBTU1I6IGEgbGl2ZSB0cmFwIHNob3VsZG4ndCBiZSBjcmVhdGVkIGluIHRoaXMgdHlwZSBvZiBlbnZpcm9ubWVudCBzbyB0aGlzXG4gIC8vICBzaG91bGQgYmUgc2FmZSBjb2RlIHRvIGV4ZWN1dGUgaWYgdGhlIGBkb2N1bWVudGAgb3B0aW9uIGlzbid0IHNwZWNpZmllZFxuICB2YXIgZG9jID0gKHVzZXJPcHRpb25zID09PSBudWxsIHx8IHVzZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyT3B0aW9ucy5kb2N1bWVudCkgfHwgZG9jdW1lbnQ7XG5cbiAgdmFyIGNvbmZpZyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTogdHJ1ZSxcbiAgICBlc2NhcGVEZWFjdGl2YXRlczogdHJ1ZSxcbiAgICBkZWxheUluaXRpYWxGb2N1czogdHJ1ZVxuICB9LCB1c2VyT3B0aW9ucyk7XG5cbiAgdmFyIHN0YXRlID0ge1xuICAgIC8vIGNvbnRhaW5lcnMgZ2l2ZW4gdG8gY3JlYXRlRm9jdXNUcmFwKClcbiAgICAvLyBAdHlwZSB7QXJyYXk8SFRNTEVsZW1lbnQ+fVxuICAgIGNvbnRhaW5lcnM6IFtdLFxuICAgIC8vIGxpc3Qgb2Ygb2JqZWN0cyBpZGVudGlmeWluZyB0YWJiYWJsZSBub2RlcyBpbiBgY29udGFpbmVyc2AgaW4gdGhlIHRyYXBcbiAgICAvLyBOT1RFOiBpdCdzIHBvc3NpYmxlIHRoYXQgYSBncm91cCBoYXMgbm8gdGFiYmFibGUgbm9kZXMgaWYgbm9kZXMgZ2V0IHJlbW92ZWQgd2hpbGUgdGhlIHRyYXBcbiAgICAvLyAgaXMgYWN0aXZlLCBidXQgdGhlIHRyYXAgc2hvdWxkIG5ldmVyIGdldCB0byBhIHN0YXRlIHdoZXJlIHRoZXJlIGlzbid0IGF0IGxlYXN0IG9uZSBncm91cFxuICAgIC8vICB3aXRoIGF0IGxlYXN0IG9uZSB0YWJiYWJsZSBub2RlIGluIGl0ICh0aGF0IHdvdWxkIGxlYWQgdG8gYW4gZXJyb3IgY29uZGl0aW9uIHRoYXQgd291bGRcbiAgICAvLyAgcmVzdWx0IGluIGFuIGVycm9yIGJlaW5nIHRocm93bilcbiAgICAvLyBAdHlwZSB7QXJyYXk8e1xuICAgIC8vICAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgICAvLyAgIHRhYmJhYmxlTm9kZXM6IEFycmF5PEhUTUxFbGVtZW50PiwgLy8gZW1wdHkgaWYgbm9uZVxuICAgIC8vICAgZm9jdXNhYmxlTm9kZXM6IEFycmF5PEhUTUxFbGVtZW50PiwgLy8gZW1wdHkgaWYgbm9uZVxuICAgIC8vICAgZmlyc3RUYWJiYWJsZU5vZGU6IEhUTUxFbGVtZW50fG51bGwsXG4gICAgLy8gICBsYXN0VGFiYmFibGVOb2RlOiBIVE1MRWxlbWVudHxudWxsLFxuICAgIC8vICAgbmV4dFRhYmJhYmxlTm9kZTogKG5vZGU6IEhUTUxFbGVtZW50LCBmb3J3YXJkOiBib29sZWFuKSA9PiBIVE1MRWxlbWVudHx1bmRlZmluZWRcbiAgICAvLyB9Pn1cbiAgICBjb250YWluZXJHcm91cHM6IFtdLFxuICAgIC8vIHNhbWUgb3JkZXIvbGVuZ3RoIGFzIGBjb250YWluZXJzYCBsaXN0XG4gICAgLy8gcmVmZXJlbmNlcyB0byBvYmplY3RzIGluIGBjb250YWluZXJHcm91cHNgLCBidXQgb25seSB0aG9zZSB0aGF0IGFjdHVhbGx5IGhhdmVcbiAgICAvLyAgdGFiYmFibGUgbm9kZXMgaW4gdGhlbVxuICAgIC8vIE5PVEU6IHNhbWUgb3JkZXIgYXMgYGNvbnRhaW5lcnNgIGFuZCBgY29udGFpbmVyR3JvdXBzYCwgYnV0IF9fbm90IG5lY2Vzc2FyaWx5X19cbiAgICAvLyAgdGhlIHNhbWUgbGVuZ3RoXG4gICAgdGFiYmFibGVHcm91cHM6IFtdLFxuICAgIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbjogbnVsbCxcbiAgICBtb3N0UmVjZW50bHlGb2N1c2VkTm9kZTogbnVsbCxcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIHBhdXNlZDogZmFsc2UsXG4gICAgLy8gdGltZXIgSUQgZm9yIHdoZW4gZGVsYXlJbml0aWFsRm9jdXMgaXMgdHJ1ZSBhbmQgaW5pdGlhbCBmb2N1cyBpbiB0aGlzIHRyYXBcbiAgICAvLyAgaGFzIGJlZW4gZGVsYXllZCBkdXJpbmcgYWN0aXZhdGlvblxuICAgIGRlbGF5SW5pdGlhbEZvY3VzVGltZXI6IHVuZGVmaW5lZFxuICB9O1xuICB2YXIgdHJhcDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItY29uc3QgLS0gc29tZSBwcml2YXRlIGZ1bmN0aW9ucyByZWZlcmVuY2UgaXQsIGFuZCBpdHMgbWV0aG9kcyByZWZlcmVuY2UgcHJpdmF0ZSBmdW5jdGlvbnMsIHNvIHdlIG11c3QgZGVjbGFyZSBoZXJlIGFuZCBkZWZpbmUgbGF0ZXJcblxuICAvKipcbiAgICogR2V0cyBhIGNvbmZpZ3VyYXRpb24gb3B0aW9uIHZhbHVlLlxuICAgKiBAcGFyYW0ge09iamVjdHx1bmRlZmluZWR9IGNvbmZpZ092ZXJyaWRlT3B0aW9ucyBJZiB0cnVlLCBhbmQgb3B0aW9uIGlzIGRlZmluZWQgaW4gdGhpcyBzZXQsXG4gICAqICB2YWx1ZSB3aWxsIGJlIHRha2VuIGZyb20gdGhpcyBvYmplY3QuIE90aGVyd2lzZSwgdmFsdWUgd2lsbCBiZSB0YWtlbiBmcm9tIGJhc2UgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbk5hbWUgTmFtZSBvZiB0aGUgb3B0aW9uIHdob3NlIHZhbHVlIGlzIHNvdWdodC5cbiAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBbY29uZmlnT3B0aW9uTmFtZV0gTmFtZSBvZiBvcHRpb24gdG8gdXNlIF9faW5zdGVhZCBvZl9fIGBvcHRpb25OYW1lYFxuICAgKiAgSUlGIGBjb25maWdPdmVycmlkZU9wdGlvbnNgIGlzIG5vdCBkZWZpbmVkLiBPdGhlcndpc2UsIGBvcHRpb25OYW1lYCBpcyB1c2VkLlxuICAgKi9cblxuICB2YXIgZ2V0T3B0aW9uID0gZnVuY3Rpb24gZ2V0T3B0aW9uKGNvbmZpZ092ZXJyaWRlT3B0aW9ucywgb3B0aW9uTmFtZSwgY29uZmlnT3B0aW9uTmFtZSkge1xuICAgIHJldHVybiBjb25maWdPdmVycmlkZU9wdGlvbnMgJiYgY29uZmlnT3ZlcnJpZGVPcHRpb25zW29wdGlvbk5hbWVdICE9PSB1bmRlZmluZWQgPyBjb25maWdPdmVycmlkZU9wdGlvbnNbb3B0aW9uTmFtZV0gOiBjb25maWdbY29uZmlnT3B0aW9uTmFtZSB8fCBvcHRpb25OYW1lXTtcbiAgfTtcbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgY29udGFpbmVyIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybnMge251bWJlcn0gSW5kZXggb2YgdGhlIGNvbnRhaW5lciBpbiBlaXRoZXIgYHN0YXRlLmNvbnRhaW5lcnNgIG9yXG4gICAqICBgc3RhdGUuY29udGFpbmVyR3JvdXBzYCAodGhlIG9yZGVyL2xlbmd0aCBvZiB0aGVzZSBsaXN0cyBhcmUgdGhlIHNhbWUpOyAtMVxuICAgKiAgaWYgdGhlIGVsZW1lbnQgaXNuJ3QgZm91bmQuXG4gICAqL1xuXG5cbiAgdmFyIGZpbmRDb250YWluZXJJbmRleCA9IGZ1bmN0aW9uIGZpbmRDb250YWluZXJJbmRleChlbGVtZW50KSB7XG4gICAgLy8gTk9URTogc2VhcmNoIGBjb250YWluZXJHcm91cHNgIGJlY2F1c2UgaXQncyBwb3NzaWJsZSBhIGdyb3VwIGNvbnRhaW5zIG5vIHRhYmJhYmxlXG4gICAgLy8gIG5vZGVzLCBidXQgc3RpbGwgY29udGFpbnMgZm9jdXNhYmxlIG5vZGVzIChlLmcuIGlmIHRoZXkgYWxsIGhhdmUgYHRhYmluZGV4PS0xYClcbiAgICAvLyAgYW5kIHdlIHN0aWxsIG5lZWQgdG8gZmluZCB0aGUgZWxlbWVudCBpbiB0aGVyZVxuICAgIHJldHVybiBzdGF0ZS5jb250YWluZXJHcm91cHMuZmluZEluZGV4KGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gX3JlZi5jb250YWluZXIsXG4gICAgICAgICAgdGFiYmFibGVOb2RlcyA9IF9yZWYudGFiYmFibGVOb2RlcztcbiAgICAgIHJldHVybiBjb250YWluZXIuY29udGFpbnMoZWxlbWVudCkgfHwgLy8gZmFsbCBiYWNrIHRvIGV4cGxpY2l0IHRhYmJhYmxlIHNlYXJjaCB3aGljaCB3aWxsIHRha2UgaW50byBjb25zaWRlcmF0aW9uIGFueVxuICAgICAgLy8gIHdlYiBjb21wb25lbnRzIGlmIHRoZSBgdGFiYmFibGVPcHRpb25zLmdldFNoYWRvd1Jvb3RgIG9wdGlvbiB3YXMgdXNlZCBmb3JcbiAgICAgIC8vICB0aGUgdHJhcCwgZW5hYmxpbmcgc2hhZG93IERPTSBzdXBwb3J0IGluIHRhYmJhYmxlIChgTm9kZS5jb250YWlucygpYCBkb2Vzbid0XG4gICAgICAvLyAgbG9vayBpbnNpZGUgd2ViIGNvbXBvbmVudHMgZXZlbiBpZiBvcGVuKVxuICAgICAgdGFiYmFibGVOb2Rlcy5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlID09PSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBub2RlIGZvciB0aGUgZ2l2ZW4gb3B0aW9uLCB3aGljaCBpcyBleHBlY3RlZCB0byBiZSBhbiBvcHRpb24gdGhhdFxuICAgKiAgY2FuIGJlIGVpdGhlciBhIERPTSBub2RlLCBhIHN0cmluZyB0aGF0IGlzIGEgc2VsZWN0b3IgdG8gZ2V0IGEgbm9kZSwgYGZhbHNlYFxuICAgKiAgKGlmIGEgbm9kZSBpcyBleHBsaWNpdGx5IE5PVCBnaXZlbiksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFueSBvZiB0aGVzZVxuICAgKiAgdmFsdWVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uTmFtZVxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkIHwgZmFsc2UgfCBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IFJldHVybnNcbiAgICogIGB1bmRlZmluZWRgIGlmIHRoZSBvcHRpb24gaXMgbm90IHNwZWNpZmllZDsgYGZhbHNlYCBpZiB0aGUgb3B0aW9uXG4gICAqICByZXNvbHZlZCB0byBgZmFsc2VgIChub2RlIGV4cGxpY2l0bHkgbm90IGdpdmVuKTsgb3RoZXJ3aXNlLCB0aGUgcmVzb2x2ZWRcbiAgICogIERPTSBub2RlLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG9wdGlvbiBpcyBzZXQsIG5vdCBgZmFsc2VgLCBhbmQgaXMgbm90LCBvciBkb2VzIG5vdFxuICAgKiAgcmVzb2x2ZSB0byBhIG5vZGUuXG4gICAqL1xuXG5cbiAgdmFyIGdldE5vZGVGb3JPcHRpb24gPSBmdW5jdGlvbiBnZXROb2RlRm9yT3B0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICB2YXIgb3B0aW9uVmFsdWUgPSBjb25maWdbb3B0aW9uTmFtZV07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHBhcmFtc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9uVmFsdWUgPSBvcHRpb25WYWx1ZS5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvblZhbHVlID09PSB0cnVlKSB7XG4gICAgICBvcHRpb25WYWx1ZSA9IHVuZGVmaW5lZDsgLy8gdXNlIGRlZmF1bHQgdmFsdWVcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvblZhbHVlKSB7XG4gICAgICBpZiAob3B0aW9uVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvblZhbHVlO1xuICAgICAgfSAvLyBlbHNlLCBlbXB0eSBzdHJpbmcgKGludmFsaWQpLCBudWxsIChpbnZhbGlkKSwgMCAoaW52YWxpZClcblxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiYCB3YXMgc3BlY2lmaWVkIGJ1dCB3YXMgbm90IGEgbm9kZSwgb3IgZGlkIG5vdCByZXR1cm4gYSBub2RlXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IG9wdGlvblZhbHVlOyAvLyBjb3VsZCBiZSBIVE1MRWxlbWVudCwgU1ZHRWxlbWVudCwgb3Igbm9uLWVtcHR5IHN0cmluZyBhdCB0aGlzIHBvaW50XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgbm9kZSA9IGRvYy5xdWVyeVNlbGVjdG9yKG9wdGlvblZhbHVlKTsgLy8gcmVzb2x2ZSB0byBub2RlLCBvciBudWxsIGlmIGZhaWxzXG5cbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiYCBhcyBzZWxlY3RvciByZWZlcnMgdG8gbm8ga25vd24gbm9kZVwiKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgdmFyIGdldEluaXRpYWxGb2N1c05vZGUgPSBmdW5jdGlvbiBnZXRJbml0aWFsRm9jdXNOb2RlKCkge1xuICAgIHZhciBub2RlID0gZ2V0Tm9kZUZvck9wdGlvbignaW5pdGlhbEZvY3VzJyk7IC8vIGZhbHNlIGV4cGxpY2l0bHkgaW5kaWNhdGVzIHdlIHdhbnQgbm8gaW5pdGlhbEZvY3VzIGF0IGFsbFxuXG4gICAgaWYgKG5vZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gb3B0aW9uIG5vdCBzcGVjaWZpZWQ6IHVzZSBmYWxsYmFjayBvcHRpb25zXG4gICAgICBpZiAoZmluZENvbnRhaW5lckluZGV4KGRvYy5hY3RpdmVFbGVtZW50KSA+PSAwKSB7XG4gICAgICAgIG5vZGUgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmaXJzdFRhYmJhYmxlR3JvdXAgPSBzdGF0ZS50YWJiYWJsZUdyb3Vwc1swXTtcbiAgICAgICAgdmFyIGZpcnN0VGFiYmFibGVOb2RlID0gZmlyc3RUYWJiYWJsZUdyb3VwICYmIGZpcnN0VGFiYmFibGVHcm91cC5maXJzdFRhYmJhYmxlTm9kZTsgLy8gTk9URTogYGZhbGxiYWNrRm9jdXNgIG9wdGlvbiBmdW5jdGlvbiBjYW5ub3QgcmV0dXJuIGBmYWxzZWAgKG5vdCBzdXBwb3J0ZWQpXG5cbiAgICAgICAgbm9kZSA9IGZpcnN0VGFiYmFibGVOb2RlIHx8IGdldE5vZGVGb3JPcHRpb24oJ2ZhbGxiYWNrRm9jdXMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBmb2N1cy10cmFwIG5lZWRzIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGZvY3VzYWJsZSBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVRhYmJhYmxlTm9kZXMgPSBmdW5jdGlvbiB1cGRhdGVUYWJiYWJsZU5vZGVzKCkge1xuICAgIHN0YXRlLmNvbnRhaW5lckdyb3VwcyA9IHN0YXRlLmNvbnRhaW5lcnMubWFwKGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIHZhciB0YWJiYWJsZU5vZGVzID0gdGFiYmFibGUoY29udGFpbmVyLCBjb25maWcudGFiYmFibGVPcHRpb25zKTsgLy8gTk9URTogaWYgd2UgaGF2ZSB0YWJiYWJsZSBub2Rlcywgd2UgbXVzdCBoYXZlIGZvY3VzYWJsZSBub2RlczsgZm9jdXNhYmxlIG5vZGVzXG4gICAgICAvLyAgYXJlIGEgc3VwZXJzZXQgb2YgdGFiYmFibGUgbm9kZXNcblxuICAgICAgdmFyIGZvY3VzYWJsZU5vZGVzID0gZm9jdXNhYmxlKGNvbnRhaW5lciwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgdGFiYmFibGVOb2RlczogdGFiYmFibGVOb2RlcyxcbiAgICAgICAgZm9jdXNhYmxlTm9kZXM6IGZvY3VzYWJsZU5vZGVzLFxuICAgICAgICBmaXJzdFRhYmJhYmxlTm9kZTogdGFiYmFibGVOb2Rlcy5sZW5ndGggPiAwID8gdGFiYmFibGVOb2Rlc1swXSA6IG51bGwsXG4gICAgICAgIGxhc3RUYWJiYWJsZU5vZGU6IHRhYmJhYmxlTm9kZXMubGVuZ3RoID4gMCA/IHRhYmJhYmxlTm9kZXNbdGFiYmFibGVOb2Rlcy5sZW5ndGggLSAxXSA6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmRzIHRoZSBfX3RhYmJhYmxlX18gbm9kZSB0aGF0IGZvbGxvd3MgdGhlIGdpdmVuIG5vZGUgaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24sXG4gICAgICAgICAqICBpbiB0aGlzIGNvbnRhaW5lciwgaWYgYW55LlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcndhcmRdIFRydWUgaWYgZ29pbmcgaW4gZm9yd2FyZCB0YWIgb3JkZXI7IGZhbHNlIGlmIGdvaW5nXG4gICAgICAgICAqICBpbiByZXZlcnNlLlxuICAgICAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8dW5kZWZpbmVkfSBUaGUgbmV4dCB0YWJiYWJsZSBub2RlLCBpZiBhbnkuXG4gICAgICAgICAqL1xuICAgICAgICBuZXh0VGFiYmFibGVOb2RlOiBmdW5jdGlvbiBuZXh0VGFiYmFibGVOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgZm9yd2FyZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgICAgICAvLyBOT1RFOiBJZiB0YWJpbmRleCBpcyBwb3NpdGl2ZSAoaW4gb3JkZXIgdG8gbWFuaXB1bGF0ZSB0aGUgdGFiIG9yZGVyIHNlcGFyYXRlXG4gICAgICAgICAgLy8gIGZyb20gdGhlIERPTSBvcmRlciksIHRoaXMgX193aWxsIG5vdCB3b3JrX18gYmVjYXVzZSB0aGUgbGlzdCBvZiBmb2N1c2FibGVOb2RlcyxcbiAgICAgICAgICAvLyAgd2hpbGUgaXQgY29udGFpbnMgdGFiYmFibGUgbm9kZXMsIGRvZXMgbm90IHNvcnQgaXRzIG5vZGVzIGluIGFueSBvcmRlciBvdGhlclxuICAgICAgICAgIC8vICB0aGFuIERPTSBvcmRlciwgYmVjYXVzZSBpdCBjYW4ndDogV2hlcmUgd291bGQgeW91IHBsYWNlIGZvY3VzYWJsZSAoYnV0IG5vdFxuICAgICAgICAgIC8vICB0YWJiYWJsZSkgbm9kZXMgaW4gdGhhdCBvcmRlcj8gVGhleSBoYXZlIG5vIG9yZGVyLCBiZWNhdXNlIHRoZXkgYXJlbid0IHRhYmJhbGUuLi5cbiAgICAgICAgICAvLyBTdXBwb3J0IGZvciBwb3NpdGl2ZSB0YWJpbmRleCBpcyBhbHJlYWR5IGJyb2tlbiBhbmQgaGFyZCB0byBtYW5hZ2UgKHBvc3NpYmx5XG4gICAgICAgICAgLy8gIG5vdCBzdXBwb3J0YWJsZSwgVEJEKSwgc28gdGhpcyBpc24ndCBnb2luZyB0byBtYWtlIHRoaW5ncyB3b3JzZSB0aGFuIHRoZXlcbiAgICAgICAgICAvLyAgYWxyZWFkeSBhcmUsIGFuZCBhdCBsZWFzdCBtYWtlcyB0aGluZ3MgYmV0dGVyIGZvciB0aGUgbWFqb3JpdHkgb2YgY2FzZXMgd2hlcmVcbiAgICAgICAgICAvLyAgdGFiaW5kZXggaXMgZWl0aGVyIDAvdW5zZXQgb3IgbmVnYXRpdmUuXG4gICAgICAgICAgLy8gRllJLCBwb3NpdGl2ZSB0YWJpbmRleCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC9pc3N1ZXMvMzc1XG4gICAgICAgICAgdmFyIG5vZGVJZHggPSBmb2N1c2FibGVOb2Rlcy5maW5kSW5kZXgoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBuID09PSBub2RlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKG5vZGVJZHggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9jdXNhYmxlTm9kZXMuc2xpY2Uobm9kZUlkeCArIDEpLmZpbmQoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzVGFiYmFibGUobiwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZm9jdXNhYmxlTm9kZXMuc2xpY2UoMCwgbm9kZUlkeCkucmV2ZXJzZSgpLmZpbmQoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBpc1RhYmJhYmxlKG4sIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHN0YXRlLnRhYmJhYmxlR3JvdXBzID0gc3RhdGUuY29udGFpbmVyR3JvdXBzLmZpbHRlcihmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgIHJldHVybiBncm91cC50YWJiYWJsZU5vZGVzLmxlbmd0aCA+IDA7XG4gICAgfSk7IC8vIHRocm93IGlmIG5vIGdyb3VwcyBoYXZlIHRhYmJhYmxlIG5vZGVzIGFuZCB3ZSBkb24ndCBoYXZlIGEgZmFsbGJhY2sgZm9jdXMgbm9kZSBlaXRoZXJcblxuICAgIGlmIChzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggPD0gMCAmJiAhZ2V0Tm9kZUZvck9wdGlvbignZmFsbGJhY2tGb2N1cycpIC8vIHJldHVybmluZyBmYWxzZSBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIG9wdGlvblxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIGZvY3VzLXRyYXAgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBjb250YWluZXIgd2l0aCBhdCBsZWFzdCBvbmUgdGFiYmFibGUgbm9kZSBpbiBpdCBhdCBhbGwgdGltZXMnKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHRyeUZvY3VzID0gZnVuY3Rpb24gdHJ5Rm9jdXMobm9kZSkge1xuICAgIGlmIChub2RlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSBkb2MuYWN0aXZlRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghbm9kZSB8fCAhbm9kZS5mb2N1cykge1xuICAgICAgdHJ5Rm9jdXMoZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6ICEhY29uZmlnLnByZXZlbnRTY3JvbGxcbiAgICB9KTtcbiAgICBzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSA9IG5vZGU7XG5cbiAgICBpZiAoaXNTZWxlY3RhYmxlSW5wdXQobm9kZSkpIHtcbiAgICAgIG5vZGUuc2VsZWN0KCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRSZXR1cm5Gb2N1c05vZGUgPSBmdW5jdGlvbiBnZXRSZXR1cm5Gb2N1c05vZGUocHJldmlvdXNBY3RpdmVFbGVtZW50KSB7XG4gICAgdmFyIG5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKCdzZXRSZXR1cm5Gb2N1cycsIHByZXZpb3VzQWN0aXZlRWxlbWVudCk7XG4gICAgcmV0dXJuIG5vZGUgPyBub2RlIDogbm9kZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHByZXZpb3VzQWN0aXZlRWxlbWVudDtcbiAgfTsgLy8gVGhpcyBuZWVkcyB0byBiZSBkb25lIG9uIG1vdXNlZG93biBhbmQgdG91Y2hzdGFydCBpbnN0ZWFkIG9mIGNsaWNrXG4gIC8vIHNvIHRoYXQgaXQgcHJlY2VkZXMgdGhlIGZvY3VzIGV2ZW50LlxuXG5cbiAgdmFyIGNoZWNrUG9pbnRlckRvd24gPSBmdW5jdGlvbiBjaGVja1BvaW50ZXJEb3duKGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0QWN0dWFsVGFyZ2V0KGUpO1xuXG4gICAgaWYgKGZpbmRDb250YWluZXJJbmRleCh0YXJnZXQpID49IDApIHtcbiAgICAgIC8vIGFsbG93IHRoZSBjbGljayBzaW5jZSBpdCBvY3VycmVkIGluc2lkZSB0aGUgdHJhcFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZU9ySGFuZGxlcihjb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMsIGUpKSB7XG4gICAgICAvLyBpbW1lZGlhdGVseSBkZWFjdGl2YXRlIHRoZSB0cmFwXG4gICAgICB0cmFwLmRlYWN0aXZhdGUoe1xuICAgICAgICAvLyBpZiwgb24gZGVhY3RpdmF0aW9uLCB3ZSBzaG91bGQgcmV0dXJuIGZvY3VzIHRvIHRoZSBub2RlIG9yaWdpbmFsbHktZm9jdXNlZFxuICAgICAgICAvLyAgd2hlbiB0aGUgdHJhcCB3YXMgYWN0aXZhdGVkIChvciB0aGUgY29uZmlndXJlZCBgc2V0UmV0dXJuRm9jdXNgIG5vZGUpLFxuICAgICAgICAvLyAgdGhlbiBhc3N1bWUgaXQncyBhbHNvIE9LIHRvIHJldHVybiBmb2N1cyB0byB0aGUgb3V0c2lkZSBub2RlIHRoYXQgd2FzXG4gICAgICAgIC8vICBqdXN0IGNsaWNrZWQsIGNhdXNpbmcgZGVhY3RpdmF0aW9uLCBhcyBsb25nIGFzIHRoYXQgbm9kZSBpcyBmb2N1c2FibGU7XG4gICAgICAgIC8vICBpZiBpdCBpc24ndCBmb2N1c2FibGUsIHRoZW4gcmV0dXJuIGZvY3VzIHRvIHRoZSBvcmlnaW5hbCBub2RlIGZvY3VzZWRcbiAgICAgICAgLy8gIG9uIGFjdGl2YXRpb24gKG9yIHRoZSBjb25maWd1cmVkIGBzZXRSZXR1cm5Gb2N1c2Agbm9kZSlcbiAgICAgICAgLy8gTk9URTogYnkgc2V0dGluZyBgcmV0dXJuRm9jdXM6IGZhbHNlYCwgZGVhY3RpdmF0ZSgpIHdpbGwgZG8gbm90aGluZyxcbiAgICAgICAgLy8gIHdoaWNoIHdpbGwgcmVzdWx0IGluIHRoZSBvdXRzaWRlIGNsaWNrIHNldHRpbmcgZm9jdXMgdG8gdGhlIG5vZGVcbiAgICAgICAgLy8gIHRoYXQgd2FzIGNsaWNrZWQsIHdoZXRoZXIgaXQncyBmb2N1c2FibGUgb3Igbm90OyBieSBzZXR0aW5nXG4gICAgICAgIC8vICBgcmV0dXJuRm9jdXM6IHRydWVgLCB3ZSdsbCBhdHRlbXB0IHRvIHJlLWZvY3VzIHRoZSBub2RlIG9yaWdpbmFsbHktZm9jdXNlZFxuICAgICAgICAvLyAgb24gYWN0aXZhdGlvbiAob3IgdGhlIGNvbmZpZ3VyZWQgYHNldFJldHVybkZvY3VzYCBub2RlKVxuICAgICAgICByZXR1cm5Gb2N1czogY29uZmlnLnJldHVybkZvY3VzT25EZWFjdGl2YXRlICYmICFpc0ZvY3VzYWJsZSh0YXJnZXQsIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoaXMgaXMgbmVlZGVkIGZvciBtb2JpbGUgZGV2aWNlcy5cbiAgICAvLyAoSWYgd2UnbGwgb25seSBsZXQgYGNsaWNrYCBldmVudHMgdGhyb3VnaCxcbiAgICAvLyB0aGVuIG9uIG1vYmlsZSB0aGV5IHdpbGwgYmUgYmxvY2tlZCBhbnl3YXlzIGlmIGB0b3VjaHN0YXJ0YCBpcyBibG9ja2VkLilcblxuXG4gICAgaWYgKHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5hbGxvd091dHNpZGVDbGljaywgZSkpIHtcbiAgICAgIC8vIGFsbG93IHRoZSBjbGljayBvdXRzaWRlIHRoZSB0cmFwIHRvIHRha2UgcGxhY2VcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG90aGVyd2lzZSwgcHJldmVudCB0aGUgY2xpY2tcblxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9OyAvLyBJbiBjYXNlIGZvY3VzIGVzY2FwZXMgdGhlIHRyYXAgZm9yIHNvbWUgc3RyYW5nZSByZWFzb24sIHB1bGwgaXQgYmFjayBpbi5cblxuXG4gIHZhciBjaGVja0ZvY3VzSW4gPSBmdW5jdGlvbiBjaGVja0ZvY3VzSW4oZSkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRBY3R1YWxUYXJnZXQoZSk7XG4gICAgdmFyIHRhcmdldENvbnRhaW5lZCA9IGZpbmRDb250YWluZXJJbmRleCh0YXJnZXQpID49IDA7IC8vIEluIEZpcmVmb3ggd2hlbiB5b3UgVGFiIG91dCBvZiBhbiBpZnJhbWUgdGhlIERvY3VtZW50IGlzIGJyaWVmbHkgZm9jdXNlZC5cblxuICAgIGlmICh0YXJnZXRDb250YWluZWQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIGlmICh0YXJnZXRDb250YWluZWQpIHtcbiAgICAgICAgc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzY2FwZWQhIHB1bGwgaXQgYmFjayBpbiB0byB3aGVyZSBpdCBqdXN0IGxlZnRcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB0cnlGb2N1cyhzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSB8fCBnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIH1cbiAgfTsgLy8gSGlqYWNrIFRhYiBldmVudHMgb24gdGhlIGZpcnN0IGFuZCBsYXN0IGZvY3VzYWJsZSBub2RlcyBvZiB0aGUgdHJhcCxcbiAgLy8gaW4gb3JkZXIgdG8gcHJldmVudCBmb2N1cyBmcm9tIGVzY2FwaW5nLiBJZiBpdCBlc2NhcGVzIGZvciBldmVuIGFcbiAgLy8gbW9tZW50IGl0IGNhbiBlbmQgdXAgc2Nyb2xsaW5nIHRoZSBwYWdlIGFuZCBjYXVzaW5nIGNvbmZ1c2lvbiBzbyB3ZVxuICAvLyBraW5kIG9mIG5lZWQgdG8gY2FwdHVyZSB0aGUgYWN0aW9uIGF0IHRoZSBrZXlkb3duIHBoYXNlLlxuXG5cbiAgdmFyIGNoZWNrVGFiID0gZnVuY3Rpb24gY2hlY2tUYWIoZSkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRBY3R1YWxUYXJnZXQoZSk7XG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgIHZhciBkZXN0aW5hdGlvbk5vZGUgPSBudWxsO1xuXG4gICAgaWYgKHN0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgdGFyZ2V0IGlzIGFjdHVhbGx5IGNvbnRhaW5lZCBpbiBhIGdyb3VwXG4gICAgICAvLyBOT1RFOiB0aGUgdGFyZ2V0IG1heSBhbHNvIGJlIHRoZSBjb250YWluZXIgaXRzZWxmIGlmIGl0J3MgZm9jdXNhYmxlXG4gICAgICAvLyAgd2l0aCB0YWJJbmRleD0nLTEnIGFuZCB3YXMgZ2l2ZW4gaW5pdGlhbCBmb2N1c1xuICAgICAgdmFyIGNvbnRhaW5lckluZGV4ID0gZmluZENvbnRhaW5lckluZGV4KHRhcmdldCk7XG4gICAgICB2YXIgY29udGFpbmVyR3JvdXAgPSBjb250YWluZXJJbmRleCA+PSAwID8gc3RhdGUuY29udGFpbmVyR3JvdXBzW2NvbnRhaW5lckluZGV4XSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGNvbnRhaW5lckluZGV4IDwgMCkge1xuICAgICAgICAvLyB0YXJnZXQgbm90IGZvdW5kIGluIGFueSBncm91cDogcXVpdGUgcG9zc2libGUgZm9jdXMgaGFzIGVzY2FwZWQgdGhlIHRyYXAsXG4gICAgICAgIC8vICBzbyBicmluZyBpdCBiYWNrIGluIHRvLi4uXG4gICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgLy8gLi4udGhlIGxhc3Qgbm9kZSBpbiB0aGUgbGFzdCBncm91cFxuICAgICAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IHN0YXRlLnRhYmJhYmxlR3JvdXBzW3N0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCAtIDFdLmxhc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gLi4udGhlIGZpcnN0IG5vZGUgaW4gdGhlIGZpcnN0IGdyb3VwXG4gICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gc3RhdGUudGFiYmFibGVHcm91cHNbMF0uZmlyc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAvLyBSRVZFUlNFXG4gICAgICAgIC8vIGlzIHRoZSB0YXJnZXQgdGhlIGZpcnN0IHRhYmJhYmxlIG5vZGUgaW4gYSBncm91cD9cbiAgICAgICAgdmFyIHN0YXJ0T2ZHcm91cEluZGV4ID0gZmluZEluZGV4KHN0YXRlLnRhYmJhYmxlR3JvdXBzLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICB2YXIgZmlyc3RUYWJiYWJsZU5vZGUgPSBfcmVmMi5maXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0ID09PSBmaXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0T2ZHcm91cEluZGV4IDwgMCAmJiAoY29udGFpbmVyR3JvdXAuY29udGFpbmVyID09PSB0YXJnZXQgfHwgaXNGb2N1c2FibGUodGFyZ2V0LCBjb25maWcudGFiYmFibGVPcHRpb25zKSAmJiAhaXNUYWJiYWJsZSh0YXJnZXQsIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpICYmICFjb250YWluZXJHcm91cC5uZXh0VGFiYmFibGVOb2RlKHRhcmdldCwgZmFsc2UpKSkge1xuICAgICAgICAgIC8vIGFuIGV4Y2VwdGlvbiBjYXNlIHdoZXJlIHRoZSB0YXJnZXQgaXMgZWl0aGVyIHRoZSBjb250YWluZXIgaXRzZWxmLCBvclxuICAgICAgICAgIC8vICBhIG5vbi10YWJiYWJsZSBub2RlIHRoYXQgd2FzIGdpdmVuIGZvY3VzIChpLmUuIHRhYmluZGV4IGlzIG5lZ2F0aXZlXG4gICAgICAgICAgLy8gIGFuZCB1c2VyIGNsaWNrZWQgb24gaXQgb3Igbm9kZSB3YXMgcHJvZ3JhbW1hdGljYWxseSBnaXZlbiBmb2N1cylcbiAgICAgICAgICAvLyAgYW5kIGlzIG5vdCBmb2xsb3dlZCBieSBhbnkgb3RoZXIgdGFiYmFibGUgbm9kZSwgaW4gd2hpY2hcbiAgICAgICAgICAvLyAgY2FzZSwgd2Ugc2hvdWxkIGhhbmRsZSBzaGlmdCt0YWIgYXMgaWYgZm9jdXMgd2VyZSBvbiB0aGUgY29udGFpbmVyJ3NcbiAgICAgICAgICAvLyAgZmlyc3QgdGFiYmFibGUgbm9kZSwgYW5kIGdvIHRvIHRoZSBsYXN0IHRhYmJhYmxlIG5vZGUgb2YgdGhlIExBU1QgZ3JvdXBcbiAgICAgICAgICBzdGFydE9mR3JvdXBJbmRleCA9IGNvbnRhaW5lckluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0T2ZHcm91cEluZGV4ID49IDApIHtcbiAgICAgICAgICAvLyBZRVM6IHRoZW4gc2hpZnQrdGFiIHNob3VsZCBnbyB0byB0aGUgbGFzdCB0YWJiYWJsZSBub2RlIGluIHRoZVxuICAgICAgICAgIC8vICBwcmV2aW91cyBncm91cCAoYW5kIHdyYXAgYXJvdW5kIHRvIHRoZSBsYXN0IHRhYmJhYmxlIG5vZGUgb2ZcbiAgICAgICAgICAvLyAgdGhlIExBU1QgZ3JvdXAgaWYgaXQncyB0aGUgZmlyc3QgdGFiYmFibGUgbm9kZSBvZiB0aGUgRklSU1QgZ3JvdXApXG4gICAgICAgICAgdmFyIGRlc3RpbmF0aW9uR3JvdXBJbmRleCA9IHN0YXJ0T2ZHcm91cEluZGV4ID09PSAwID8gc3RhdGUudGFiYmFibGVHcm91cHMubGVuZ3RoIC0gMSA6IHN0YXJ0T2ZHcm91cEluZGV4IC0gMTtcbiAgICAgICAgICB2YXIgZGVzdGluYXRpb25Hcm91cCA9IHN0YXRlLnRhYmJhYmxlR3JvdXBzW2Rlc3RpbmF0aW9uR3JvdXBJbmRleF07XG4gICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gZGVzdGluYXRpb25Hcm91cC5sYXN0VGFiYmFibGVOb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGT1JXQVJEXG4gICAgICAgIC8vIGlzIHRoZSB0YXJnZXQgdGhlIGxhc3QgdGFiYmFibGUgbm9kZSBpbiBhIGdyb3VwP1xuICAgICAgICB2YXIgbGFzdE9mR3JvdXBJbmRleCA9IGZpbmRJbmRleChzdGF0ZS50YWJiYWJsZUdyb3VwcywgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgdmFyIGxhc3RUYWJiYWJsZU5vZGUgPSBfcmVmMy5sYXN0VGFiYmFibGVOb2RlO1xuICAgICAgICAgIHJldHVybiB0YXJnZXQgPT09IGxhc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChsYXN0T2ZHcm91cEluZGV4IDwgMCAmJiAoY29udGFpbmVyR3JvdXAuY29udGFpbmVyID09PSB0YXJnZXQgfHwgaXNGb2N1c2FibGUodGFyZ2V0LCBjb25maWcudGFiYmFibGVPcHRpb25zKSAmJiAhaXNUYWJiYWJsZSh0YXJnZXQsIGNvbmZpZy50YWJiYWJsZU9wdGlvbnMpICYmICFjb250YWluZXJHcm91cC5uZXh0VGFiYmFibGVOb2RlKHRhcmdldCkpKSB7XG4gICAgICAgICAgLy8gYW4gZXhjZXB0aW9uIGNhc2Ugd2hlcmUgdGhlIHRhcmdldCBpcyB0aGUgY29udGFpbmVyIGl0c2VsZiwgb3JcbiAgICAgICAgICAvLyAgYSBub24tdGFiYmFibGUgbm9kZSB0aGF0IHdhcyBnaXZlbiBmb2N1cyAoaS5lLiB0YWJpbmRleCBpcyBuZWdhdGl2ZVxuICAgICAgICAgIC8vICBhbmQgdXNlciBjbGlja2VkIG9uIGl0IG9yIG5vZGUgd2FzIHByb2dyYW1tYXRpY2FsbHkgZ2l2ZW4gZm9jdXMpXG4gICAgICAgICAgLy8gIGFuZCBpcyBub3QgZm9sbG93ZWQgYnkgYW55IG90aGVyIHRhYmJhYmxlIG5vZGUsIGluIHdoaWNoXG4gICAgICAgICAgLy8gIGNhc2UsIHdlIHNob3VsZCBoYW5kbGUgdGFiIGFzIGlmIGZvY3VzIHdlcmUgb24gdGhlIGNvbnRhaW5lcidzXG4gICAgICAgICAgLy8gIGxhc3QgdGFiYmFibGUgbm9kZSwgYW5kIGdvIHRvIHRoZSBmaXJzdCB0YWJiYWJsZSBub2RlIG9mIHRoZSBGSVJTVCBncm91cFxuICAgICAgICAgIGxhc3RPZkdyb3VwSW5kZXggPSBjb250YWluZXJJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0T2ZHcm91cEluZGV4ID49IDApIHtcbiAgICAgICAgICAvLyBZRVM6IHRoZW4gdGFiIHNob3VsZCBnbyB0byB0aGUgZmlyc3QgdGFiYmFibGUgbm9kZSBpbiB0aGUgbmV4dFxuICAgICAgICAgIC8vICBncm91cCAoYW5kIHdyYXAgYXJvdW5kIHRvIHRoZSBmaXJzdCB0YWJiYWJsZSBub2RlIG9mIHRoZSBGSVJTVFxuICAgICAgICAgIC8vICBncm91cCBpZiBpdCdzIHRoZSBsYXN0IHRhYmJhYmxlIG5vZGUgb2YgdGhlIExBU1QgZ3JvdXApXG4gICAgICAgICAgdmFyIF9kZXN0aW5hdGlvbkdyb3VwSW5kZXggPSBsYXN0T2ZHcm91cEluZGV4ID09PSBzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggLSAxID8gMCA6IGxhc3RPZkdyb3VwSW5kZXggKyAxO1xuXG4gICAgICAgICAgdmFyIF9kZXN0aW5hdGlvbkdyb3VwID0gc3RhdGUudGFiYmFibGVHcm91cHNbX2Rlc3RpbmF0aW9uR3JvdXBJbmRleF07XG4gICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gX2Rlc3RpbmF0aW9uR3JvdXAuZmlyc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTk9URTogdGhlIGZhbGxiYWNrRm9jdXMgb3B0aW9uIGRvZXMgbm90IHN1cHBvcnQgcmV0dXJuaW5nIGZhbHNlIHRvIG9wdC1vdXRcbiAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IGdldE5vZGVGb3JPcHRpb24oJ2ZhbGxiYWNrRm9jdXMnKTtcbiAgICB9XG5cbiAgICBpZiAoZGVzdGluYXRpb25Ob2RlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0cnlGb2N1cyhkZXN0aW5hdGlvbk5vZGUpO1xuICAgIH0gLy8gZWxzZSwgbGV0IHRoZSBicm93c2VyIHRha2UgY2FyZSBvZiBbc2hpZnQrXXRhYiBhbmQgbW92ZSB0aGUgZm9jdXNcblxuICB9O1xuXG4gIHZhciBjaGVja0tleSA9IGZ1bmN0aW9uIGNoZWNrS2V5KGUpIHtcbiAgICBpZiAoaXNFc2NhcGVFdmVudChlKSAmJiB2YWx1ZU9ySGFuZGxlcihjb25maWcuZXNjYXBlRGVhY3RpdmF0ZXMsIGUpICE9PSBmYWxzZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzVGFiRXZlbnQoZSkpIHtcbiAgICAgIGNoZWNrVGFiKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY2hlY2tDbGljayA9IGZ1bmN0aW9uIGNoZWNrQ2xpY2soZSkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRBY3R1YWxUYXJnZXQoZSk7XG5cbiAgICBpZiAoZmluZENvbnRhaW5lckluZGV4KHRhcmdldCkgPj0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZU9ySGFuZGxlcihjb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMsIGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5hbGxvd091dHNpZGVDbGljaywgZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfTsgLy9cbiAgLy8gRVZFTlQgTElTVEVORVJTXG4gIC8vXG5cblxuICB2YXIgYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmICghc3RhdGUuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUaGVyZSBjYW4gYmUgb25seSBvbmUgbGlzdGVuaW5nIGZvY3VzIHRyYXAgYXQgYSB0aW1lXG5cblxuICAgIGFjdGl2ZUZvY3VzVHJhcHMuYWN0aXZhdGVUcmFwKHRyYXApOyAvLyBEZWxheSBlbnN1cmVzIHRoYXQgdGhlIGZvY3VzZWQgZWxlbWVudCBkb2Vzbid0IGNhcHR1cmUgdGhlIGV2ZW50XG4gICAgLy8gdGhhdCBjYXVzZWQgdGhlIGZvY3VzIHRyYXAgYWN0aXZhdGlvbi5cblxuICAgIHN0YXRlLmRlbGF5SW5pdGlhbEZvY3VzVGltZXIgPSBjb25maWcuZGVsYXlJbml0aWFsRm9jdXMgPyBkZWxheShmdW5jdGlvbiAoKSB7XG4gICAgICB0cnlGb2N1cyhnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIH0pIDogdHJ5Rm9jdXMoZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGNoZWNrRm9jdXNJbiwgdHJ1ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2hlY2tQb2ludGVyRG93biwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH07XG5cbiAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBpZiAoIXN0YXRlLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgY2hlY2tGb2N1c0luLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjaGVja0NsaWNrLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNoZWNrS2V5LCB0cnVlKTtcbiAgICByZXR1cm4gdHJhcDtcbiAgfTsgLy9cbiAgLy8gVFJBUCBERUZJTklUSU9OXG4gIC8vXG5cblxuICB0cmFwID0ge1xuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICByZXR1cm4gc3RhdGUuYWN0aXZlO1xuICAgIH0sXG5cbiAgICBnZXQgcGF1c2VkKCkge1xuICAgICAgcmV0dXJuIHN0YXRlLnBhdXNlZDtcbiAgICB9LFxuXG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uIGFjdGl2YXRlKGFjdGl2YXRlT3B0aW9ucykge1xuICAgICAgaWYgKHN0YXRlLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIG9uQWN0aXZhdGUgPSBnZXRPcHRpb24oYWN0aXZhdGVPcHRpb25zLCAnb25BY3RpdmF0ZScpO1xuICAgICAgdmFyIG9uUG9zdEFjdGl2YXRlID0gZ2V0T3B0aW9uKGFjdGl2YXRlT3B0aW9ucywgJ29uUG9zdEFjdGl2YXRlJyk7XG4gICAgICB2YXIgY2hlY2tDYW5Gb2N1c1RyYXAgPSBnZXRPcHRpb24oYWN0aXZhdGVPcHRpb25zLCAnY2hlY2tDYW5Gb2N1c1RyYXAnKTtcblxuICAgICAgaWYgKCFjaGVja0NhbkZvY3VzVHJhcCkge1xuICAgICAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmFjdGl2ZSA9IHRydWU7XG4gICAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IGRvYy5hY3RpdmVFbGVtZW50O1xuXG4gICAgICBpZiAob25BY3RpdmF0ZSkge1xuICAgICAgICBvbkFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaW5pc2hBY3RpdmF0aW9uID0gZnVuY3Rpb24gZmluaXNoQWN0aXZhdGlvbigpIHtcbiAgICAgICAgaWYgKGNoZWNrQ2FuRm9jdXNUcmFwKSB7XG4gICAgICAgICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkTGlzdGVuZXJzKCk7XG5cbiAgICAgICAgaWYgKG9uUG9zdEFjdGl2YXRlKSB7XG4gICAgICAgICAgb25Qb3N0QWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGNoZWNrQ2FuRm9jdXNUcmFwKSB7XG4gICAgICAgIGNoZWNrQ2FuRm9jdXNUcmFwKHN0YXRlLmNvbnRhaW5lcnMuY29uY2F0KCkpLnRoZW4oZmluaXNoQWN0aXZhdGlvbiwgZmluaXNoQWN0aXZhdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBmaW5pc2hBY3RpdmF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRlYWN0aXZhdGU6IGZ1bmN0aW9uIGRlYWN0aXZhdGUoZGVhY3RpdmF0ZU9wdGlvbnMpIHtcbiAgICAgIGlmICghc3RhdGUuYWN0aXZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgb25EZWFjdGl2YXRlOiBjb25maWcub25EZWFjdGl2YXRlLFxuICAgICAgICBvblBvc3REZWFjdGl2YXRlOiBjb25maWcub25Qb3N0RGVhY3RpdmF0ZSxcbiAgICAgICAgY2hlY2tDYW5SZXR1cm5Gb2N1czogY29uZmlnLmNoZWNrQ2FuUmV0dXJuRm9jdXNcbiAgICAgIH0sIGRlYWN0aXZhdGVPcHRpb25zKTtcblxuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLmRlbGF5SW5pdGlhbEZvY3VzVGltZXIpOyAvLyBub29wIGlmIHVuZGVmaW5lZFxuXG4gICAgICBzdGF0ZS5kZWxheUluaXRpYWxGb2N1c1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICBzdGF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgYWN0aXZlRm9jdXNUcmFwcy5kZWFjdGl2YXRlVHJhcCh0cmFwKTtcbiAgICAgIHZhciBvbkRlYWN0aXZhdGUgPSBnZXRPcHRpb24ob3B0aW9ucywgJ29uRGVhY3RpdmF0ZScpO1xuICAgICAgdmFyIG9uUG9zdERlYWN0aXZhdGUgPSBnZXRPcHRpb24ob3B0aW9ucywgJ29uUG9zdERlYWN0aXZhdGUnKTtcbiAgICAgIHZhciBjaGVja0NhblJldHVybkZvY3VzID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdjaGVja0NhblJldHVybkZvY3VzJyk7XG4gICAgICB2YXIgcmV0dXJuRm9jdXMgPSBnZXRPcHRpb24ob3B0aW9ucywgJ3JldHVybkZvY3VzJywgJ3JldHVybkZvY3VzT25EZWFjdGl2YXRlJyk7XG5cbiAgICAgIGlmIChvbkRlYWN0aXZhdGUpIHtcbiAgICAgICAgb25EZWFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaW5pc2hEZWFjdGl2YXRpb24gPSBmdW5jdGlvbiBmaW5pc2hEZWFjdGl2YXRpb24oKSB7XG4gICAgICAgIGRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRm9jdXMpIHtcbiAgICAgICAgICAgIHRyeUZvY3VzKGdldFJldHVybkZvY3VzTm9kZShzdGF0ZS5ub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob25Qb3N0RGVhY3RpdmF0ZSkge1xuICAgICAgICAgICAgb25Qb3N0RGVhY3RpdmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAocmV0dXJuRm9jdXMgJiYgY2hlY2tDYW5SZXR1cm5Gb2N1cykge1xuICAgICAgICBjaGVja0NhblJldHVybkZvY3VzKGdldFJldHVybkZvY3VzTm9kZShzdGF0ZS5ub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24pKS50aGVuKGZpbmlzaERlYWN0aXZhdGlvbiwgZmluaXNoRGVhY3RpdmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZpbmlzaERlYWN0aXZhdGlvbigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICBpZiAoc3RhdGUucGF1c2VkIHx8ICFzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBhdXNlZCA9IHRydWU7XG4gICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdW5wYXVzZTogZnVuY3Rpb24gdW5wYXVzZSgpIHtcbiAgICAgIGlmICghc3RhdGUucGF1c2VkIHx8ICFzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgYWRkTGlzdGVuZXJzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHVwZGF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiB1cGRhdGVDb250YWluZXJFbGVtZW50cyhjb250YWluZXJFbGVtZW50cykge1xuICAgICAgdmFyIGVsZW1lbnRzQXNBcnJheSA9IFtdLmNvbmNhdChjb250YWluZXJFbGVtZW50cykuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgc3RhdGUuY29udGFpbmVycyA9IGVsZW1lbnRzQXNBcnJheS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGRvYy5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpIDogZWxlbWVudDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3RhdGUuYWN0aXZlKSB7XG4gICAgICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9OyAvLyBpbml0aWFsaXplIGNvbnRhaW5lciBlbGVtZW50c1xuXG4gIHRyYXAudXBkYXRlQ29udGFpbmVyRWxlbWVudHMoZWxlbWVudHMpO1xuICByZXR1cm4gdHJhcDtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUZvY3VzVHJhcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtdHJhcC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/focus-trap/dist/focus-trap.esm.js\n"));

/***/ }),

/***/ "./node_modules/no-scroll/index.js":
/*!*****************************************!*\
  !*** ./node_modules/no-scroll/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function(root) {\n  var isOn = false;\n  var scrollbarSize;\n  var scrollTop;\n\n  function getScrollbarSize() {\n    if (typeof scrollbarSize !== 'undefined') return scrollbarSize;\n\n    var doc = document.documentElement;\n    var dummyScroller = document.createElement('div');\n    dummyScroller.setAttribute('style', 'width:99px;height:99px;' + 'position:absolute;top:-9999px;overflow:scroll;');\n    doc.appendChild(dummyScroller);\n    scrollbarSize = dummyScroller.offsetWidth - dummyScroller.clientWidth;\n    doc.removeChild(dummyScroller);\n    return scrollbarSize;\n  }\n\n  function hasScrollbar() {\n    return document.documentElement.scrollHeight > window.innerHeight;\n  }\n\n  function on(options) {\n    if (typeof document === 'undefined' || isOn) return;\n    var doc = document.documentElement;\n    scrollTop = window.pageYOffset;\n    if (hasScrollbar()) {\n      doc.style.width = 'calc(100% - '+ getScrollbarSize() +'px)';\n    } else {\n      doc.style.width = '100%';\n    }\n    doc.style.position = 'fixed';\n    doc.style.top = -scrollTop + 'px';\n    doc.style.overflow = 'hidden';\n    isOn = true;\n  }\n\n  function off() {\n    if (typeof document === 'undefined' || !isOn) return;\n    var doc = document.documentElement;\n    doc.style.width = '';\n    doc.style.position = '';\n    doc.style.top = '';\n    doc.style.overflow = '';\n    window.scroll(0, scrollTop);\n    isOn = false;\n  }\n\n  function toggle() {\n    if (isOn) {\n      off();\n      return;\n    }\n    on();\n  }\n\n  var noScroll = {\n    on: on,\n    off: off,\n    toggle: toggle,\n  };\n\n  if ( true && typeof module.exports !== 'undefined') {\n    module.exports = noScroll;\n  } else {\n    root.noScroll = noScroll;\n  }\n})(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm8tc2Nyb2xsL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxZQUFZLHVCQUF1QixZQUFZLGdCQUFnQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQTZCO0FBQ25DO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uby1zY3JvbGwvaW5kZXguanM/YmFmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24ocm9vdCkge1xuICB2YXIgaXNPbiA9IGZhbHNlO1xuICB2YXIgc2Nyb2xsYmFyU2l6ZTtcbiAgdmFyIHNjcm9sbFRvcDtcblxuICBmdW5jdGlvbiBnZXRTY3JvbGxiYXJTaXplKCkge1xuICAgIGlmICh0eXBlb2Ygc2Nyb2xsYmFyU2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBzY3JvbGxiYXJTaXplO1xuXG4gICAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgZHVtbXlTY3JvbGxlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGR1bW15U2Nyb2xsZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICd3aWR0aDo5OXB4O2hlaWdodDo5OXB4OycgKyAncG9zaXRpb246YWJzb2x1dGU7dG9wOi05OTk5cHg7b3ZlcmZsb3c6c2Nyb2xsOycpO1xuICAgIGRvYy5hcHBlbmRDaGlsZChkdW1teVNjcm9sbGVyKTtcbiAgICBzY3JvbGxiYXJTaXplID0gZHVtbXlTY3JvbGxlci5vZmZzZXRXaWR0aCAtIGR1bW15U2Nyb2xsZXIuY2xpZW50V2lkdGg7XG4gICAgZG9jLnJlbW92ZUNoaWxkKGR1bW15U2Nyb2xsZXIpO1xuICAgIHJldHVybiBzY3JvbGxiYXJTaXplO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzU2Nyb2xsYmFyKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gb24ob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IGlzT24pIHJldHVybjtcbiAgICB2YXIgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICBpZiAoaGFzU2Nyb2xsYmFyKCkpIHtcbiAgICAgIGRvYy5zdHlsZS53aWR0aCA9ICdjYWxjKDEwMCUgLSAnKyBnZXRTY3JvbGxiYXJTaXplKCkgKydweCknO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2Muc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgfVxuICAgIGRvYy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgZG9jLnN0eWxlLnRvcCA9IC1zY3JvbGxUb3AgKyAncHgnO1xuICAgIGRvYy5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIGlzT24gPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb2ZmKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICFpc09uKSByZXR1cm47XG4gICAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBkb2Muc3R5bGUud2lkdGggPSAnJztcbiAgICBkb2Muc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICBkb2Muc3R5bGUudG9wID0gJyc7XG4gICAgZG9jLnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgd2luZG93LnNjcm9sbCgwLCBzY3JvbGxUb3ApO1xuICAgIGlzT24gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICBpZiAoaXNPbikge1xuICAgICAgb2ZmKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uKCk7XG4gIH1cblxuICB2YXIgbm9TY3JvbGwgPSB7XG4gICAgb246IG9uLFxuICAgIG9mZjogb2ZmLFxuICAgIHRvZ2dsZTogdG9nZ2xlLFxuICB9O1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBub1Njcm9sbDtcbiAgfSBlbHNlIHtcbiAgICByb290Lm5vU2Nyb2xsID0gbm9TY3JvbGw7XG4gIH1cbn0pKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/no-scroll/index.js\n"));

/***/ }),

/***/ "./node_modules/tabbable/dist/index.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tabbable/dist/index.esm.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"focusable\": function() { return /* binding */ focusable; },\n/* harmony export */   \"isFocusable\": function() { return /* binding */ isFocusable; },\n/* harmony export */   \"isTabbable\": function() { return /* binding */ isTabbable; },\n/* harmony export */   \"tabbable\": function() { return /* binding */ tabbable; }\n/* harmony export */ });\n/*!\n* tabbable 5.3.3\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  return element.getRootNode();\n} : function (element) {\n  return element.ownerDocument;\n};\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\n\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidatesScope\n * @property {Element} scope contains inner candidates\n * @property {Element[]} candidates\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidatesScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidatesScope>}\n */\n\n\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scope: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      } // iterate over shadow content if possible\n\n\n      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);\n\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scope: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n\n  return candidates;\n};\n\nvar getTabindex = function getTabindex(node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\n\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\n\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\n\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || getRootNode(node);\n\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n\n  var radioSet;\n\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      width = _node$getBoundingClie.width,\n      height = _node$getBoundingClie.height;\n\n  return width === 0 && height === 0;\n};\n\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n      getShadowRoot = _ref.getShadowRoot;\n\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  } // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n\n\n  var nodeRootHost = getRootNode(node).host;\n  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);\n\n  if (!displayCheck || displayCheck === 'full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n\n    if (nodeIsAttached) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    } // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  } // visible, as far as we can tell, or per current `displayCheck` mode\n\n\n  return false;\n}; // form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\n\n\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>\n\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i); // when the first <legend> (in document order) is found\n\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        } // the disabled <fieldset> containing `node` has no <legend>\n\n\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  } // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n\n\n  return false;\n};\n\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  } // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n\n\n  return false;\n};\n/**\n * @param {Array.<Element|CandidatesScope>} candidates\n * @returns Element[]\n */\n\n\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scope;\n    var element = isScope ? item.scope : item;\n    var candidateTabindex = getTabindex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\n\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n\n  return sortByOrder(candidates);\n};\n\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n\n  return candidates;\n};\n\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvZGlzdC9pbmRleC5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLDRCQUE0QjtBQUN2QyxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLG9CQUFvQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkIsY0FBYyxXQUFXO0FBQ3pCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsdUJBQXVCLGlEQUFpRDtBQUN0RjtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUMsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsa0JBQWtCO0FBQ2hDOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsU0FBUztBQUNwQixXQUFXLGtCQUFrQjtBQUM3QixhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksb0VBQW9FO0FBQ3hFLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTix1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RCxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFd0Q7QUFDeEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RhYmJhYmxlL2Rpc3QvaW5kZXguZXNtLmpzPzI2N2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIHRhYmJhYmxlIDUuMy4zXG4qIEBsaWNlbnNlIE1JVCwgaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvdGFiYmFibGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuKi9cbnZhciBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbJ2lucHV0JywgJ3NlbGVjdCcsICd0ZXh0YXJlYScsICdhW2hyZWZdJywgJ2J1dHRvbicsICdbdGFiaW5kZXhdOm5vdChzbG90KScsICdhdWRpb1tjb250cm9sc10nLCAndmlkZW9bY29udHJvbHNdJywgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0pJywgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJywgJ2RldGFpbHMnXTtcbnZhciBjYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqL2NhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJyk7XG52YXIgTm9FbGVtZW50ID0gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnO1xudmFyIG1hdGNoZXMgPSBOb0VsZW1lbnQgPyBmdW5jdGlvbiAoKSB7fSA6IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xudmFyIGdldFJvb3ROb2RlID0gIU5vRWxlbWVudCAmJiBFbGVtZW50LnByb3RvdHlwZS5nZXRSb290Tm9kZSA/IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LmdldFJvb3ROb2RlKCk7XG59IDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudDtcbn07XG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgY29udGFpbmVyIHRvIGNoZWNrIGluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciB0byBjaGVja1xuICogQHBhcmFtIHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudFtdfVxuICovXG5cbnZhciBnZXRDYW5kaWRhdGVzID0gZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlcyhlbCwgaW5jbHVkZUNvbnRhaW5lciwgZmlsdGVyKSB7XG4gIHZhciBjYW5kaWRhdGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2FuZGlkYXRlU2VsZWN0b3IpKTtcblxuICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gIH1cblxuICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5maWx0ZXIoZmlsdGVyKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuLyoqXG4gKiBAY2FsbGJhY2sgR2V0U2hhZG93Um9vdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrIGZvciBzaGFkb3cgcm9vdFxuICogQHJldHVybnMge1NoYWRvd1Jvb3R8Ym9vbGVhbn0gU2hhZG93Um9vdCBpZiBhdmFpbGFibGUgb3IgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgc2hhZG93Um9vdCBpcyBhdHRhY2hlZCBidXQgbm90IGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTaGFkb3dSb290RmlsdGVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHNoYWRvd0hvc3ROb2RlIHRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHNoYWRvdyBjb250ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIHNoYWRvdyByb290IGNvdWxkIHBvdGVudGlhbGx5IGNvbnRhaW4gdmFsaWQgY2FuZGlkYXRlcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbmRpZGF0ZXNTY29wZVxuICogQHByb3BlcnR5IHtFbGVtZW50fSBzY29wZSBjb250YWlucyBpbm5lciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge0VsZW1lbnRbXX0gY2FuZGlkYXRlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSXRlcmF0aXZlT3B0aW9uc1xuICogQHByb3BlcnR5IHtHZXRTaGFkb3dSb290fGJvb2xlYW59IGdldFNoYWRvd1Jvb3QgdHJ1ZSBpZiBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkOyBmYWxzeSBpZiBub3Q7XG4gKiAgaWYgYSBmdW5jdGlvbiwgaW1wbGllcyBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkIGFuZCBlaXRoZXIgcmV0dXJucyB0aGUgc2hhZG93IHJvb3Qgb2YgYW4gZWxlbWVudFxuICogIG9yIGEgYm9vbGVhbiBzdGF0aW5nIGlmIGl0IGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgcm9vdFxuICogQHByb3BlcnR5IHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZsYXR0ZW4gaWYgdHJ1ZSB0aGVuIHJlc3VsdCB3aWxsIGZsYXR0ZW4gYW55IENhbmRpZGF0ZXNTY29wZSBpbnRvIHRoZSByZXR1cm5lZCBsaXN0XG4gKiBAcHJvcGVydHkge1NoYWRvd1Jvb3RGaWx0ZXJ9IHNoYWRvd1Jvb3RGaWx0ZXIgZmlsdGVyIHNoYWRvdyByb290cztcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50cyBsaXN0IG9mIGVsZW1lbnQgY29udGFpbmVycyB0byBtYXRjaCBjYW5kaWRhdGVzIGZyb21cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIGxpc3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7SXRlcmF0aXZlT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZXNTY29wZT59XG4gKi9cblxuXG52YXIgZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5ID0gZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KGVsZW1lbnRzLCBpbmNsdWRlQ29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHZhciBjYW5kaWRhdGVzID0gW107XG4gIHZhciBlbGVtZW50c1RvQ2hlY2sgPSBBcnJheS5mcm9tKGVsZW1lbnRzKTtcblxuICB3aGlsZSAoZWxlbWVudHNUb0NoZWNrLmxlbmd0aCkge1xuICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNUb0NoZWNrLnNoaWZ0KCk7XG5cbiAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnU0xPVCcpIHtcbiAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNsb3Qgc2NvcGUgKHNsb3QgaXRzZWxmIGNhbm5vdCBiZSBmb2N1c2FibGUpXG4gICAgICB2YXIgYXNzaWduZWQgPSBlbGVtZW50LmFzc2lnbmVkRWxlbWVudHMoKTtcbiAgICAgIHZhciBjb250ZW50ID0gYXNzaWduZWQubGVuZ3RoID8gYXNzaWduZWQgOiBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgdmFyIG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoY29udGVudCwgdHJ1ZSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoLmFwcGx5KGNhbmRpZGF0ZXMsIG5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBzY29wZTogZWxlbWVudCxcbiAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayBjYW5kaWRhdGUgZWxlbWVudFxuICAgICAgdmFyIHZhbGlkQ2FuZGlkYXRlID0gbWF0Y2hlcy5jYWxsKGVsZW1lbnQsIGNhbmRpZGF0ZVNlbGVjdG9yKTtcblxuICAgICAgaWYgKHZhbGlkQ2FuZGlkYXRlICYmIG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQpICYmIChpbmNsdWRlQ29udGFpbmVyIHx8ICFlbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSkpIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSAvLyBpdGVyYXRlIG92ZXIgc2hhZG93IGNvbnRlbnQgaWYgcG9zc2libGVcblxuXG4gICAgICB2YXIgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdCB8fCAvLyBjaGVjayBmb3IgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICB0eXBlb2Ygb3B0aW9ucy5nZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMuZ2V0U2hhZG93Um9vdChlbGVtZW50KTtcbiAgICAgIHZhciB2YWxpZFNoYWRvd1Jvb3QgPSAhb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyIHx8IG9wdGlvbnMuc2hhZG93Um9vdEZpbHRlcihlbGVtZW50KTtcblxuICAgICAgaWYgKHNoYWRvd1Jvb3QgJiYgdmFsaWRTaGFkb3dSb290KSB7XG4gICAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNjb3BlIElJRiBhIHNoYWRvdyByb290IG5vZGUgd2FzIGdpdmVuOyBvdGhlcndpc2UsIGFuIHVuZGlzY2xvc2VkXG4gICAgICAgIC8vICBzaGFkb3cgZXhpc3RzLCBzbyBsb29rIGF0IGxpZ2h0IGRvbSBjaGlsZHJlbiBhcyBmYWxsYmFjayBCVVQgY3JlYXRlIGEgc2NvcGUgZm9yIGFueVxuICAgICAgICAvLyAgY2hpbGQgY2FuZGlkYXRlcyBmb3VuZCBiZWNhdXNlIHRoZXkncmUgbGlrZWx5IHNsb3R0ZWQgZWxlbWVudHMgKGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgICAgIC8vICBjaGlsZHJlbiBvZiB0aGUgd2ViIGNvbXBvbmVudCBlbGVtZW50ICh3aGljaCBoYXMgdGhlIHNoYWRvdyksIGluIHRoZSBsaWdodCBkb20sIGJ1dFxuICAgICAgICAvLyAgc2xvdHRlZCBzb21ld2hlcmUgX2luc2lkZV8gdGhlIHVuZGlzY2xvc2VkIHNoYWRvdykgLS0gdGhlIHNjb3BlIGlzIGNyZWF0ZWQgYmVsb3csXG4gICAgICAgIC8vICBfYWZ0ZXJfIHdlIHJldHVybiBmcm9tIHRoaXMgcmVjdXJzaXZlIGNhbGxcbiAgICAgICAgdmFyIF9uZXN0ZWRDYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KHNoYWRvd1Jvb3QgPT09IHRydWUgPyBlbGVtZW50LmNoaWxkcmVuIDogc2hhZG93Um9vdC5jaGlsZHJlbiwgdHJ1ZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaC5hcHBseShjYW5kaWRhdGVzLCBfbmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3BlOiBlbGVtZW50LFxuICAgICAgICAgICAgY2FuZGlkYXRlczogX25lc3RlZENhbmRpZGF0ZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlcmUncyBub3Qgc2hhZG93IHNvIGp1c3QgZGlnIGludG8gdGhlIGVsZW1lbnQncyAobGlnaHQgZG9tKSBjaGlsZHJlblxuICAgICAgICAvLyAgX193aXRob3V0X18gZ2l2aW5nIHRoZSBlbGVtZW50IHNwZWNpYWwgc2NvcGUgdHJlYXRtZW50XG4gICAgICAgIGVsZW1lbnRzVG9DaGVjay51bnNoaWZ0LmFwcGx5KGVsZW1lbnRzVG9DaGVjaywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG52YXIgZ2V0VGFiaW5kZXggPSBmdW5jdGlvbiBnZXRUYWJpbmRleChub2RlLCBpc1Njb3BlKSB7XG4gIGlmIChub2RlLnRhYkluZGV4IDwgMCkge1xuICAgIC8vIGluIENocm9tZSwgPGRldGFpbHMvPiwgPGF1ZGlvIGNvbnRyb2xzLz4gYW5kIDx2aWRlbyBjb250cm9scy8+IGVsZW1lbnRzIGdldCBhIGRlZmF1bHRcbiAgICAvLyBgdGFiSW5kZXhgIG9mIC0xIHdoZW4gdGhlICd0YWJpbmRleCcgYXR0cmlidXRlIGlzbid0IHNwZWNpZmllZCBpbiB0aGUgRE9NLFxuICAgIC8vIHlldCB0aGV5IGFyZSBzdGlsbCBwYXJ0IG9mIHRoZSByZWd1bGFyIHRhYiBvcmRlcjsgaW4gRkYsIHRoZXkgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgMDsgc2luY2UgQ2hyb21lIHN0aWxsIHB1dHMgdGhvc2UgZWxlbWVudHMgaW4gdGhlIHJlZ3VsYXIgdGFiXG4gICAgLy8gb3JkZXIsIGNvbnNpZGVyIHRoZWlyIHRhYiBpbmRleCB0byBiZSAwLlxuICAgIC8vIEFsc28gYnJvd3NlcnMgZG8gbm90IHJldHVybiBgdGFiSW5kZXhgIGNvcnJlY3RseSBmb3IgY29udGVudEVkaXRhYmxlIG5vZGVzO1xuICAgIC8vIHNvIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHRhYmluZGV4IGF0dHJpYnV0ZSBzcGVjaWZpY2FsbHkgc2V0LCBhc3N1bWUgaXQncyAwLlxuICAgIC8vXG4gICAgLy8gaXNTY29wZSBpcyBwb3NpdGl2ZSBmb3IgY3VzdG9tIGVsZW1lbnQgd2l0aCBzaGFkb3cgcm9vdCBvciBzbG90IHRoYXQgYnkgZGVmYXVsdFxuICAgIC8vIGhhdmUgdGFiSW5kZXggLTEsIGJ1dCBuZWVkIHRvIGJlIHNvcnRlZCBieSBkb2N1bWVudCBvcmRlciBpbiBvcmRlciBmb3IgdGhlaXJcbiAgICAvLyBjb250ZW50IHRvIGJlIGluc2VydGVkIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uXG4gICAgaWYgKChpc1Njb3BlIHx8IC9eKEFVRElPfFZJREVPfERFVEFJTFMpJC8udGVzdChub2RlLnRhZ05hbWUpIHx8IG5vZGUuaXNDb250ZW50RWRpdGFibGUpICYmIGlzTmFOKHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCkpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZS50YWJJbmRleDtcbn07XG5cbnZhciBzb3J0T3JkZXJlZFRhYmJhYmxlcyA9IGZ1bmN0aW9uIHNvcnRPcmRlcmVkVGFiYmFibGVzKGEsIGIpIHtcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXIgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn07XG5cbnZhciBpc0lucHV0ID0gZnVuY3Rpb24gaXNJbnB1dChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdJTlBVVCc7XG59O1xuXG52YXIgaXNIaWRkZW5JbnB1dCA9IGZ1bmN0aW9uIGlzSGlkZGVuSW5wdXQobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdoaWRkZW4nO1xufTtcblxudmFyIGlzRGV0YWlsc1dpdGhTdW1tYXJ5ID0gZnVuY3Rpb24gaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkge1xuICB2YXIgciA9IG5vZGUudGFnTmFtZSA9PT0gJ0RFVEFJTFMnICYmIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlLmNoaWxkcmVuKS5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC50YWdOYW1lID09PSAnU1VNTUFSWSc7XG4gIH0pO1xuICByZXR1cm4gcjtcbn07XG5cbnZhciBnZXRDaGVja2VkUmFkaW8gPSBmdW5jdGlvbiBnZXRDaGVja2VkUmFkaW8obm9kZXMsIGZvcm0pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkICYmIG5vZGVzW2ldLmZvcm0gPT09IGZvcm0pIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpc1RhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiBpc1RhYmJhYmxlUmFkaW8obm9kZSkge1xuICBpZiAoIW5vZGUubmFtZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHJhZGlvU2NvcGUgPSBub2RlLmZvcm0gfHwgZ2V0Um9vdE5vZGUobm9kZSk7XG5cbiAgdmFyIHF1ZXJ5UmFkaW9zID0gZnVuY3Rpb24gcXVlcnlSYWRpb3MobmFtZSkge1xuICAgIHJldHVybiByYWRpb1Njb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJyk7XG4gIH07XG5cbiAgdmFyIHJhZGlvU2V0O1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkNTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLCBlcnIubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoZWNrZWQgPSBnZXRDaGVja2VkUmFkaW8ocmFkaW9TZXQsIG5vZGUuZm9ybSk7XG4gIHJldHVybiAhY2hlY2tlZCB8fCBjaGVja2VkID09PSBub2RlO1xufTtcblxudmFyIGlzUmFkaW8gPSBmdW5jdGlvbiBpc1JhZGlvKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAncmFkaW8nO1xufTtcblxudmFyIGlzTm9uVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIHJldHVybiBpc1JhZGlvKG5vZGUpICYmICFpc1RhYmJhYmxlUmFkaW8obm9kZSk7XG59O1xuXG52YXIgaXNaZXJvQXJlYSA9IGZ1bmN0aW9uIGlzWmVyb0FyZWEobm9kZSkge1xuICB2YXIgX25vZGUkZ2V0Qm91bmRpbmdDbGllID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHdpZHRoID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwO1xufTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gaXNIaWRkZW4obm9kZSwgX3JlZikge1xuICB2YXIgZGlzcGxheUNoZWNrID0gX3JlZi5kaXNwbGF5Q2hlY2ssXG4gICAgICBnZXRTaGFkb3dSb290ID0gX3JlZi5nZXRTaGFkb3dSb290O1xuXG4gIC8vIE5PVEU6IHZpc2liaWxpdHkgd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBub2RlIGlzIGRldGFjaGVkIGZyb20gdGhlIGRvY3VtZW50XG4gIC8vICAoc2VlIG5vdGVzIGFib3V0IHRoaXMgZnVydGhlciBkb3duKSwgd2hpY2ggbWVhbnMgd2Ugd2lsbCBjb25zaWRlciBpdCB2aXNpYmxlXG4gIC8vICAodGhpcyBpcyBsZWdhY3kgYmVoYXZpb3IgZnJvbSBhIHZlcnkgbG9uZyB3YXkgYmFjaylcbiAgLy8gTk9URTogd2UgY2hlY2sgdGhpcyByZWdhcmRsZXNzIG9mIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIGJlY2F1c2UgdGhpcyBpcyBhXG4gIC8vICBfdmlzaWJpbGl0eV8gY2hlY2ssIG5vdCBhIF9kaXNwbGF5XyBjaGVja1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGlzRGlyZWN0U3VtbWFyeSA9IG1hdGNoZXMuY2FsbChub2RlLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnKTtcbiAgdmFyIG5vZGVVbmRlckRldGFpbHMgPSBpc0RpcmVjdFN1bW1hcnkgPyBub2RlLnBhcmVudEVsZW1lbnQgOiBub2RlO1xuXG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZVVuZGVyRGV0YWlscywgJ2RldGFpbHM6bm90KFtvcGVuXSkgKicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVGhlIHJvb3Qgbm9kZSBpcyB0aGUgc2hhZG93IHJvb3QgaWYgdGhlIG5vZGUgaXMgaW4gYSBzaGFkb3cgRE9NOyBzb21lIGRvY3VtZW50IG90aGVyd2lzZVxuICAvLyAgKGJ1dCBOT1QgX3RoZV8gZG9jdW1lbnQ7IHNlZSBzZWNvbmQgJ0lmJyBjb21tZW50IGJlbG93IGZvciBtb3JlKS5cbiAgLy8gSWYgcm9vdE5vZGUgaXMgc2hhZG93IHJvb3QsIGl0J2xsIGhhdmUgYSBob3N0LCB3aGljaCBpcyB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgc2hhZG93XG4gIC8vICBpcyBhdHRhY2hlZCwgYW5kIHRoZSBvbmUgd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIGluIHRoZSBkb2N1bWVudCBvciBub3QgKGJlY2F1c2UgdGhlXG4gIC8vICBzaGFkb3csIGFuZCBhbGwgbm9kZXMgaXQgY29udGFpbnMsIGlzIG5ldmVyIGNvbnNpZGVyZWQgaW4gdGhlIGRvY3VtZW50IHNpbmNlIHNoYWRvd3NcbiAgLy8gIGJlaGF2ZSBsaWtlIHNlbGYtY29udGFpbmVkIERPTXM7IGJ1dCBpZiB0aGUgc2hhZG93J3MgSE9TVCwgd2hpY2ggaXMgcGFydCBvZiB0aGUgZG9jdW1lbnQsXG4gIC8vICBpcyBoaWRkZW4sIG9yIGlzIG5vdCBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmIGJ1dCBpcyBkZXRhY2hlZCwgaXQgd2lsbCBhZmZlY3QgdGhlIHNoYWRvdydzXG4gIC8vICB2aXNpYmlsaXR5LCBpbmNsdWRpbmcgYWxsIHRoZSBub2RlcyBpdCBjb250YWlucykuIFRoZSBob3N0IGNvdWxkIGJlIGFueSBub3JtYWwgbm9kZSxcbiAgLy8gIG9yIGEgY3VzdG9tIGVsZW1lbnQgKGkuZS4gd2ViIGNvbXBvbmVudCkuIEVpdGhlciB3YXksIHRoYXQncyB0aGUgb25lIHRoYXQgaXMgY29uc2lkZXJlZFxuICAvLyAgcGFydCBvZiB0aGUgZG9jdW1lbnQsIG5vdCB0aGUgc2hhZG93IHJvb3QsIG5vciBhbnkgb2YgaXRzIGNoaWxkcmVuIChpLmUuIHRoZSBub2RlIGJlaW5nXG4gIC8vICB0ZXN0ZWQpLlxuICAvLyBJZiByb290Tm9kZSBpcyBub3QgYSBzaGFkb3cgcm9vdCwgaXQgd29uJ3QgaGF2ZSBhIGhvc3QsIGFuZCBzbyByb290Tm9kZSBzaG91bGQgYmUgdGhlXG4gIC8vICBkb2N1bWVudCAocGVyIHRoZSBkb2NzKSBhbmQgd2hpbGUgaXQncyBhIERvY3VtZW50LXR5cGUgb2JqZWN0LCB0aGF0IGRvY3VtZW50IGRvZXMgbm90XG4gIC8vICBhcHBlYXIgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG5vZGUncyBgb3duZXJEb2N1bWVudGAgZm9yIHNvbWUgcmVhc29uLCBzbyBpdCdzIHNhZmVyXG4gIC8vICB0byBpZ25vcmUgdGhlIHJvb3ROb2RlIGF0IHRoaXMgcG9pbnQsIGFuZCB1c2UgYG5vZGUub3duZXJEb2N1bWVudGAuIE90aGVyd2lzZSxcbiAgLy8gIHVzaW5nIGByb290Tm9kZS5jb250YWlucyhub2RlKWAgd2lsbCBfYWx3YXlzXyBiZSB0cnVlIHdlJ2xsIGdldCBmYWxzZS1wb3NpdGl2ZXMgd2hlblxuICAvLyAgbm9kZSBpcyBhY3R1YWxseSBkZXRhY2hlZC5cblxuXG4gIHZhciBub2RlUm9vdEhvc3QgPSBnZXRSb290Tm9kZShub2RlKS5ob3N0O1xuICB2YXIgbm9kZUlzQXR0YWNoZWQgPSAobm9kZVJvb3RIb3N0ID09PSBudWxsIHx8IG5vZGVSb290SG9zdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZVJvb3RIb3N0Lm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZVJvb3RIb3N0KSkgfHwgbm9kZS5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGUpO1xuXG4gIGlmICghZGlzcGxheUNoZWNrIHx8IGRpc3BsYXlDaGVjayA9PT0gJ2Z1bGwnKSB7XG4gICAgaWYgKHR5cGVvZiBnZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBmaWd1cmUgb3V0IGlmIHdlIHNob3VsZCBjb25zaWRlciB0aGUgbm9kZSB0byBiZSBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgYW5kIHVzZSB0aGVcbiAgICAgIC8vICAnbm9uLXplcm8tYXJlYScgZmFsbGJhY2tcbiAgICAgIHZhciBvcmlnaW5hbE5vZGUgPSBub2RlO1xuXG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgdmFyIHJvb3ROb2RlID0gZ2V0Um9vdE5vZGUobm9kZSk7XG5cbiAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQgJiYgIXBhcmVudEVsZW1lbnQuc2hhZG93Um9vdCAmJiBnZXRTaGFkb3dSb290KHBhcmVudEVsZW1lbnQpID09PSB0cnVlIC8vIGNoZWNrIGlmIHRoZXJlJ3MgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5vZGUgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyB3aGljaCBtZWFucyB3ZSBjYW4gb25seSB0cmVhdCBpdCBhcyBhIGJsYWNrIGJveCwgc28gd2VcbiAgICAgICAgICAvLyAgZmFsbCBiYWNrIHRvIGEgbm9uLXplcm8tYXJlYSB0ZXN0XG4gICAgICAgICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIHNsb3RcbiAgICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmVudEVsZW1lbnQgJiYgcm9vdE5vZGUgIT09IG5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgIC8vIGNyb3NzIHNoYWRvdyBib3VuZGFyeVxuICAgICAgICAgIG5vZGUgPSByb290Tm9kZS5ob3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgbm9ybWFsIGRvbVxuICAgICAgICAgIG5vZGUgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBvcmlnaW5hbE5vZGU7XG4gICAgfSAvLyBlbHNlLCBgZ2V0U2hhZG93Um9vdGAgbWlnaHQgYmUgdHJ1ZSwgYnV0IGFsbCB0aGF0IGRvZXMgaXMgZW5hYmxlIHNoYWRvdyBET00gc3VwcG9ydFxuICAgIC8vICAoaS5lLiBpdCBkb2VzIG5vdCBhbHNvIHByZXN1bWUgdGhhdCBhbGwgbm9kZXMgbWlnaHQgaGF2ZSB1bmRpc2Nsb3NlZCBzaGFkb3dzKTsgb3JcbiAgICAvLyAgaXQgbWlnaHQgYmUgYSBmYWxzeSB2YWx1ZSwgd2hpY2ggbWVhbnMgc2hhZG93IERPTSBzdXBwb3J0IGlzIGRpc2FibGVkXG4gICAgLy8gU2luY2Ugd2UgZGlkbid0IGZpbmQgaXQgc2l0dGluZyBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgKG9yIHNoYWRvd3MgYXJlIGRpc2FibGVkKVxuICAgIC8vICBub3cgd2UgY2FuIGp1c3QgdGVzdCB0byBzZWUgaWYgaXQgd291bGQgbm9ybWFsbHkgYmUgdmlzaWJsZSBvciBub3QsIHByb3ZpZGVkIGl0J3NcbiAgICAvLyAgYXR0YWNoZWQgdG8gdGhlIG1haW4gZG9jdW1lbnQuXG4gICAgLy8gTk9URTogV2UgbXVzdCBjb25zaWRlciBjYXNlIHdoZXJlIG5vZGUgaXMgaW5zaWRlIGEgc2hhZG93IERPTSBhbmQgZ2l2ZW4gZGlyZWN0bHkgdG9cbiAgICAvLyAgYGlzVGFiYmFibGUoKWAgb3IgYGlzRm9jdXNhYmxlKClgIC0tIHJlZ2FyZGxlc3Mgb2YgYGdldFNoYWRvd1Jvb3RgIG9wdGlvbiBzZXR0aW5nLlxuXG5cbiAgICBpZiAobm9kZUlzQXR0YWNoZWQpIHtcbiAgICAgIC8vIHRoaXMgd29ya3Mgd2hlcmV2ZXIgdGhlIG5vZGUgaXM6IGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGNsaWVudCByZWN0LCBpdCdzXG4gICAgICAvLyAgc29tZWhvdyBkaXNwbGF5ZWQ7IGl0IGFsc28gY292ZXJzIHRoZSBDU1MgJ2Rpc3BsYXk6IGNvbnRlbnRzJyBjYXNlIHdoZXJlIHRoZVxuICAgICAgLy8gIG5vZGUgaXRzZWxmIGlzIGhpZGRlbiBpbiBwbGFjZSBvZiBpdHMgY29udGVudHM7IGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoXG4gICAgICAvLyAgdXAgdGhlIGhpZXJhcmNoeSBlaXRoZXJcbiAgICAgIHJldHVybiAhbm9kZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aDtcbiAgICB9IC8vIEVsc2UsIHRoZSBub2RlIGlzbid0IGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhlIGBnZXRDbGllbnRSZWN0cygpYFxuICAgIC8vICBBUEkgd2lsbCBfX2Fsd2F5c19fIHJldHVybiB6ZXJvIHJlY3RzICh0aGlzIGNhbiBoYXBwZW4sIGZvciBleGFtcGxlLCBpZiBSZWFjdFxuICAgIC8vICBpcyB1c2VkIHRvIHJlbmRlciBub2RlcyBvbnRvIGEgZGV0YWNoZWQgdHJlZSwgYXMgY29uZmlybWVkIGluIHRoaXMgdGhyZWFkOlxuICAgIC8vICBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzkxMTcjaXNzdWVjb21tZW50LTI4NDIyODg3MClcbiAgICAvL1xuICAgIC8vIEl0IGFsc28gbWVhbnMgdGhhdCBldmVuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLmRpc3BsYXkgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAvLyAgYmVjYXVzZSBzdHlsZXMgYXJlIG9ubHkgY29tcHV0ZWQgZm9yIG5vZGVzIHRoYXQgYXJlIGluIHRoZSBkb2N1bWVudC5cbiAgICAvL1xuICAgIC8vIE5PVEU6IFRISVMgSEFTIEJFRU4gVEhFIENBU0UgRk9SIFlFQVJTLiBJdCBpcyBub3QgbmV3LCBub3IgaXMgaXQgY2F1c2VkIGJ5IHRhYmJhYmxlXG4gICAgLy8gIHNvbWVob3cuIFRob3VnaCBpdCB3YXMgbmV2ZXIgc3RhdGVkIG9mZmljaWFsbHksIGFueW9uZSB3aG8gaGFzIGV2ZXIgdXNlZCB0YWJiYWJsZVxuICAgIC8vICBBUElzIG9uIG5vZGVzIGluIGRldGFjaGVkIGNvbnRhaW5lcnMgaGFzIGFjdHVhbGx5IGltcGxpY2l0bHkgdXNlZCB0YWJiYWJsZSBpbiB3aGF0XG4gICAgLy8gIHdhcyBsYXRlciAoYXMgb2YgdjUuMi4wIG9uIEFwciA5LCAyMDIxKSBjYWxsZWQgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgbW9kZSAtLSBlc3NlbnRpYWxseVxuICAgIC8vICBjb25zaWRlcmluZyBfX2V2ZXJ5dGhpbmdfXyB0byBiZSB2aXNpYmxlIGJlY2F1c2Ugb2YgdGhlIGlubmFiaWxpdHkgdG8gZGV0ZXJtaW5lIHN0eWxlcy5cblxuICB9IGVsc2UgaWYgKGRpc3BsYXlDaGVjayA9PT0gJ25vbi16ZXJvLWFyZWEnKSB7XG4gICAgLy8gTk9URTogRXZlbiB0aG91Z2ggdGhpcyB0ZXN0cyB0aGF0IHRoZSBub2RlJ3MgY2xpZW50IHJlY3QgaXMgbm9uLXplcm8gdG8gZGV0ZXJtaW5lXG4gICAgLy8gIHdoZXRoZXIgaXQncyBkaXNwbGF5ZWQsIGFuZCB0aGF0IGEgZGV0YWNoZWQgbm9kZSB3aWxsIF9fYWx3YXlzX18gaGF2ZSBhIHplcm8tYXJlYVxuICAgIC8vICBjbGllbnQgcmVjdCwgd2UgZG9uJ3Qgc3BlY2lhbC1jYXNlIGZvciB3aGV0aGVyIHRoZSBub2RlIGlzIGF0dGFjaGVkIG9yIG5vdC4gSW5cbiAgICAvLyAgdGhpcyBtb2RlLCB3ZSBkbyB3YW50IHRvIGNvbnNpZGVyIG5vZGVzIHRoYXQgaGF2ZSBhIHplcm8gYXJlYSB0byBiZSBoaWRkZW4gYXQgYWxsXG4gICAgLy8gIHRpbWVzLCBhbmQgdGhhdCBpbmNsdWRlcyBhdHRhY2hlZCBvciBub3QuXG4gICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gIH0gLy8gdmlzaWJsZSwgYXMgZmFyIGFzIHdlIGNhbiB0ZWxsLCBvciBwZXIgY3VycmVudCBgZGlzcGxheUNoZWNrYCBtb2RlXG5cblxuICByZXR1cm4gZmFsc2U7XG59OyAvLyBmb3JtIGZpZWxkcyAobmVzdGVkKSBpbnNpZGUgYSBkaXNhYmxlZCBmaWVsZHNldCBhcmUgbm90IGZvY3VzYWJsZS90YWJiYWJsZVxuLy8gIHVubGVzcyB0aGV5IGFyZSBpbiB0aGUgX2ZpcnN0XyA8bGVnZW5kPiBlbGVtZW50IG9mIHRoZSB0b3AtbW9zdCBkaXNhYmxlZFxuLy8gIGZpZWxkc2V0XG5cblxudmFyIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQgPSBmdW5jdGlvbiBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpIHtcbiAgaWYgKC9eKElOUFVUfEJVVFRPTnxTRUxFQ1R8VEVYVEFSRUEpJC8udGVzdChub2RlLnRhZ05hbWUpKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7IC8vIGNoZWNrIGlmIGBub2RlYCBpcyBjb250YWluZWQgaW4gYSBkaXNhYmxlZCA8ZmllbGRzZXQ+XG5cbiAgICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgICAgaWYgKHBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ0ZJRUxEU0VUJyAmJiBwYXJlbnROb2RlLmRpc2FibGVkKSB7XG4gICAgICAgIC8vIGxvb2sgZm9yIHRoZSBmaXJzdCA8bGVnZW5kPiBhbW9uZyB0aGUgY2hpbGRyZW4gb2YgdGhlIGRpc2FibGVkIDxmaWVsZHNldD5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pdGVtKGkpOyAvLyB3aGVuIHRoZSBmaXJzdCA8bGVnZW5kPiAoaW4gZG9jdW1lbnQgb3JkZXIpIGlzIGZvdW5kXG5cbiAgICAgICAgICBpZiAoY2hpbGQudGFnTmFtZSA9PT0gJ0xFR0VORCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0cyBwYXJlbnQgPGZpZWxkc2V0PiBpcyBub3QgbmVzdGVkIGluIGFub3RoZXIgZGlzYWJsZWQgPGZpZWxkc2V0PixcbiAgICAgICAgICAgIC8vIHJldHVybiB3aGV0aGVyIGBub2RlYCBpcyBhIGRlc2NlbmRhbnQgb2YgaXRzIGZpcnN0IDxsZWdlbmQ+XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcy5jYWxsKHBhcmVudE5vZGUsICdmaWVsZHNldFtkaXNhYmxlZF0gKicpID8gdHJ1ZSA6ICFjaGlsZC5jb250YWlucyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdGhlIGRpc2FibGVkIDxmaWVsZHNldD4gY29udGFpbmluZyBgbm9kZWAgaGFzIG5vIDxsZWdlbmQ+XG5cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH0gLy8gZWxzZSwgbm9kZSdzIHRhYmJhYmxlL2ZvY3VzYWJsZSBzdGF0ZSBzaG91bGQgbm90IGJlIGFmZmVjdGVkIGJ5IGEgZmllbGRzZXQnc1xuICAvLyAgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUgPSBmdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpIHtcbiAgaWYgKG5vZGUuZGlzYWJsZWQgfHwgaXNIaWRkZW5JbnB1dChub2RlKSB8fCBpc0hpZGRlbihub2RlLCBvcHRpb25zKSB8fCAvLyBGb3IgYSBkZXRhaWxzIGVsZW1lbnQgd2l0aCBhIHN1bW1hcnksIHRoZSBzdW1tYXJ5IGVsZW1lbnQgZ2V0cyB0aGUgZm9jdXNcbiAgaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkgfHwgaXNEaXNhYmxlZEZyb21GaWVsZHNldChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKSB7XG4gIGlmIChpc05vblRhYmJhYmxlUmFkaW8obm9kZSkgfHwgZ2V0VGFiaW5kZXgobm9kZSkgPCAwIHx8ICFpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUoc2hhZG93SG9zdE5vZGUpIHtcbiAgdmFyIHRhYkluZGV4ID0gcGFyc2VJbnQoc2hhZG93SG9zdE5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG5cbiAgaWYgKGlzTmFOKHRhYkluZGV4KSB8fCB0YWJJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSWYgYSBjdXN0b20gZWxlbWVudCBoYXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgdGFiaW5kZXgsXG4gIC8vIGJyb3dzZXJzIHdpbGwgbm90IGFsbG93IHRhYiB0YXJnZXRpbmcgc2FpZCBlbGVtZW50J3MgY2hpbGRyZW4uXG5cblxuICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZXNTY29wZT59IGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIEVsZW1lbnRbXVxuICovXG5cblxudmFyIHNvcnRCeU9yZGVyID0gZnVuY3Rpb24gc29ydEJ5T3JkZXIoY2FuZGlkYXRlcykge1xuICB2YXIgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICB2YXIgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuICBjYW5kaWRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICB2YXIgaXNTY29wZSA9ICEhaXRlbS5zY29wZTtcbiAgICB2YXIgZWxlbWVudCA9IGlzU2NvcGUgPyBpdGVtLnNjb3BlIDogaXRlbTtcbiAgICB2YXIgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRUYWJpbmRleChlbGVtZW50LCBpc1Njb3BlKTtcbiAgICB2YXIgZWxlbWVudHMgPSBpc1Njb3BlID8gc29ydEJ5T3JkZXIoaXRlbS5jYW5kaWRhdGVzKSA6IGVsZW1lbnQ7XG5cbiAgICBpZiAoY2FuZGlkYXRlVGFiaW5kZXggPT09IDApIHtcbiAgICAgIGlzU2NvcGUgPyByZWd1bGFyVGFiYmFibGVzLnB1c2guYXBwbHkocmVndWxhclRhYmJhYmxlcywgZWxlbWVudHMpIDogcmVndWxhclRhYmJhYmxlcy5wdXNoKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxuICAgICAgICB0YWJJbmRleDogY2FuZGlkYXRlVGFiaW5kZXgsXG4gICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgIGlzU2NvcGU6IGlzU2NvcGUsXG4gICAgICAgIGNvbnRlbnQ6IGVsZW1lbnRzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3JkZXJlZFRhYmJhYmxlcy5zb3J0KHNvcnRPcmRlcmVkVGFiYmFibGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc29ydGFibGUpIHtcbiAgICBzb3J0YWJsZS5pc1Njb3BlID8gYWNjLnB1c2guYXBwbHkoYWNjLCBzb3J0YWJsZS5jb250ZW50KSA6IGFjYy5wdXNoKHNvcnRhYmxlLmNvbnRlbnQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKS5jb25jYXQocmVndWxhclRhYmJhYmxlcyk7XG59O1xuXG52YXIgdGFiYmFibGUgPSBmdW5jdGlvbiB0YWJiYWJsZShlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNhbmRpZGF0ZXM7XG5cbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogZmFsc2UsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgICBzaGFkb3dSb290RmlsdGVyOiBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoZWwsIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICB9XG5cbiAgcmV0dXJuIHNvcnRCeU9yZGVyKGNhbmRpZGF0ZXMpO1xufTtcblxudmFyIGZvY3VzYWJsZSA9IGZ1bmN0aW9uIGZvY3VzYWJsZShlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNhbmRpZGF0ZXM7XG5cbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3RcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhlbCwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICB9XG5cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG52YXIgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVGFiYmFibGUobm9kZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuXG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgY2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG52YXIgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi9jYW5kaWRhdGVTZWxlY3RvcnMuY29uY2F0KCdpZnJhbWUnKS5qb2luKCcsJyk7XG5cbnZhciBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIGlzRm9jdXNhYmxlKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cblxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmV4cG9ydCB7IGZvY3VzYWJsZSwgaXNGb2N1c2FibGUsIGlzVGFiYmFibGUsIHRhYmJhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tabbable/dist/index.esm.js\n"));

/***/ }),

/***/ "./node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"arrow\": function() { return /* binding */ arrow; },\n/* harmony export */   \"autoPlacement\": function() { return /* binding */ autoPlacement; },\n/* harmony export */   \"computePosition\": function() { return /* binding */ computePosition; },\n/* harmony export */   \"detectOverflow\": function() { return /* binding */ detectOverflow; },\n/* harmony export */   \"flip\": function() { return /* binding */ flip; },\n/* harmony export */   \"hide\": function() { return /* binding */ hide; },\n/* harmony export */   \"inline\": function() { return /* binding */ inline; },\n/* harmony export */   \"limitShift\": function() { return /* binding */ limitShift; },\n/* harmony export */   \"offset\": function() { return /* binding */ offset; },\n/* harmony export */   \"rectToClientRect\": function() { return /* binding */ rectToClientRect; },\n/* harmony export */   \"shift\": function() { return /* binding */ shift; },\n/* harmony export */   \"size\": function() { return /* binding */ size; }\n/* harmony export */ });\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    {\n      if (resetCount > 50) {\n        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n      }\n    }\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const alignment = getAlignment(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max); // Make sure that arrow points at the reference\n\n    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];\n    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset({ ...rects,\n        placement\n      }) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply,\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      const prevDimensions = await platform.getDimensions(elements.floating);\n      apply == null ? void 0 : apply({ ...middlewareArguments,\n        ...dimensions\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n\n      if (prevDimensions.width !== nextDimensions.width || prevDimensions.height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLmJyb3dzZXIubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJIQUEySDs7QUFFbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDBEQUEwRDs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLE9BQU87QUFDUCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUIseUJBQXlCLEtBQUs7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUV3SSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLmJyb3dzZXIubWpzP2U0NDkiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuXG5mdW5jdGlvbiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKSA/ICd4JyA6ICd5Jztcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoRnJvbUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChfcmVmLCBwbGFjZW1lbnQsIHJ0bCkge1xuICBsZXQge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZ1xuICB9ID0gX3JlZjtcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRMZW5ndGhGcm9tQXhpcyhtYWluQXhpcyk7XG4gIGNvbnN0IGNvbW1vbkFsaWduID0gcmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gZmxvYXRpbmdbbGVuZ3RoXSAvIDI7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBtYWluQXhpcyA9PT0gJ3gnO1xuICBsZXQgY29vcmRzO1xuXG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZmxvYXRpbmcuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGZsb2F0aW5nLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICBzd2l0Y2ggKGdldEFsaWdubWVudChwbGFjZW1lbnQpKSB7XG4gICAgY2FzZSAnc3RhcnQnOlxuICAgICAgY29vcmRzW21haW5BeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2VuZCc6XG4gICAgICBjb29yZHNbbWFpbkF4aXNdICs9IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGNvb3Jkcztcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgcmVmZXJlbmNlIGVsZW1lbnQgd2hlbiBpdCBpcyBnaXZlbiBhIGNlcnRhaW4gcG9zaXRpb25pbmcgc3RyYXRlZ3kuXG4gKlxuICogVGhpcyBleHBvcnQgZG9lcyBub3QgaGF2ZSBhbnkgYHBsYXRmb3JtYCBpbnRlcmZhY2UgbG9naWMuIFlvdSB3aWxsIG5lZWQgdG9cbiAqIHdyaXRlIG9uZSBmb3IgdGhlIHBsYXRmb3JtIHlvdSBhcmUgdXNpbmcgRmxvYXRpbmcgVUkgd2l0aC5cbiAqL1xuXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSBhc3luYyAocmVmZXJlbmNlLCBmbG9hdGluZywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpKTtcblxuICB7XG4gICAgaWYgKHBsYXRmb3JtID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydGbG9hdGluZyBVSTogYHBsYXRmb3JtYCBwcm9wZXJ0eSB3YXMgbm90IHBhc3NlZCB0byBjb25maWcuIElmIHlvdScsICd3YW50IHRvIHVzZSBGbG9hdGluZyBVSSBvbiB0aGUgd2ViLCBpbnN0YWxsIEBmbG9hdGluZy11aS9kb20nLCAnaW5zdGVhZCBvZiB0aGUgL2NvcmUgcGFja2FnZS4gT3RoZXJ3aXNlLCB5b3UgY2FuIGNyZWF0ZSB5b3VyIG93bicsICdgcGxhdGZvcm1gOiBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3BsYXRmb3JtJ10uam9pbignICcpKTtcbiAgICB9XG5cbiAgICBpZiAobWlkZGxld2FyZS5maWx0ZXIoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBuYW1lXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiBuYW1lID09PSAnYXV0b1BsYWNlbWVudCcgfHwgbmFtZSA9PT0gJ2ZsaXAnO1xuICAgIH0pLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbJ0Zsb2F0aW5nIFVJOiBkdXBsaWNhdGUgYGZsaXBgIGFuZC9vciBgYXV0b1BsYWNlbWVudGAnLCAnbWlkZGxld2FyZSBkZXRlY3RlZC4gVGhpcyB3aWxsIGxlYWQgdG8gYW4gaW5maW5pdGUgbG9vcC4gRW5zdXJlIG9ubHknLCAnb25lIG9mIGVpdGhlciBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIGBtaWRkbGV3YXJlYCBhcnJheS4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIHN0cmF0ZWd5XG4gIH0pO1xuICBsZXQge1xuICAgIHgsXG4gICAgeVxuICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHBsYWNlbWVudCwgcnRsKTtcbiAgbGV0IHN0YXRlZnVsUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICBsZXQgbWlkZGxld2FyZURhdGEgPSB7fTtcbiAgbGV0IHJlc2V0Q291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWlkZGxld2FyZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBmblxuICAgIH0gPSBtaWRkbGV3YXJlW2ldO1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IG5leHRYLFxuICAgICAgeTogbmV4dFksXG4gICAgICBkYXRhLFxuICAgICAgcmVzZXRcbiAgICB9ID0gYXdhaXQgZm4oe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBpbml0aWFsUGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgICAgc3RyYXRlZ3ksXG4gICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgIHJlY3RzLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSk7XG4gICAgeCA9IG5leHRYICE9IG51bGwgPyBuZXh0WCA6IHg7XG4gICAgeSA9IG5leHRZICE9IG51bGwgPyBuZXh0WSA6IHk7XG4gICAgbWlkZGxld2FyZURhdGEgPSB7IC4uLm1pZGRsZXdhcmVEYXRhLFxuICAgICAgW25hbWVdOiB7IC4uLm1pZGRsZXdhcmVEYXRhW25hbWVdLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9XG4gICAgfTtcblxuICAgIHtcbiAgICAgIGlmIChyZXNldENvdW50ID4gNTApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFsnRmxvYXRpbmcgVUk6IFRoZSBtaWRkbGV3YXJlIGxpZmVjeWNsZSBhcHBlYXJzIHRvIGJlIHJ1bm5pbmcgaW4gYW4nLCAnaW5maW5pdGUgbG9vcC4gVGhpcyBpcyB1c3VhbGx5IGNhdXNlZCBieSBhIGByZXNldGAgY29udGludWFsbHknLCAnYmVpbmcgcmV0dXJuZWQgd2l0aG91dCBhIGJyZWFrIGNvbmRpdGlvbi4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXNldCAmJiByZXNldENvdW50IDw9IDUwKSB7XG4gICAgICByZXNldENvdW50Kys7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChyZXNldC5wbGFjZW1lbnQpIHtcbiAgICAgICAgICBzdGF0ZWZ1bFBsYWNlbWVudCA9IHJlc2V0LnBsYWNlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNldC5yZWN0cykge1xuICAgICAgICAgIHJlY3RzID0gcmVzZXQucmVjdHMgPT09IHRydWUgPyBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgZmxvYXRpbmcsXG4gICAgICAgICAgICBzdHJhdGVneVxuICAgICAgICAgIH0pIDogcmVzZXQucmVjdHM7XG4gICAgICAgIH1cblxuICAgICAgICAoe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHN0YXRlZnVsUGxhY2VtZW50LCBydGwpKTtcbiAgICAgIH1cblxuICAgICAgaSA9IC0xO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICBzdHJhdGVneSxcbiAgICBtaWRkbGV3YXJlRGF0YVxuICB9O1xufTtcblxuZnVuY3Rpb24gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIC4uLnBhZGRpbmdcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2lkZU9iamVjdEZyb21QYWRkaW5nKHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykgOiB7XG4gICAgdG9wOiBwYWRkaW5nLFxuICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICBsZWZ0OiBwYWRkaW5nXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4geyAuLi5yZWN0LFxuICAgIHRvcDogcmVjdC55LFxuICAgIGxlZnQ6IHJlY3QueCxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIG9wdGlvbnMpIHtcbiAgdmFyIF9hd2FpdCRwbGF0Zm9ybSRpc0VsZTtcblxuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGF0Zm9ybSxcbiAgICByZWN0cyxcbiAgICBlbGVtZW50cyxcbiAgICBzdHJhdGVneVxuICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgY29uc3Qge1xuICAgIGJvdW5kYXJ5ID0gJ2NsaXBwaW5nQW5jZXN0b3JzJyxcbiAgICByb290Qm91bmRhcnkgPSAndmlld3BvcnQnLFxuICAgIGVsZW1lbnRDb250ZXh0ID0gJ2Zsb2F0aW5nJyxcbiAgICBhbHRCb3VuZGFyeSA9IGZhbHNlLFxuICAgIHBhZGRpbmcgPSAwXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0U2lkZU9iamVjdEZyb21QYWRkaW5nKHBhZGRpbmcpO1xuICBjb25zdCBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyAncmVmZXJlbmNlJyA6ICdmbG9hdGluZyc7XG4gIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIGNvbnN0IGNsaXBwaW5nQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoYXdhaXQgcGxhdGZvcm0uZ2V0Q2xpcHBpbmdSZWN0KHtcbiAgICBlbGVtZW50OiAoKF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA9IGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChlbGVtZW50KSkpICE9IG51bGwgPyBfYXdhaXQkcGxhdGZvcm0kaXNFbGUgOiB0cnVlKSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IChhd2FpdCAocGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpKSksXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0pKTtcbiAgY29uc3QgZWxlbWVudENsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8gYXdhaXQgcGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgIHJlY3Q6IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8geyAuLi5yZWN0cy5mbG9hdGluZyxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA6IHJlY3RzLnJlZmVyZW5jZSxcbiAgICBvZmZzZXRQYXJlbnQ6IGF3YWl0IChwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldE9mZnNldFBhcmVudChlbGVtZW50cy5mbG9hdGluZykpLFxuICAgIHN0cmF0ZWd5XG4gIH0pIDogcmVjdHNbZWxlbWVudENvbnRleHRdKTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xufVxuXG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuXG5mdW5jdGlvbiB3aXRoaW4obWluJDEsIHZhbHVlLCBtYXgkMSkge1xuICByZXR1cm4gbWF4KG1pbiQxLCBtaW4odmFsdWUsIG1heCQxKSk7XG59XG5cbi8qKlxuICogUG9zaXRpb25zIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc3VjaCB0aGF0IGl0IGlzIGNlbnRlcmVkXG4gKiB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBvcHRpb25zID0+ICh7XG4gIG5hbWU6ICdhcnJvdycsXG4gIG9wdGlvbnMsXG5cbiAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgIC8vIFNpbmNlIGBlbGVtZW50YCBpcyByZXF1aXJlZCwgd2UgZG9uJ3QgUGFydGlhbDw+IHRoZSB0eXBlXG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhZGRpbmcgPSAwXG4gICAgfSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHJlY3RzLFxuICAgICAgcGxhdGZvcm1cbiAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGbG9hdGluZyBVSTogTm8gYGVsZW1lbnRgIHdhcyBwYXNzZWQgdG8gdGhlIGBhcnJvd2AgbWlkZGxld2FyZS4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRTaWRlT2JqZWN0RnJvbVBhZGRpbmcocGFkZGluZyk7XG4gICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICAgIGNvbnN0IGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRMZW5ndGhGcm9tQXhpcyhheGlzKTtcbiAgICBjb25zdCBhcnJvd0RpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnQpO1xuICAgIGNvbnN0IG1pblByb3AgPSBheGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICBjb25zdCBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgIGNvbnN0IGVuZERpZmYgPSByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSArIHJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIGNvb3Jkc1theGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgY29uc3Qgc3RhcnREaWZmID0gY29vcmRzW2F4aXNdIC0gcmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICAgIGNvbnN0IGFycm93T2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpKTtcbiAgICBsZXQgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcblxuICAgIGlmIChjbGllbnRTaXplID09PSAwKSB7XG4gICAgICBjbGllbnRTaXplID0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICB9XG5cbiAgICBjb25zdCBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBmbG9hdGluZyBlbGVtZW50IGlmIHRoZSBjZW50ZXJcbiAgICAvLyBwb2ludCBpcyBvdXRzaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgYm91bmRzXG5cbiAgICBjb25zdCBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICAgIGNvbnN0IG1heCA9IGNsaWVudFNpemUgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gICAgY29uc3QgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgICBjb25zdCBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIE1ha2Ugc3VyZSB0aGF0IGFycm93IHBvaW50cyBhdCB0aGUgcmVmZXJlbmNlXG5cbiAgICBjb25zdCBhbGlnbm1lbnRQYWRkaW5nID0gYWxpZ25tZW50ID09PSAnc3RhcnQnID8gcGFkZGluZ09iamVjdFttaW5Qcm9wXSA6IHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gICAgY29uc3Qgc2hvdWxkQWRkT2Zmc2V0ID0gYWxpZ25tZW50UGFkZGluZyA+IDAgJiYgY2VudGVyICE9PSBvZmZzZXQgJiYgcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gPD0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICBjb25zdCBhbGlnbm1lbnRPZmZzZXQgPSBzaG91bGRBZGRPZmZzZXQgPyBjZW50ZXIgPCBtaW4gPyBtaW4gLSBjZW50ZXIgOiBtYXggLSBjZW50ZXIgOiAwO1xuICAgIHJldHVybiB7XG4gICAgICBbYXhpc106IGNvb3Jkc1theGlzXSAtIGFsaWdubWVudE9mZnNldCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgW2F4aXNdOiBvZmZzZXQsXG4gICAgICAgIGNlbnRlck9mZnNldDogY2VudGVyIC0gb2Zmc2V0XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG59KTtcblxuY29uc3QgaGFzaCQxID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIG1hdGNoZWQgPT4gaGFzaCQxW21hdGNoZWRdKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG5cbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGxlbmd0aCA9IGdldExlbmd0aEZyb21BeGlzKG1haW5BeGlzKTtcbiAgbGV0IG1haW5BbGlnbm1lbnRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGFsaWdubWVudCA9PT0gKHJ0bCA/ICdlbmQnIDogJ3N0YXJ0JykgPyAncmlnaHQnIDogJ2xlZnQnIDogYWxpZ25tZW50ID09PSAnc3RhcnQnID8gJ2JvdHRvbScgOiAndG9wJztcblxuICBpZiAocmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gPiByZWN0cy5mbG9hdGluZ1tsZW5ndGhdKSB7XG4gICAgbWFpbkFsaWdubWVudFNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1haW46IG1haW5BbGlnbm1lbnRTaWRlLFxuICAgIGNyb3NzOiBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSlcbiAgfTtcbn1cblxuY29uc3QgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgbWF0Y2hlZCA9PiBoYXNoW21hdGNoZWRdKTtcbn1cblxuY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxsUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9zaWRlcy5yZWR1Y2UoKGFjYywgc2lkZSkgPT4gYWNjLmNvbmNhdChzaWRlLCBzaWRlICsgXCItc3RhcnRcIiwgc2lkZSArIFwiLWVuZFwiKSwgW10pO1xuXG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIHtcbiAgY29uc3QgYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCA9IGFsaWdubWVudCA/IFsuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQpLCAuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9PSBhbGlnbm1lbnQpXSA6IGFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0U2lkZShwbGFjZW1lbnQpID09PSBwbGFjZW1lbnQpO1xuICByZXR1cm4gYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudC5maWx0ZXIocGxhY2VtZW50ID0+IHtcbiAgICBpZiAoYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCB8fCAoYXV0b0FsaWdubWVudCA/IGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkgIT09IHBsYWNlbWVudCA6IGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogQXV0b21hdGljYWxseSBjaG9vc2VzIHRoZSBgcGxhY2VtZW50YCB3aGljaCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhdXRvUGxhY2VtZW50JyxcbiAgICBvcHRpb25zLFxuXG4gICAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhdXRvUCwgX21pZGRsZXdhcmVEYXRhJGF1dG9QMiwgX21pZGRsZXdhcmVEYXRhJGF1dG9QMywgX21pZGRsZXdhcmVEYXRhJGF1dG9QNCwgX3BsYWNlbWVudHNTb3J0ZWRCeUxlO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBtaWRkbGV3YXJlQXJndW1lbnRzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbGlnbm1lbnQgPSBudWxsLFxuICAgICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IGFsbFBsYWNlbWVudHMsXG4gICAgICAgIGF1dG9BbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3QgcGxhY2VtZW50cyA9IGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50LCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cyk7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSAoX21pZGRsZXdhcmVEYXRhJGF1dG9QID0gKF9taWRkbGV3YXJlRGF0YSRhdXRvUDIgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QMi5pbmRleCkgIT0gbnVsbCA/IF9taWRkbGV3YXJlRGF0YSRhdXRvUCA6IDA7XG4gICAgICBjb25zdCBjdXJyZW50UGxhY2VtZW50ID0gcGxhY2VtZW50c1tjdXJyZW50SW5kZXhdO1xuXG4gICAgICBpZiAoY3VycmVudFBsYWNlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluLFxuICAgICAgICBjcm9zc1xuICAgICAgfSA9IGdldEFsaWdubWVudFNpZGVzKGN1cnJlbnRQbGFjZW1lbnQsIHJlY3RzLCBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkpOyAvLyBNYWtlIGBjb21wdXRlQ29vcmRzYCBzdGFydCBmcm9tIHRoZSByaWdodCBwbGFjZVxuXG4gICAgICBpZiAocGxhY2VtZW50ICE9PSBjdXJyZW50UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudHNbMF1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRPdmVyZmxvd3MgPSBbb3ZlcmZsb3dbZ2V0U2lkZShjdXJyZW50UGxhY2VtZW50KV0sIG92ZXJmbG93W21haW5dLCBvdmVyZmxvd1tjcm9zc11dO1xuICAgICAgY29uc3QgYWxsT3ZlcmZsb3dzID0gWy4uLigoX21pZGRsZXdhcmVEYXRhJGF1dG9QMyA9IChfbWlkZGxld2FyZURhdGEkYXV0b1A0ID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUDQub3ZlcmZsb3dzKSAhPSBudWxsID8gX21pZGRsZXdhcmVEYXRhJGF1dG9QMyA6IFtdKSwge1xuICAgICAgICBwbGFjZW1lbnQ6IGN1cnJlbnRQbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93czogY3VycmVudE92ZXJmbG93c1xuICAgICAgfV07XG4gICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50c1tjdXJyZW50SW5kZXggKyAxXTsgLy8gVGhlcmUgYXJlIG1vcmUgcGxhY2VtZW50cyB0byBjaGVja1xuXG4gICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBsYWNlbWVudHNTb3J0ZWRCeUxlYXN0T3ZlcmZsb3cgPSBhbGxPdmVyZmxvd3Muc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLm92ZXJmbG93c1swXSAtIGIub3ZlcmZsb3dzWzBdKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudFRoYXRGaXRzT25BbGxTaWRlcyA9IChfcGxhY2VtZW50c1NvcnRlZEJ5TGUgPSBwbGFjZW1lbnRzU29ydGVkQnlMZWFzdE92ZXJmbG93LmZpbmQoX3JlZiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgb3ZlcmZsb3dzXG4gICAgICAgIH0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gb3ZlcmZsb3dzLmV2ZXJ5KG92ZXJmbG93ID0+IG92ZXJmbG93IDw9IDApO1xuICAgICAgfSkpID09IG51bGwgPyB2b2lkIDAgOiBfcGxhY2VtZW50c1NvcnRlZEJ5TGUucGxhY2VtZW50O1xuICAgICAgY29uc3QgcmVzZXRQbGFjZW1lbnQgPSBwbGFjZW1lbnRUaGF0Rml0c09uQWxsU2lkZXMgIT0gbnVsbCA/IHBsYWNlbWVudFRoYXRGaXRzT25BbGxTaWRlcyA6IHBsYWNlbWVudHNTb3J0ZWRCeUxlYXN0T3ZlcmZsb3dbMF0ucGxhY2VtZW50O1xuXG4gICAgICBpZiAocmVzZXRQbGFjZW1lbnQgIT09IHBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZFBsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGNvbnN0IG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBwbGFjZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgdG8gb25lIHRoYXQgd2lsbCBmaXQgaWYgdGhlXG4gKiBpbml0aWFsbHkgc3BlY2lmaWVkIGBwbGFjZW1lbnRgIGRvZXMgbm90LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBvcHRpb25zLFxuXG4gICAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBpbml0aWFsUGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBtaWRkbGV3YXJlQXJndW1lbnRzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlLFxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgZmFsbGJhY2tTdHJhdGVneSA9ICdiZXN0Rml0JyxcbiAgICAgICAgZmxpcEFsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNCYXNlUGxhY2VtZW50ID0gc2lkZSA9PT0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwQWxpZ25tZW50ID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KGluaXRpYWxQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50KSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c107XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBvdmVyZmxvd3MgPSBbXTtcbiAgICAgIGxldCBvdmVyZmxvd3NEYXRhID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcC5vdmVyZmxvd3MpIHx8IFtdO1xuXG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBvdmVyZmxvd3MucHVzaChvdmVyZmxvd1tzaWRlXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWFpbixcbiAgICAgICAgICBjcm9zc1xuICAgICAgICB9ID0gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbbWFpbl0sIG92ZXJmbG93W2Nyb3NzXSk7XG4gICAgICB9XG5cbiAgICAgIG92ZXJmbG93c0RhdGEgPSBbLi4ub3ZlcmZsb3dzRGF0YSwge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93c1xuICAgICAgfV07IC8vIE9uZSBvciBtb3JlIHNpZGVzIGlzIG92ZXJmbG93aW5nXG5cbiAgICAgIGlmICghb3ZlcmZsb3dzLmV2ZXJ5KHNpZGUgPT4gc2lkZSA8PSAwKSkge1xuICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGZsaXAkLCBfbWlkZGxld2FyZURhdGEkZmxpcDI7XG5cbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCQgPSAoX21pZGRsZXdhcmVEYXRhJGZsaXAyID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwMi5pbmRleCkgIT0gbnVsbCA/IF9taWRkbGV3YXJlRGF0YSRmbGlwJCA6IDApICsgMTtcbiAgICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHNbbmV4dEluZGV4XTtcblxuICAgICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIFRyeSBuZXh0IHBsYWNlbWVudCBhbmQgcmUtcnVuIHRoZSBsaWZlY3ljbGVcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gJ2JvdHRvbSc7XG5cbiAgICAgICAgc3dpdGNoIChmYWxsYmFja1N0cmF0ZWd5KSB7XG4gICAgICAgICAgY2FzZSAnYmVzdEZpdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfb3ZlcmZsb3dzRGF0YSRtYXAkc287XG5cbiAgICAgICAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJG1hcCRzbyA9IG92ZXJmbG93c0RhdGEubWFwKGQgPT4gW2QsIGQub3ZlcmZsb3dzLmZpbHRlcihvdmVyZmxvdyA9PiBvdmVyZmxvdyA+IDApLnJlZHVjZSgoYWNjLCBvdmVyZmxvdykgPT4gYWNjICsgb3ZlcmZsb3csIDApXSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkbWFwJHNvWzBdLnBsYWNlbWVudDtcblxuICAgICAgICAgICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2luaXRpYWxQbGFjZW1lbnQnOlxuICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQsXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gc2lkZXMuc29tZShzaWRlID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGZ1bmN0aW9uIChfdGVtcCkge1xuICBsZXQge1xuICAgIHN0cmF0ZWd5ID0gJ3JlZmVyZW5jZUhpZGRlbicsXG4gICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaGlkZScsXG5cbiAgICBhc3luYyBmbihtaWRkbGV3YXJlQXJndW1lbnRzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY3RzXG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcblxuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdyZWZlcmVuY2VIaWRkZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3cobWlkZGxld2FyZUFyZ3VtZW50cywgeyAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW46IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvZmZzZXRzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdlc2NhcGVkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIHsgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLmZsb2F0aW5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBlc2NhcGVkOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9O1xufTtcblxuYXN5bmMgZnVuY3Rpb24gY29udmVydFZhbHVlVG9Db29yZHMobWlkZGxld2FyZUFyZ3VtZW50cywgdmFsdWUpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50c1xuICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpID09PSAneCc7XG4gIGNvbnN0IG1haW5BeGlzTXVsdGkgPSBbJ2xlZnQnLCAndG9wJ10uaW5jbHVkZXMoc2lkZSkgPyAtMSA6IDE7XG4gIGNvbnN0IGNyb3NzQXhpc011bHRpID0gcnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDE7XG4gIGNvbnN0IHJhd1ZhbHVlID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUobWlkZGxld2FyZUFyZ3VtZW50cykgOiB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuXG4gIGxldCB7XG4gICAgbWFpbkF4aXMsXG4gICAgY3Jvc3NBeGlzLFxuICAgIGFsaWdubWVudEF4aXNcbiAgfSA9IHR5cGVvZiByYXdWYWx1ZSA9PT0gJ251bWJlcicgPyB7XG4gICAgbWFpbkF4aXM6IHJhd1ZhbHVlLFxuICAgIGNyb3NzQXhpczogMCxcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsXG4gIH0gOiB7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGwsXG4gICAgLi4ucmF3VmFsdWVcbiAgfTtcblxuICBpZiAoYWxpZ25tZW50ICYmIHR5cGVvZiBhbGlnbm1lbnRBeGlzID09PSAnbnVtYmVyJykge1xuICAgIGNyb3NzQXhpcyA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyBhbGlnbm1lbnRBeGlzICogLTEgOiBhbGlnbm1lbnRBeGlzO1xuICB9XG5cbiAgcmV0dXJuIGlzVmVydGljYWwgPyB7XG4gICAgeDogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGksXG4gICAgeTogbWFpbkF4aXMgKiBtYWluQXhpc011bHRpXG4gIH0gOiB7XG4gICAgeDogbWFpbkF4aXMgKiBtYWluQXhpc011bHRpLFxuICAgIHk6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpXG4gIH07XG59XG4vKipcbiAqIERpc3BsYWNlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCBmcm9tIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuXG5jb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICB2YWx1ZSA9IDA7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgIG9wdGlvbnM6IHZhbHVlLFxuXG4gICAgYXN5bmMgZm4obWlkZGxld2FyZUFyZ3VtZW50cykge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgICAgIGNvbnN0IGRpZmZDb29yZHMgPSBhd2FpdCBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhtaWRkbGV3YXJlQXJndW1lbnRzLCB2YWx1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgZGlmZkNvb3Jkcy54LFxuICAgICAgICB5OiB5ICsgZGlmZkNvb3Jkcy55LFxuICAgICAgICBkYXRhOiBkaWZmQ29vcmRzXG4gICAgICB9O1xuICAgIH1cblxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0Q3Jvc3NBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn1cblxuLyoqXG4gKiBTaGlmdHMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvd1xuICogYSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaGlmdCcsXG4gICAgb3B0aW9ucyxcblxuICAgIGFzeW5jIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gZmFsc2UsXG4gICAgICAgIGxpbWl0ZXIgPSB7XG4gICAgICAgICAgZm46IF9yZWYgPT4ge1xuICAgICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3cobWlkZGxld2FyZUFyZ3VtZW50cywgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRDcm9zc0F4aXMobWFpbkF4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG5cbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBtYWluQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IG1haW5BeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgbWFpbkF4aXNDb29yZCA9IHdpdGhpbihtaW4sIG1haW5BeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBjcm9zc0F4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBjcm9zc0F4aXNDb29yZCA9IHdpdGhpbihtaW4sIGNyb3NzQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsaW1pdGVkQ29vcmRzID0gbGltaXRlci5mbih7IC4uLm1pZGRsZXdhcmVBcmd1bWVudHMsXG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyAuLi5saW1pdGVkQ29vcmRzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgeDogbGltaXRlZENvb3Jkcy54IC0geCxcbiAgICAgICAgICB5OiBsaW1pdGVkQ29vcmRzLnkgLSB5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gIH07XG59O1xuXG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcblxuICAgIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBtaWRkbGV3YXJlQXJndW1lbnRzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRDcm9zc0F4aXMobWFpbkF4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBjb25zdCByYXdPZmZzZXQgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KHsgLi4ucmVjdHMsXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSkgOiBvZmZzZXQ7XG4gICAgICBjb25zdCBjb21wdXRlZE9mZnNldCA9IHR5cGVvZiByYXdPZmZzZXQgPT09ICdudW1iZXInID8ge1xuICAgICAgICBtYWluQXhpczogcmF3T2Zmc2V0LFxuICAgICAgICBjcm9zc0F4aXM6IDBcbiAgICAgIH0gOiB7XG4gICAgICAgIG1haW5BeGlzOiAwLFxuICAgICAgICBjcm9zc0F4aXM6IDAsXG4gICAgICAgIC4uLnJhd09mZnNldFxuICAgICAgfTtcblxuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSAtIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuXG4gICAgICAgIGlmIChtYWluQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAobWFpbkF4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkb2Zmc2UyLCBfbWlkZGxld2FyZURhdGEkb2Zmc2UzLCBfbWlkZGxld2FyZURhdGEkb2Zmc2U0O1xuXG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IGlzT3JpZ2luU2lkZSA9IFsndG9wJywgJ2xlZnQnXS5pbmNsdWRlcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIChpc09yaWdpblNpZGUgPyAoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gKF9taWRkbGV3YXJlRGF0YSRvZmZzZTIgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UyW2Nyb3NzQXhpc10pICE9IG51bGwgPyBfbWlkZGxld2FyZURhdGEkb2Zmc2UgOiAwIDogMCkgKyAoaXNPcmlnaW5TaWRlID8gMCA6IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSArIChpc09yaWdpblNpZGUgPyAwIDogKF9taWRkbGV3YXJlRGF0YSRvZmZzZTMgPSAoX21pZGRsZXdhcmVEYXRhJG9mZnNlNCA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZTRbY3Jvc3NBeGlzXSkgIT0gbnVsbCA/IF9taWRkbGV3YXJlRGF0YSRvZmZzZTMgOiAwKSAtIChpc09yaWdpblNpZGUgPyBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMgOiAwKTtcblxuICAgICAgICBpZiAoY3Jvc3NBeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW21haW5BeGlzXTogbWFpbkF4aXNDb29yZCxcbiAgICAgICAgW2Nyb3NzQXhpc106IGNyb3NzQXhpc0Nvb3JkXG4gICAgICB9O1xuICAgIH1cblxuICB9O1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudC4gRm9yIGluc3RhbmNlLFxuICogcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIGl0cyBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGUgd2lkdGggb2YgdGhlXG4gKiByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2l6ZScsXG4gICAgb3B0aW9ucyxcblxuICAgIGFzeW5jIGZuKG1pZGRsZXdhcmVBcmd1bWVudHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gbWlkZGxld2FyZUFyZ3VtZW50cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXBwbHksXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG1pZGRsZXdhcmVBcmd1bWVudHMsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gICAgICBsZXQgaGVpZ2h0U2lkZTtcbiAgICAgIGxldCB3aWR0aFNpZGU7XG5cbiAgICAgIGlmIChzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBoZWlnaHRTaWRlID0gc2lkZTtcbiAgICAgICAgd2lkdGhTaWRlID0gYWxpZ25tZW50ID09PSAoKGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSkgPyAnc3RhcnQnIDogJ2VuZCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoU2lkZSA9IHNpZGU7XG4gICAgICAgIGhlaWdodFNpZGUgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIH1cblxuICAgICAgY29uc3QgeE1pbiA9IG1heChvdmVyZmxvdy5sZWZ0LCAwKTtcbiAgICAgIGNvbnN0IHhNYXggPSBtYXgob3ZlcmZsb3cucmlnaHQsIDApO1xuICAgICAgY29uc3QgeU1pbiA9IG1heChvdmVyZmxvdy50b3AsIDApO1xuICAgICAgY29uc3QgeU1heCA9IG1heChvdmVyZmxvdy5ib3R0b20sIDApO1xuICAgICAgY29uc3QgZGltZW5zaW9ucyA9IHtcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0OiByZWN0cy5mbG9hdGluZy5oZWlnaHQgLSAoWydsZWZ0JywgJ3JpZ2h0J10uaW5jbHVkZXMocGxhY2VtZW50KSA/IDIgKiAoeU1pbiAhPT0gMCB8fCB5TWF4ICE9PSAwID8geU1pbiArIHlNYXggOiBtYXgob3ZlcmZsb3cudG9wLCBvdmVyZmxvdy5ib3R0b20pKSA6IG92ZXJmbG93W2hlaWdodFNpZGVdKSxcbiAgICAgICAgYXZhaWxhYmxlV2lkdGg6IHJlY3RzLmZsb2F0aW5nLndpZHRoIC0gKFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKHBsYWNlbWVudCkgPyAyICogKHhNaW4gIT09IDAgfHwgeE1heCAhPT0gMCA/IHhNaW4gKyB4TWF4IDogbWF4KG92ZXJmbG93LmxlZnQsIG92ZXJmbG93LnJpZ2h0KSkgOiBvdmVyZmxvd1t3aWR0aFNpZGVdKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHByZXZEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50cy5mbG9hdGluZyk7XG4gICAgICBhcHBseSA9PSBudWxsID8gdm9pZCAwIDogYXBwbHkoeyAuLi5taWRkbGV3YXJlQXJndW1lbnRzLFxuICAgICAgICAuLi5kaW1lbnNpb25zXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5leHREaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50cy5mbG9hdGluZyk7XG5cbiAgICAgIGlmIChwcmV2RGltZW5zaW9ucy53aWR0aCAhPT0gbmV4dERpbWVuc2lvbnMud2lkdGggfHwgcHJldkRpbWVuc2lvbnMuaGVpZ2h0ICE9PSBuZXh0RGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgfTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdpbmxpbmUnLFxuICAgIG9wdGlvbnMsXG5cbiAgICBhc3luYyBmbihtaWRkbGV3YXJlQXJndW1lbnRzKSB7XG4gICAgICB2YXIgX2F3YWl0JHBsYXRmb3JtJGdldENsO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0gPSBtaWRkbGV3YXJlQXJndW1lbnRzOyAvLyBBIE1vdXNlRXZlbnQncyBjbGllbnR7WCxZfSBjb29yZHMgY2FuIGJlIHVwIHRvIDIgcGl4ZWxzIG9mZiBhXG4gICAgICAvLyBDbGllbnRSZWN0J3MgYm91bmRzLCBkZXNwaXRlIHRoZSBldmVudCBsaXN0ZW5lciBiZWluZyB0cmlnZ2VyZWQuIEFcbiAgICAgIC8vIHBhZGRpbmcgb2YgMiBzZWVtcyB0byBoYW5kbGUgdGhpcyBpc3N1ZS5cblxuICAgICAgY29uc3Qge1xuICAgICAgICBwYWRkaW5nID0gMixcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlY3RUb0NsaWVudFJlY3QocGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QgPyBhd2FpdCBwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCh7XG4gICAgICAgIHJlY3Q6IHJlY3RzLnJlZmVyZW5jZSxcbiAgICAgICAgb2Zmc2V0UGFyZW50OiBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pIDogcmVjdHMucmVmZXJlbmNlKTtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3RzID0gKF9hd2FpdCRwbGF0Zm9ybSRnZXRDbCA9IGF3YWl0IChwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMoZWxlbWVudHMucmVmZXJlbmNlKSkpICE9IG51bGwgPyBfYXdhaXQkcGxhdGZvcm0kZ2V0Q2wgOiBbXTtcbiAgICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRTaWRlT2JqZWN0RnJvbVBhZGRpbmcocGFkZGluZyk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPT09IDIgJiYgY2xpZW50UmVjdHNbMF0ubGVmdCA+IGNsaWVudFJlY3RzWzFdLnJpZ2h0ICYmIHggIT0gbnVsbCAmJiB5ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2NsaWVudFJlY3RzJGZpbmQ7XG5cbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCByZWN0IGluIHdoaWNoIHRoZSBwb2ludCBpcyBmdWxseSBpbnNpZGVcbiAgICAgICAgICByZXR1cm4gKF9jbGllbnRSZWN0cyRmaW5kID0gY2xpZW50UmVjdHMuZmluZChyZWN0ID0+IHggPiByZWN0LmxlZnQgLSBwYWRkaW5nT2JqZWN0LmxlZnQgJiYgeCA8IHJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0ICYmIHkgPiByZWN0LnRvcCAtIHBhZGRpbmdPYmplY3QudG9wICYmIHkgPCByZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSkgIT0gbnVsbCA/IF9jbGllbnRSZWN0cyRmaW5kIDogZmFsbGJhY2s7XG4gICAgICAgIH0gLy8gVGhlcmUgYXJlIDIgb3IgbW9yZSBjb25uZWN0ZWQgcmVjdHNcblxuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGlmIChnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFJlY3QgPSBjbGllbnRSZWN0c1swXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBpc1RvcCA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ3RvcCc7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBmaXJzdFJlY3QudG9wO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gbGFzdFJlY3QuYm90dG9tO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlzVG9wID8gZmlyc3RSZWN0LmxlZnQgOiBsYXN0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBpc1RvcCA/IGZpcnN0UmVjdC5yaWdodCA6IGxhc3RSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpc0xlZnRTaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAnbGVmdCc7XG4gICAgICAgICAgY29uc3QgbWF4UmlnaHQgPSBtYXgoLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICAgICAgICAgIGNvbnN0IG1pbkxlZnQgPSBtaW4oLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gICAgICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKHJlY3QgPT4gaXNMZWZ0U2lkZSA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0KTtcbiAgICAgICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSBtaW5MZWZ0O1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNldFJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0aW5nOiBlbGVtZW50cy5mbG9hdGluZyxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVjdHMucmVmZXJlbmNlLnggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnggfHwgcmVjdHMucmVmZXJlbmNlLnkgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnkgfHwgcmVjdHMucmVmZXJlbmNlLndpZHRoICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS53aWR0aCB8fCByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHJlc2V0UmVjdHNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgfTtcbn07XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcmVjdFRvQ2xpZW50UmVjdCwgc2hpZnQsIHNpemUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs\n"));

/***/ }),

/***/ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"arrow\": function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow; },\n/* harmony export */   \"autoPlacement\": function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement; },\n/* harmony export */   \"autoUpdate\": function() { return /* binding */ autoUpdate; },\n/* harmony export */   \"computePosition\": function() { return /* binding */ computePosition; },\n/* harmony export */   \"detectOverflow\": function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow; },\n/* harmony export */   \"flip\": function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip; },\n/* harmony export */   \"getOverflowAncestors\": function() { return /* binding */ getOverflowAncestors; },\n/* harmony export */   \"hide\": function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide; },\n/* harmony export */   \"inline\": function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline; },\n/* harmony export */   \"limitShift\": function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift; },\n/* harmony export */   \"offset\": function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset; },\n/* harmony export */   \"shift\": function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift; },\n/* harmony export */   \"size\": function() { return /* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size; }\n/* harmony export */ });\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ \"./node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs\");\n\n\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)\n  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  //  Always-visible scrollbar or not\n  //  Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize: _ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestorResize = _ancestorResize && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return () => {\n    var _observer;\n\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {\n  platform,\n  ...options\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5icm93c2VyLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUEyRjtBQUNtQzs7QUFFOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsbUVBQWdCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLG1FQUFnQjtBQUN6QixFQUFFO0FBQ0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsa0VBQWlCO0FBQzNFO0FBQ0E7QUFDQSxDQUFDOztBQUU0RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5icm93c2VyLm1qcz8yYTcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlY3RUb0NsaWVudFJlY3QsIGNvbXB1dGVQb3NpdGlvbiBhcyBjb21wdXRlUG9zaXRpb24kMSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2NvcmUnO1xuXG5mdW5jdGlvbiBpc1dpbmRvdyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuZG9jdW1lbnQgJiYgdmFsdWUubG9jYXRpb24gJiYgdmFsdWUuYWxlcnQgJiYgdmFsdWUuc2V0SW50ZXJ2YWw7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmICghaXNXaW5kb3cobm9kZSkpIHtcbiAgICBjb25zdCBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIHJldHVybiBpc1dpbmRvdyhub2RlKSA/ICcnIDogbm9kZSA/IChub2RlLm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogJyc7XG59XG5cbmZ1bmN0aW9uIGdldFVBU3RyaW5nKCkge1xuICBjb25zdCB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcykge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChpdGVtID0+IGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbikuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5IVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlO1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBgU2hhZG93Um9vdGAgc3VwcG9ydFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbGVtZW50KSB7XG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgY29uc3Qge1xuICAgIG92ZXJmbG93LFxuICAgIG92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1lcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KTtcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG59XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpO1xufVxuZnVuY3Rpb24gaXNDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICAvLyBUT0RPOiBUcnkgYW5kIHVzZSBmZWF0dXJlIGRldGVjdGlvbiBoZXJlIGluc3RlYWRcbiAgY29uc3QgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gIHJldHVybiBjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgLy8gQHRzLWlnbm9yZSAoVFMgNC4xIGNvbXBhdClcbiAgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmNsdWRlcyhjc3Mud2lsbENoYW5nZSkgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgKGNzcy5maWx0ZXIgPyBjc3MuZmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSk7XG59XG5mdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICAvLyBOb3QgU2FmYXJpXG4gIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChnZXRVQVN0cmluZygpKTsgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZm9yIHRoaXMgZmFpbHMgaW4gdmFyaW91cyB3YXlzXG4gIC8vIOKAoiBBbHdheXMtdmlzaWJsZSBzY3JvbGxiYXIgb3Igbm90XG4gIC8vIOKAoiBXaWR0aCBvZiA8aHRtbD4sIGV0Yy5cbiAgLy8gY29uc3QgdlYgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIC8vIHJldHVybiB2ViA/IE1hdGguYWJzKHdpbi5pbm5lcldpZHRoIC8gdlYuc2NhbGUgLSB2Vi53aWR0aCkgPCAwLjUgOiB0cnVlO1xufVxuXG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgdmFyIF93aW4kdmlzdWFsVmlld3BvcnQkbywgX3dpbiR2aXN1YWxWaWV3cG9ydCwgX3dpbiR2aXN1YWxWaWV3cG9ydCRvMiwgX3dpbiR2aXN1YWxWaWV3cG9ydDI7XG5cbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBsZXQgc2NhbGVYID0gMTtcbiAgbGV0IHNjYWxlWSA9IDE7XG5cbiAgaWYgKGluY2x1ZGVTY2FsZSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgc2NhbGVYID0gZWxlbWVudC5vZmZzZXRXaWR0aCA+IDAgPyByb3VuZChjbGllbnRSZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSA6IDE7XG4gICAgc2NhbGVZID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwID8gcm91bmQoY2xpZW50UmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSA6IDE7XG4gIH1cblxuICBjb25zdCB3aW4gPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3c7XG4gIGNvbnN0IGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgY29uc3QgeCA9IChjbGllbnRSZWN0LmxlZnQgKyAoYWRkVmlzdWFsT2Zmc2V0cyA/IChfd2luJHZpc3VhbFZpZXdwb3J0JG8gPSAoX3dpbiR2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW4kdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCkgIT0gbnVsbCA/IF93aW4kdmlzdWFsVmlld3BvcnQkbyA6IDAgOiAwKSkgLyBzY2FsZVg7XG4gIGNvbnN0IHkgPSAoY2xpZW50UmVjdC50b3AgKyAoYWRkVmlzdWFsT2Zmc2V0cyA/IChfd2luJHZpc3VhbFZpZXdwb3J0JG8yID0gKF93aW4kdmlzdWFsVmlld3BvcnQyID0gd2luLnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbiR2aXN1YWxWaWV3cG9ydDIub2Zmc2V0VG9wKSAhPSBudWxsID8gX3dpbiR2aXN1YWxWaWV3cG9ydCRvMiA6IDAgOiAwKSkgLyBzY2FsZVk7XG4gIGNvbnN0IHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlWDtcbiAgY29uc3QgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICByZXR1cm4gKChpc05vZGUobm9kZSkgPyBub2RlLm93bmVyRG9jdW1lbnQgOiBub2RlLmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQucGFnZVhPZmZzZXQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnBhZ2VZT2Zmc2V0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldE5vZGVTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn1cblxuZnVuY3Rpb24gaXNTY2FsZWQoZWxlbWVudCkge1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpO1xuICByZXR1cm4gcm91bmQocmVjdC53aWR0aCkgIT09IGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgcm91bmQocmVjdC5oZWlnaHQpICE9PSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZWxlbWVudCwgb2Zmc2V0UGFyZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgLy8gQHRzLWlnbm9yZSAtIGNoZWNrZWQgYWJvdmUgKFRTIDQuMSBjb21wYXQpXG4gIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIGlzU2NhbGVkKG9mZnNldFBhcmVudCksIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgc3RyYXRlZ3kgIT09ICdmaXhlZCcpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBub2RlLmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIG5vZGUucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KG5vZGUpID8gbm9kZS5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIGdldERvY3VtZW50RWxlbWVudChub2RlKSAvLyBmYWxsYmFja1xuXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICBsZXQgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFbJ2h0bWwnLCAnYm9keSddLmluY2x1ZGVzKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkpIHtcbiAgICBpZiAoaXNDb250YWluaW5nQmxvY2soY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWxlbWVudCkge1xuICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuXG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG5cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgc3RyYXRlZ3kgIT09ICdmaXhlZCcpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSAvLyBUaGlzIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIG5lZWQgdG8gYmUgbmVnYXRlZC5cbiAgICAvLyBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAvLyAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICAvLyB9XG5cbiAgfVxuXG4gIHJldHVybiB7IC4uLnJlY3QsXG4gICAgeDogcmVjdC54IC0gc2Nyb2xsLnNjcm9sbExlZnQgKyBvZmZzZXRzLngsXG4gICAgeTogcmVjdC55IC0gc2Nyb2xsLnNjcm9sbFRvcCArIG9mZnNldHMueVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgbGV0IHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCBsYXlvdXRWaWV3cG9ydCA9IGlzTGF5b3V0Vmlld3BvcnQoKTtcblxuICAgIGlmIChsYXlvdXRWaWV3cG9ydCB8fCAhbGF5b3V0Vmlld3BvcnQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgY29uc3QgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIGxldCB4ID0gLXNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC1zY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlJDEoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUobm9kZSk7XG5cbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKHBhcmVudE5vZGUpKSkge1xuICAgIC8vIEB0cy1pZ25vcmUgYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IocGFyZW50Tm9kZSk7XG59XG5cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKG5vZGUsIGxpc3QpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvciA9IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09ICgoX25vZGUkb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQuYm9keSk7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhzY3JvbGxhYmxlQW5jZXN0b3IpO1xuICBjb25zdCB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc092ZXJmbG93RWxlbWVudChzY3JvbGxhYmxlQW5jZXN0b3IpID8gc2Nyb2xsYWJsZUFuY2VzdG9yIDogW10pIDogc2Nyb2xsYWJsZUFuY2VzdG9yO1xuICBjb25zdCB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vIEB0cy1pZ25vcmU6IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyh0YXJnZXQpKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICBjb25zdCByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgbGV0IG5leHQgPSBjaGlsZDtcblxuICAgIGRvIHtcbiAgICAgIC8vIHVzZSBgPT09YCByZXBsYWNlIG5vZGUuaXNTYW1lTm9kZSgpXG4gICAgICBpZiAobmV4dCAmJiBwYXJlbnQgPT09IG5leHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIEB0cy1pZ25vcmU6IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgfSB3aGlsZSAobmV4dCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgZmFsc2UsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgY29uc3QgdG9wID0gY2xpZW50UmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgY29uc3QgbGVmdCA9IGNsaWVudFJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmV0dXJuIHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICB4OiBsZWZ0LFxuICAgIHk6IHRvcCxcbiAgICByaWdodDogbGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgYm90dG9tOiB0b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICB3aWR0aDogZWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIHtcbiAgaWYgKGNsaXBwaW5nUGFyZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSk7XG4gIH1cblxuICBpZiAoaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSkge1xuICAgIHJldHVybiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICB9XG5cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgYW5jZXN0b3JcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nQW5jZXN0b3JzKGVsZW1lbnQpIHtcbiAgY29uc3QgY2xpcHBpbmdBbmNlc3RvcnMgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50KTtcbiAgY29uc3QgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5jbHVkZXMoZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uKTtcbiAgY29uc3QgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gQHRzLWlnbm9yZSBpc0VsZW1lbnQgY2hlY2sgZW5zdXJlcyB3ZSByZXR1cm4gQXJyYXk8RWxlbWVudD5cblxuXG4gIHJldHVybiBjbGlwcGluZ0FuY2VzdG9ycy5maWx0ZXIoY2xpcHBpbmdBbmNlc3RvcnMgPT4gaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3JzKSAmJiBjb250YWlucyhjbGlwcGluZ0FuY2VzdG9ycywgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nQW5jZXN0b3JzKSAhPT0gJ2JvZHknKTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgbWFpbkNsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBnZXRDbGlwcGluZ0FuY2VzdG9ycyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nQW5jZXN0b3JzID0gWy4uLm1haW5DbGlwcGluZ0FuY2VzdG9ycywgcm9vdEJvdW5kYXJ5XTtcbiAgY29uc3QgZmlyc3RDbGlwcGluZ0FuY2VzdG9yID0gY2xpcHBpbmdBbmNlc3RvcnNbMF07XG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nQW5jZXN0b3JzLnJlZHVjZSgoYWNjUmVjdCwgY2xpcHBpbmdBbmNlc3RvcikgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBmaXJzdENsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIGhlaWdodDogY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3AsXG4gICAgeDogY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgeTogY2xpcHBpbmdSZWN0LnRvcFxuICB9O1xufVxuXG5jb25zdCBwbGF0Zm9ybSA9IHtcbiAgZ2V0Q2xpcHBpbmdSZWN0LFxuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCxcbiAgaXNFbGVtZW50LFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRPZmZzZXRQYXJlbnQsXG4gIGdldERvY3VtZW50RWxlbWVudCxcbiAgZ2V0RWxlbWVudFJlY3RzOiBfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgcmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmcsXG4gICAgICBzdHJhdGVneVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KGZsb2F0aW5nKSwgc3RyYXRlZ3kpLFxuICAgICAgZmxvYXRpbmc6IHsgLi4uZ2V0RGltZW5zaW9ucyhmbG9hdGluZyksXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBnZXRDbGllbnRSZWN0czogZWxlbWVudCA9PiBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKSksXG4gIGlzUlRMOiBlbGVtZW50ID0+IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KS5kaXJlY3Rpb24gPT09ICdydGwnXG59O1xuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBuZWNlc3NhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1VwZGF0ZVxuICovXG5mdW5jdGlvbiBhdXRvVXBkYXRlKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsOiBfYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplOiBfYW5jZXN0b3JSZXNpemUgPSB0cnVlLFxuICAgIGVsZW1lbnRSZXNpemUgPSB0cnVlLFxuICAgIGFuaW1hdGlvbkZyYW1lID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGFuY2VzdG9yU2Nyb2xsID0gX2FuY2VzdG9yU2Nyb2xsICYmICFhbmltYXRpb25GcmFtZTtcbiAgY29uc3QgYW5jZXN0b3JSZXNpemUgPSBfYW5jZXN0b3JSZXNpemUgJiYgIWFuaW1hdGlvbkZyYW1lO1xuICBjb25zdCBhbmNlc3RvcnMgPSBhbmNlc3RvclNjcm9sbCB8fCBhbmNlc3RvclJlc2l6ZSA/IFsuLi4oaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2UpIDogW10pLCAuLi5nZXRPdmVyZmxvd0FuY2VzdG9ycyhmbG9hdGluZyldIDogW107XG4gIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICB9KTtcbiAgbGV0IG9ic2VydmVyID0gbnVsbDtcblxuICBpZiAoZWxlbWVudFJlc2l6ZSkge1xuICAgIGxldCBpbml0aWFsVXBkYXRlID0gdHJ1ZTtcbiAgICBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICBpZiAoIWluaXRpYWxVcGRhdGUpIHtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBpc0VsZW1lbnQocmVmZXJlbmNlKSAmJiAhYW5pbWF0aW9uRnJhbWUgJiYgb2JzZXJ2ZXIub2JzZXJ2ZShyZWZlcmVuY2UpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICB9XG5cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuXG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJhbWVMb29wKCkge1xuICAgIGNvbnN0IG5leHRSZWZSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSk7XG5cbiAgICBpZiAocHJldlJlZlJlY3QgJiYgKG5leHRSZWZSZWN0LnggIT09IHByZXZSZWZSZWN0LnggfHwgbmV4dFJlZlJlY3QueSAhPT0gcHJldlJlZlJlY3QueSB8fCBuZXh0UmVmUmVjdC53aWR0aCAhPT0gcHJldlJlZlJlY3Qud2lkdGggfHwgbmV4dFJlZlJlY3QuaGVpZ2h0ICE9PSBwcmV2UmVmUmVjdC5oZWlnaHQpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG5cbiAgICBwcmV2UmVmUmVjdCA9IG5leHRSZWZSZWN0O1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWVMb29wKTtcbiAgfVxuXG4gIHVwZGF0ZSgpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBfb2JzZXJ2ZXI7XG5cbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUpO1xuICAgICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgICB9KTtcbiAgICAoX29ic2VydmVyID0gb2JzZXJ2ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIG9ic2VydmVyID0gbnVsbDtcblxuICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSByZWZlcmVuY2UgZWxlbWVudCB3aGVuIGl0IGlzIGdpdmVuIGEgY2VydGFpbiBDU1MgcG9zaXRpb25pbmdcbiAqIHN0cmF0ZWd5LlxuICovXG5cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiBjb21wdXRlUG9zaXRpb24kMShyZWZlcmVuY2UsIGZsb2F0aW5nLCB7XG4gIHBsYXRmb3JtLFxuICAuLi5vcHRpb25zXG59KTtcblxuZXhwb3J0IHsgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBnZXRPdmVyZmxvd0FuY2VzdG9ycyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs\n"));

/***/ })

}]);